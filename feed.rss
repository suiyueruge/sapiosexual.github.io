<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>3apio储存罐</title><description>桂康佳的个人博客,Swift,Swift UI,iOS APP</description><link>http://www.fatbobman.com</link><language>zh</language><lastBuildDate>Tue, 30 Mar 2021 18:06:58 +0800</lastBuildDate><pubDate>Tue, 30 Mar 2021 18:06:58 +0800</pubDate><ttl>250</ttl><atom:link href="http://www.fatbobman.com/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swiftui-ipad</guid><title>在SwiftUI下对iPad进行适配</title><description>SwiftUI创建初衷之一便是可以高效、可靠的适配多个苹果的硬件平台。在健康笔记2.0开发初始，适配iPad便是我本次的设计目标之一。本文并非教程，只是我在进行本次开发中，对于适配iPad的一些教训和心得。</description><link>http://www.fatbobman.com/posts/swiftui-ipad</link><pubDate>Thu, 29 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI创建初衷之一便是可以高效、可靠的适配多个苹果的硬件平台。在健康笔记2.0开发初始，适配iPad便是我本次的设计目标之一。本文并非教程，只是我在进行本次开发中，对于适配iPad的一些教训和心得。</p></blockquote><h2>我是谁</h2><p>app中的代码必须能高效、清晰的了解当前设备的状况，时刻搞清楚我是谁，我在哪，在干啥等等。因此在项目开始之初我便做了不少的准备并创建了一系列的代码。</p><p>比如，当前的运行设备：</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Device</span> </span>{
    <span class="hljs-comment">//MARK:当前设备类型 iphone ipad mac</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Devicetype</span></span>{
        <span class="hljs-keyword">case</span> iphone,ipad,mac
    }
    
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> deviceType:<span class="hljs-type">Devicetype</span>{
        #<span class="hljs-keyword">if</span> os(macOS)
        <span class="hljs-keyword">return</span> .mac
        #<span class="hljs-keyword">else</span>
        <span class="hljs-keyword">if</span>  <span class="hljs-type">UIDevice</span>.current.userInterfaceIdiom == .pad {
            <span class="hljs-keyword">return</span> .ipad
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> .iphone
        }
        #endif
 }
</code></pre><p>如果想要具体了解当前运行设备的型号，Github上有人提供了代码可以返回更精准的信息。</p><p>为了能够在View中方便的利用这些状态信息应对不同的情况，还需要继续做些准备。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">ViewBuilder</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ifIs</span>&lt;T&gt;<span class="hljs-params">(<span class="hljs-number">_</span> condition: Bool, transform: <span class="hljs-params">(<span class="hljs-keyword">Self</span>)</span></span></span> -&gt; <span class="hljs-type">T</span>) -&gt; some <span class="hljs-type">View</span> <span class="hljs-keyword">where</span> <span class="hljs-type">T</span>: <span class="hljs-type">View</span> {
        <span class="hljs-keyword">if</span> condition {
            transform(<span class="hljs-keyword">self</span>)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">self</span>
        }
    }
    
    @<span class="hljs-type">ViewBuilder</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ifElse</span>&lt;T:View,V:View&gt;<span class="hljs-params">( <span class="hljs-number">_</span> condition:Bool,isTransform:<span class="hljs-params">(<span class="hljs-keyword">Self</span>)</span></span></span> -&gt; <span class="hljs-type">T</span>,elseTransform:(<span class="hljs-type">Self</span>) -&gt; <span class="hljs-type">V</span>) -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">if</span> condition {
            isTransform(<span class="hljs-keyword">self</span>)
        } <span class="hljs-keyword">else</span> {
            elseTransform(<span class="hljs-keyword">self</span>)
        }
    }
}
</code></pre><p>这两段是我使用非常频繁的代码，在SwiftUI下，利用类似的代码可以非常容易的利用同一段代码应对各种不同的状况。</p><p>例如：</p><pre data-language="swift"><code><span class="hljs-type">VStack</span>{
     <span class="hljs-type">Text</span>(<span class="hljs-string">"hello world"</span>)
}
.ifIs(<span class="hljs-type">Deivce</span>.deviceType == .iphone){
  $<span class="hljs-number">0</span>.frame(width:<span class="hljs-number">150</span>)
}
.ifIs(<span class="hljs-type">Device</span>.deviceType == .ipad){
  $<span class="hljs-number">0</span>.frame(width:<span class="hljs-number">300</span>)
}
.ifIs(<span class="hljs-type">Device</span>.deviceType == .mac){
  $<span class="hljs-number">0</span>.frmae(minWidth:<span class="hljs-number">200</span>,maxWidth:<span class="hljs-number">600</span>)
}
</code></pre><p>只有解决了我是谁的问题，后面的工作才能更好的展开</p><h2>躺着还是站着</h2><p>因为健康笔记以列表被主要表现形式的app，最初所以我希望在iphone上始终保持Portrait，在ipad上保持Landscape的形式。不过最终还是决定让其在ipad上同时支持Portrait和Landscape。</p><img src="http://cdn.fatbobman.com/swiftui-ipad-ipadiPhone.png" alt="ipadiphone"/><p>为了更灵活的处理，我没有选择在info.plist中对其进行设定，而是通过在delegate中，针对不同的情况作出响应。</p><img src="http://cdn.fatbobman.com/swiftui-ipad-xcode.png" alt="xcode"/><p>因为无需支持多窗口，所以关闭了multiple windows。另外需要激活Requires full screen才能让delegate作出响应</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span>:<span class="hljs-title">NSObject</span>,<span class="hljs-title">UIApplicationDelegate</span></span>{
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">application</span><span class="hljs-params">(<span class="hljs-number">_</span> application: UIApplication, supportedInterfaceOrientationsFor window: UIWindow?)</span></span> -&gt; <span class="hljs-type">UIInterfaceOrientationMask</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">Device</span>.deviceType == .ipad
            ? <span class="hljs-type">UIInterfaceOrientationMask</span>.all
            : <span class="hljs-type">UIInterfaceOrientationMask</span>.portrait
    }
}
</code></pre><p>在SwiftUI下如何设置Delegate请查看<a href="http://www.fatbobman.com/posts/swiftui2-new-feature-1/">SwiftUI2.0 —— App、Scene及新的代码结构</a></p><p>如此便可以方便的控制自己想要的app呈现形态了。</p><h2>难以控制的NavigationView</h2><p>SwiftUI的NavigationView本身为了适配做了不少的工作，但效果并不好。</p><p>目前它支持两种style： StackNavigationView、DoubleColumnNavigationViewStyle，三种表现形式：单列、双列、以及三列（sidebar）。虽然看似覆盖了多数的应用，但由于没有提供更多的控制选项，因此用起来并不顺手。</p><p>比如，DoubleColumnNavigationViewStyle，在ipad上的竖屏和横屏时的呈现是不同的。左上角的隐藏按钮不可更改，不可取消。在包含sidebar的三列模式下，逻辑又有不同，不过按钮同样不提供任何替换、取消的能力。</p><p>NavigationLink只能在当前列中响应，另外并不提供控制列宽的能力。</p><p>如果想调整双列NavigationView的列宽，可以使用Introspect，参见<a href="http://www.fatbobman.com/posts/healthnote2-3rd-package/">介绍几个我在开发健康笔记2用到的Swift或SwiftUI第三方库</a></p><pre data-language="swift"><code><span class="hljs-type">NavigationView</span>{
  <span class="hljs-type">Text</span>(<span class="hljs-string">"hello"</span>)
}
.introspectNavigationController{ navigation <span class="hljs-keyword">in</span>
    navigation.splitViewController?.maximumPrimaryColumnWidth = <span class="hljs-number">360</span>
    navigation.splitViewController?.preferredPrimaryColumnWidth = <span class="hljs-number">500.0</span>
}
</code></pre><p>为了能够让ipad在竖屏或横屏状态下都固定呈现双列的模式，并且左侧列不可折叠同时也不能出现我想要的折叠按钮，我使用了一个不得已的手段。伪造了一个双列显示的NavigationView。</p><p>针对不同的设备进入不同的rootView</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HealthNotesApp</span>:<span class="hljs-title">APP</span></span>{
  <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span>{
     rootView()
  }
  
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rootView</span><span class="hljs-params">()</span></span>-&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">switch</span> <span class="hljs-type">Device</span>.deviceType {
        <span class="hljs-keyword">case</span> .ipad:
            <span class="hljs-keyword">return</span> <span class="hljs-type">AnyView</span>(<span class="hljs-type">ContentView_iPad</span>())
        <span class="hljs-keyword">default</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-type">AnyView</span>(<span class="hljs-type">ContentView_iPhone</span>())
        }
    }
}
</code></pre><p>在ContentView_iPad中，使用类似代码伪造一个双列形式</p><pre data-language="swift"><code><span class="hljs-type">HStack</span>(spacing:<span class="hljs-number">0</span>){
      <span class="hljs-type">ItemRootView</span>(item: $item)
           .frame(width:height)
       <span class="hljs-type">Divider</span>()
       <span class="hljs-type">ItemDataRootView</span>()
            .navigationContent()
        }
.edgesIgnoringSafeArea(.all)
</code></pre><p>如此一来便拥有了上面图片中iPad的显示效果。状态基本上同DoubleColumnNavigationViewStyle的形式是完全一致的。分别都可以设置Toolbar，并且分割线也可以贯穿屏幕。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">navigationContent</span><span class="hljs-params">()</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-type">NavigationView</span>{
            <span class="hljs-keyword">self</span>
        }
        .navigationViewStyle(<span class="hljs-type">StackNavigationViewStyle</span>())
    }
}
</code></pre><p>由于在Ipad下右侧列的视图同时被用在iphone下，在iPhone下它是由NavigationLink激活的，所以仍在NavigationView中，但在iPad下，需要明确的将在放置在NavigationView中。通过 .navigationContent，结合上面的isIf，便可以灵活的控制形态了。</p><p>另外需要针对iPhone和ipad的二级View激活进行分别处理,比如</p><pre data-language="swift"><code><span class="hljs-keyword">if</span> <span class="hljs-type">Device</span>.deviceType  == .iphone {
                    <span class="hljs-type">NavigationLink</span>(<span class="hljs-string">""</span>, destination: <span class="hljs-type">ItemDataRootView</span>(), isActive: $gotoDataList).frame(width:<span class="hljs-number">0</span>,height:<span class="hljs-number">0</span>)
            }

<span class="hljs-comment">//在link的button中</span>
<span class="hljs-type">Button</span>(<span class="hljs-string">"Item1"</span>){
   store.item = item
   <span class="hljs-keyword">if</span> <span class="hljs-type">Devie</span>.deviceType == .iphone {
       gotoDataList.toggle()
   }
}

<span class="hljs-comment">//在ItemDataRootView中直接响应store.item即可</span>
</code></pre><h2>Bug还是特别设计？</h2><p>某些SwiftUI的默认控件在iPad和iPhone下的运行效果和预期有较大差别,</p><p>比如ActionSheet:</p><p>当前AlertSheet在运行iOS14的ipad上的显示位置是几乎不可控的。箭头的位置，内容的显示，和预期都有巨大的差别。我不知道以后都会是这样还是目前的Bug。</p><p>个人不推荐当前在iPad上使用ActionSheet。最终只能在iPad下使用Alert替代了ActionSheet。如果一定要使用ActionSheet，popover或许是更好的选择。</p><p>ContextMenu目前在iPad上有响应上的问题，同样的指令在iPhone上没有问题，在iPad上会出现无法获取值的状况。同样不清楚是Bug还是其他原因。</p><p>比如</p><pre data-language="swift"><code><span class="hljs-type">Text</span>(<span class="hljs-string">"click"</span>)
.contextMenu{
  <span class="hljs-type">Button</span>(<span class="hljs-string">"del"</span>){
     delItem = item
     <span class="hljs-type">ShowActionSheet</span>.toggle()
  }
}
.<span class="hljs-type">ActionSheet</span>(isPresented:showActionSheet){
    delSheet(item:delItem)
}
</code></pre><p>这段代码在iphone上执行没有任何问题，不过在ipad上，delsheet很有可能会无法获取item。为了避免这个情况，目前只能做些特殊处理</p><pre data-language="swift"><code><span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">0.5</span>){
                  showActionSheet.wrappedValue = <span class="hljs-literal">true</span>
}
</code></pre><p>类似上述的问题还有一些，只有当代码在ipad上跑起来多做测试才会发现其中的问题。</p><h2>布局优化</h2><p>由于健康笔记2.0在iPad上显示的左右两列，所以本来在iphone下运行没有问题View,在iPad下就会出现左右不对齐，不对称等问题。所以只要多调试，采用isIf多做处理，问题基本上都会比较容易获得解决。</p><p>仅举一例：</p><pre data-language="swift"><code><span class="hljs-type">List</span>{
   ...
}
.listStyle(<span class="hljs-type">InsetGroupedListStyle</span>())
</code></pre><p>当它在iphone上作为独占屏幕的View时，显示很完美，但当它显示在IPad的右侧列时，Group上方的留空和左侧列的就不对齐，做点处理就ok了。</p><h2>结尾</h2><p>总之使用SwiftUI适配iPhone和iPad总体来说还是比较容易的。能否充分利用好各自设备的特点主要还是要在交互逻辑和UI设计上多下功夫，代码上的难度不大。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/coredata-in-swiftui</guid><title>聊一下在SwiftUI中使用CoreData</title><description>本文并非一个教你如何在SwiftUI下使用CoreData的教程。主要探讨的是在我近一年的SwiftUI开发中使用CoreData的教训、经验、心得。</description><link>http://www.fatbobman.com/posts/coredata-in-swiftui</link><pubDate>Wed, 28 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文并非一个教你如何在SwiftUI下使用CoreData的教程。主要探讨的是在我近一年的SwiftUI开发中使用CoreData的教训、经验、心得。</p></blockquote><h2>SwiftUI lifecycle 中如何声明持久化存储和上下文</h2><p>在XCode12中，苹果新增了SwiftUI lifecycle，让App完全的SwiftUI化。不过这就需要我们使用新的方法来声明持久化存储和上下文。</p><p>好像是从beta6开始，XCode 12提供了基于SwiftUI lifecycle的CoreData模板</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CoreDataTestApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-comment">//持久化声明</span>
    <span class="hljs-keyword">let</span> persistenceController = <span class="hljs-type">PersistenceController</span>.shared

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">ContentView</span>()
                .environment(\.managedObjectContext, persistenceController.container.viewContext)  
          <span class="hljs-comment">//上下文注入</span>
        }
    }
}
</code></pre><p>在它的Presitence中，添加了用于preview的持久化定义</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PersistenceController</span> </span>{
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> shared = <span class="hljs-type">PersistenceController</span>()

    <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> preview: <span class="hljs-type">PersistenceController</span> = {
        <span class="hljs-keyword">let</span> result = <span class="hljs-type">PersistenceController</span>(inMemory: <span class="hljs-literal">true</span>)
        <span class="hljs-keyword">let</span> viewContext = result.container.viewContext
        <span class="hljs-comment">//根据你的实际需要，创建用于preview的数据</span>
        <span class="hljs-keyword">for</span> <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span> {
            <span class="hljs-keyword">let</span> newItem = <span class="hljs-type">Item</span>(context: viewContext)
            newItem.timestamp = <span class="hljs-type">Date</span>()
        }
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">try</span> viewContext.save()
        } <span class="hljs-keyword">catch</span> {
            <span class="hljs-keyword">let</span> nsError = error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError</span>
            <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"Unresolved error \(nsError), \(nsError.userInfo)"</span>)
        }
        <span class="hljs-keyword">return</span> result
    }()

    <span class="hljs-keyword">let</span> container: <span class="hljs-type">NSPersistentCloudKitContainer</span>
    <span class="hljs-comment">//如果是用于preview便将数据保存在内存而非sqlite中</span>
    <span class="hljs-keyword">init</span>(inMemory: <span class="hljs-type">Bool</span> = <span class="hljs-literal">false</span>) {
        container = <span class="hljs-type">NSPersistentCloudKitContainer</span>(name: <span class="hljs-string">"Shared"</span>)
        <span class="hljs-keyword">if</span> inMemory {
            container.persistentStoreDescriptions.first!.url = <span class="hljs-type">URL</span>(fileURLWithPath: <span class="hljs-string">"/dev/null"</span>)
        }
        container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error = error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError?</span> {
                <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"Unresolved error \(error), \(error.userInfo)"</span>)
            }
        })
    }
}
</code></pre><p>虽然对于用于preview的持久化设置并不完美，不过苹果也意识到了在SwiftUI1.0中的一个很大问题，无法preview使用了@FetchRequest的视图。</p><p>由于在官方CoreData模板出现前，我已经开始了我的项目构建，因此，我使用了下面的方式来声明</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HealthNotesApp</span>:<span class="hljs-title">App</span></span>{
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> coreDataStack = <span class="hljs-type">CoreDataStack</span>(modelName: <span class="hljs-string">"Model"</span>) <span class="hljs-comment">//Model.xcdatemodeld</span>
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">let</span> context = <span class="hljs-type">DataNoteApp</span>.coreDataStack.managedContext
  <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> storeRoot = <span class="hljs-type">Store</span>() 
   @<span class="hljs-type">UIApplicationDelegateAdaptor</span>(<span class="hljs-type">AppDelegate</span>.<span class="hljs-keyword">self</span>) <span class="hljs-keyword">var</span> delegate
  <span class="hljs-type">WindowGroup</span> {
        rootView()
            .environmentObject(store)
            .environment(\.managedObjectContext, <span class="hljs-type">DataNoteApp</span>.context)
  }
}
</code></pre><p>在UIKit App Delegate中，我们可以使用如下代码在App任意位置获取上下文</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> context = (<span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as</span>! <span class="hljs-type">AppDelegate</span>).persistentContainer.viewContext
</code></pre><p>但由于我们已经没有办法在SwiftUI lifecycle中如此使用，通过上面的声明我们可以利用下面的方法在全局获取想要的上下文或其他想要获得的对象</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> context = <span class="hljs-type">HealthNotesApp</span>.context
</code></pre><p>比如在 delegate中</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span>:<span class="hljs-title">NSObject</span>,<span class="hljs-title">UIApplicationDelegate</span></span>{
    
    <span class="hljs-keyword">let</span> send = <span class="hljs-type">HealthNotesApp</span>.storeRoot.send
    
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">application</span><span class="hljs-params">(<span class="hljs-number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: <span class="hljs-keyword">Any</span>]?)</span></span> -&gt; <span class="hljs-type">Bool</span> {
       
        logDebug(<span class="hljs-string">"app startup on ios"</span>)
       
        send(.loadNote)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">applicationDidFinishLaunching</span><span class="hljs-params">(<span class="hljs-number">_</span> application: UIApplication)</span></span>{
        
        logDebug(<span class="hljs-string">"app quit on ios"</span>)
        send(.counter(.save))

    }

}

<span class="hljs-comment">//或者直接操作数据库，都是可以的</span>
</code></pre><h2>如何动态设置 @FetchRequest</h2><p>在SwiftUI中，如果无需复杂的数据操作，使用CoreData是非常方便的。在完成xcdatamodeld的设置后，我们就可以在View中轻松的操作数据了。</p><p>我们通常使用如下语句来获取某个entity的数据</p><pre data-language="swift"><code>@<span class="hljs-type">FetchRequest</span>(sortDescriptors: [<span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">Student</span>.studentId, ascending: <span class="hljs-literal">true</span>)],
              predicate:<span class="hljs-type">NSPredicate</span>(format: <span class="hljs-string">"age &gt; 10"</span>),
              animation: .<span class="hljs-keyword">default</span>) 
<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> students: <span class="hljs-type">FetchedResults</span>&lt;<span class="hljs-type">Student</span>&gt;
</code></pre><p>不过如此使用的话，查询条件将无法改变，如果想根据需要调整查询条件，可以使用下面的方法。</p><p>健康笔记2中的部分代码：</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rootView</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> predicate:<span class="hljs-type">NSPredicate?</span> = <span class="hljs-literal">nil</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">sort</span> = <span class="hljs-type">NSSortDescriptor</span>(key: <span class="hljs-string">"date"</span>, ascending: <span class="hljs-literal">false</span>)
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> searchStore = <span class="hljs-type">SearchStore</span>()
    @<span class="hljs-type">EnvironmentObject</span> <span class="hljs-keyword">var</span> store:<span class="hljs-type">Store</span>
    <span class="hljs-keyword">var</span> body:some <span class="hljs-type">View</span>{
      <span class="hljs-type">VStack</span> {
       <span class="hljs-type">SearchBar</span>(text: $searchStore.searchText) <span class="hljs-comment">//搜索框</span>
       <span class="hljs-type">MemoList</span>(predicate: predicate, <span class="hljs-built_in">sort</span>: <span class="hljs-built_in">sort</span>,searching:searchStore.showSearch)
        }
      .onChange(of: searchStore.text){ <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
          getMemos()
      } 
    }
  
       <span class="hljs-comment">//读取指定范围的memo</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getMemos</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">var</span> predicators:[<span class="hljs-type">NSPredicate</span>] = []
        <span class="hljs-keyword">if</span> !searchStore.searchText.isEmpty &amp;&amp; searchStore.showSearch {
            <span class="hljs-comment">//memo内容或者item名称包含关键字</span>
            predicators.append(<span class="hljs-type">NSPredicate</span>(format: <span class="hljs-string">"itemData.item.name contains[cd] %@ OR content contains[cd] %@"</span>, searchStore.searchText,searchStore.searchText))
        }
        <span class="hljs-keyword">if</span> star {
            predicators.append(<span class="hljs-type">NSPredicate</span>(format: <span class="hljs-string">"star = true"</span>))
        }
        
        <span class="hljs-keyword">switch</span> store.state.memo{
        <span class="hljs-keyword">case</span> .all:
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">case</span> .memo:
            <span class="hljs-keyword">if</span> !searchStore.searchText.isEmpty &amp;&amp; noteOption == <span class="hljs-number">1</span> {
                <span class="hljs-keyword">break</span>
            }
            <span class="hljs-keyword">else</span> {
                predicators.append(<span class="hljs-type">NSPredicate</span>(format: <span class="hljs-string">"itemData.item.note = nil"</span>))
            }
        <span class="hljs-keyword">case</span> .note(<span class="hljs-keyword">let</span> note):
            <span class="hljs-keyword">if</span> !searchStore.searchText.isEmpty &amp;&amp; noteOption == <span class="hljs-number">1</span> {
                <span class="hljs-keyword">break</span>
            }
            <span class="hljs-keyword">else</span> {
                predicators.append(<span class="hljs-type">NSPredicate</span>(format: <span class="hljs-string">"itemData.item.note = %@"</span>, note))
            }
        }
        
        withAnimation(.easeInOut){
            predicate =  <span class="hljs-type">NSCompoundPredicate</span>(type: <span class="hljs-type">NSCompoundPredicate</span>.<span class="hljs-type">LogicalType</span>.and, subpredicates: predicators)
            <span class="hljs-built_in">sort</span> =  <span class="hljs-type">NSSortDescriptor</span>(key: <span class="hljs-string">"date"</span>, ascending: ascending)
        }
    }
}
</code></pre><p>上述代码会根据搜索关键字以及一些其他的范围条件，动态的创建predicate，从而获得所需的数据。</p><p>对于类似查询这样的操作，最好配合上Combine来限制数据获取的频次</p><p>例如：</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SearchStore</span>:<span class="hljs-title">ObservableObject</span></span>{
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> searchText = <span class="hljs-string">""</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> text = <span class="hljs-string">""</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> showSearch = <span class="hljs-literal">false</span>
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> cancellables:[<span class="hljs-type">AnyCancellable</span>] = []
    
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">registerPublisher</span><span class="hljs-params">()</span></span>{
        $searchText
            .removeDuplicates()
            .debounce(<span class="hljs-keyword">for</span>: <span class="hljs-number">0.4</span>, scheduler: <span class="hljs-type">DispatchQueue</span>.main)
            .assign(to: &amp;$text)
    }
    
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removePublisher</span><span class="hljs-params">()</span></span>{
        cancellables.removeAll()
    }
    
}
</code></pre><p>上述所有代码均缺失了很大部分，仅做思路上的说明</p><h2>增加转换层方便代码开发</h2><p>在开发健康笔记 1.0的时候我经常被类似下面的代码所烦恼</p><pre data-language="swift"><code>@<span class="hljs-type">FetchRequest</span>(sortDescriptors: [<span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">Student</span>.name, ascending: <span class="hljs-literal">true</span>)],
              animation: .<span class="hljs-keyword">default</span>) 
<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> students: <span class="hljs-type">FetchedResults</span>&lt;<span class="hljs-type">Student</span>&gt;

<span class="hljs-type">ForEach</span>(students){ student <span class="hljs-keyword">in</span>
  <span class="hljs-type">Text</span>(student.name ?? <span class="hljs-string">""</span>)
  <span class="hljs-type">Text</span>(<span class="hljs-type">String</span>(student.date ?? <span class="hljs-type">Date</span>()))
}
</code></pre><p>在CoreData中，设置Attribute，很多时候并不能完全如愿。</p><p>好几个类型是可选的，比如String，UUID等，如果在已发布的app，将新增的attribute其改为不可选，并设置默认值，将极大的增加迁移的难度。另外，如果使用了NSPersistentCloudKitContainer,由于Cloudkit的atrribute和CoreData并不相同，XCode会强制你将很多Attribute改成你不希望的样式。</p><p>为了提高开发效率，并为未来的修改留出灵活、充分的更改空间，在健康笔记2.0的开发中，我为每个NSManagedObject都增加了一个便于在View和其他数据操作中使用的中间层。</p><p>例如：</p><pre data-language="swift"><code><span class="hljs-meta">@objc</span>(<span class="hljs-type">Student</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>: <span class="hljs-title">NSManagedObject</span>,<span class="hljs-title">Identifiable</span> </span>{
    <span class="hljs-meta">@NSManaged</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> name: <span class="hljs-type">String?</span>
    @<span class="hljs-type">NSmanaged</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> birthdate: <span class="hljs-type">Date?</span>
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StudentViewModel</span>: <span class="hljs-title">Identifiable</span></span>{
    <span class="hljs-keyword">let</span> name:<span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> birthdate:<span class="hljs-type">String</span>
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Student</span></span>{
   <span class="hljs-keyword">var</span> viewModel:<span class="hljs-type">StudentViewModel</span>(
        name:name ?? <span class="hljs-string">""</span>
        birthdate:(birthdate ?? <span class="hljs-type">Date</span>()).<span class="hljs-built_in">toString</span>() <span class="hljs-comment">//举例</span>
   )
  
}
</code></pre><p>如此一来，在View中调用将非常方便，同时即使更改entity的设置，整个程序的代码修改量也将显著降低。</p><pre data-language="swift"><code><span class="hljs-type">ForEach</span>(students){ student <span class="hljs-keyword">in</span>
  <span class="hljs-keyword">let</span> student = student.viewModel
  <span class="hljs-type">Text</span>(student.name)
  <span class="hljs-type">Text</span>(student.birthdate)
}
</code></pre><p>同时，对于数据的其他操作，我也都通过这个viewModel来完成。</p><p>比如：</p><pre data-language="swift"><code><span class="hljs-comment">//MARK:通过ViewModel生成Note数据,所有的prepare动作都需要显示调用 _coreDataSave()</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">_prepareNote</span><span class="hljs-params">(<span class="hljs-number">_</span> viewModel:NoteViewModel)</span></span> -&gt; <span class="hljs-type">Note</span>{
        <span class="hljs-keyword">let</span> note = <span class="hljs-type">Note</span>(context: context )
        note.id = viewModel.id 
        note.index = <span class="hljs-type">Int32</span>(viewModel.index)  
        note.createDate = viewModel.createDate  
        note.name = viewModel.name 
        note.source = <span class="hljs-type">Int32</span>(viewModel.source)  
        note.descriptionContent = viewModel.descriptionContent 
        note.color = viewModel.color.rawValue 
        <span class="hljs-keyword">return</span> note
    }
    
    <span class="hljs-comment">//MARK:更新Note数据,仍需显示调用save</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">_updateNote</span><span class="hljs-params">(<span class="hljs-number">_</span> note:Note,<span class="hljs-number">_</span> viewModel:NoteViewModel)</span></span> -&gt; <span class="hljs-type">Note</span> {
        note.name = viewModel.name
        note.source = <span class="hljs-type">Int32</span>(viewModel.source)
        note.descriptionContent = viewModel.descriptionContent
        note.color = viewModel.color.rawValue
        <span class="hljs-keyword">return</span> note
    }

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newNote</span><span class="hljs-params">(noteViewModel:NoteViewModel)</span></span> -&gt; <span class="hljs-type">AnyPublisher</span>&lt;<span class="hljs-type">AppAction</span>,<span class="hljs-type">Never</span>&gt; {
       <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = _prepareNote(noteViewModel)
       <span class="hljs-keyword">if</span>  !_coreDataSave() {
            logDebug(<span class="hljs-string">"新建Note出现错误"</span>)
       }
       <span class="hljs-keyword">return</span> <span class="hljs-type">Just</span>(<span class="hljs-type">AppAction</span>.<span class="hljs-keyword">none</span>).eraseToAnyPublisher()
    }
    
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">editNote</span><span class="hljs-params">(note:Note,newNoteViewModel:NoteViewModel)</span></span> -&gt; <span class="hljs-type">AnyPublisher</span>&lt;<span class="hljs-type">AppAction</span>,<span class="hljs-type">Never</span>&gt;{
        <span class="hljs-keyword">let</span> <span class="hljs-number">_</span> = _updateNote(note, newNoteViewModel)
        <span class="hljs-keyword">if</span> !_coreDataSave() {
            logDebug(<span class="hljs-string">"更新Note出现错误"</span>)
        }
        <span class="hljs-keyword">return</span> <span class="hljs-type">Just</span>(<span class="hljs-type">AppAction</span>.<span class="hljs-keyword">none</span>).eraseToAnyPublisher()
}
</code></pre><p>在View中调用</p><pre data-language="swift"><code><span class="hljs-type">Button</span>(<span class="hljs-string">"New"</span>){
      <span class="hljs-keyword">let</span> noteViewModel = <span class="hljs-type">NoteViewModel</span>(createDate: <span class="hljs-type">Date</span>(), descriptionContent: myState.noteDescription, id: <span class="hljs-type">UUID</span>(), index: -<span class="hljs-number">1</span>, name: myState.noteName, source: <span class="hljs-number">0</span>, color: .<span class="hljs-keyword">none</span>)
     store.send(.newNote(noteViewModel: noteViewModel))
     presentationMode.wrappedValue.dismiss()
}
</code></pre><p>从而将可选值或者类型转换控制在最小范围</p><h2>使用NSPersistentCloudKitContainer 需要注意的问题</h2><p>从iOS13开始，苹果提供了NSPersistentCloudKitContainer，让app可以以最简单的方式享有了数据库云同步功能。</p><p>不过在使用中，我们需要注意几个问题。</p><ul><li>Attribute 在上一节提高过，由于Cloudkit的数据设定和CoreData并不完全兼容，因此如果你在项目初始阶段是使用NSPersistentContainer进行开发的，当将代码改成NSPersistentCloudKitContainer后，XCode可能会提示你某些Attribute不兼容的情况。如果你采用了中间层处理数据，修改起来会很方便，否则你需要对已完成的代码做出不少的修改和调整。我通常为了开发调试的效率，只有到最后的时候才会使用NSPersistentCloudKitContainer，因此这个问题会比较突出。</li></ul><ul><li>合并策略 奇怪的是，在XCode的CoreData（点选使用CloudKit）默认模板中，并没有设定合并策略。如果没有设置的话，当app的数据进行云同步时，时长会出现合并错误，并且@FetchRequest也并不会在有数据发生变动时对View进行刷新。因此我们需要自己明确数据的合并策略。</li></ul><pre data-language="swift"><code>      <span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> persistentContainer: <span class="hljs-type">NSPersistentCloudKitContainer</span> = {
          <span class="hljs-keyword">let</span> container = <span class="hljs-type">NSPersistentCloudKitContainer</span>(name: modelName)
          container.loadPersistentStores(completionHandler: { (storeDescription, error) <span class="hljs-keyword">in</span>
              <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> error = error <span class="hljs-keyword">as</span> <span class="hljs-type">NSError?</span> {
                  <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"Unresolved error \(error), \(error.userInfo)"</span>)
              }
          })
          <span class="hljs-comment">//需要显式表明下面的合并策略,否则会出现合并错误!</span>
          container.viewContext.automaticallyMergesChangesFromParent = <span class="hljs-literal">true</span>
          container.viewContext.mergePolicy = <span class="hljs-type">NSMergeByPropertyObjectTrumpMergePolicy</span>
          <span class="hljs-keyword">return</span> container
      }()
</code></pre><ul><li>调试信息 当打开云同步后，在调试信息中将出现大量的数据同步调试信息，严重影响了对于其他调试信息的观察。虽然可以通过启动命令屏蔽掉数据同步信息，但有时候我还是需要对其进行观察的。目前我使用了一个临时的解决方案。</li></ul><pre data-language="swift"><code>  #<span class="hljs-keyword">if</span> !targetEnvironment(macCatalyst) &amp;&amp; canImport(<span class="hljs-type">OSLog</span>)
  <span class="hljs-keyword">import</span> OSLog
  <span class="hljs-keyword">let</span> logger = <span class="hljs-type">Logger</span>.<span class="hljs-keyword">init</span>(subsystem: <span class="hljs-string">"com.fatbobman.DataNote"</span>, category: <span class="hljs-string">"main"</span>) <span class="hljs-comment">//调试用</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">logDebug</span><span class="hljs-params">(<span class="hljs-number">_</span> text:String,enable:Bool = <span class="hljs-literal">true</span>)</span></span>{
      #<span class="hljs-keyword">if</span> <span class="hljs-type">DEBUG</span>
      <span class="hljs-keyword">if</span> enable {
          logger.debug(<span class="hljs-string">"\(text)"</span>)
      }
      #endif
  }
  #<span class="hljs-keyword">else</span>
  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">logDebug</span><span class="hljs-params">(<span class="hljs-number">_</span> text:String,enable:Bool = <span class="hljs-literal">true</span>)</span></span>{
      <span class="hljs-built_in">print</span>(text,<span class="hljs-string">"$$$$"</span>)
  }
  #endif
</code></pre><p>对于需要显示调试信息的地方</p><pre data-language="swift"><code>  logDebug(<span class="hljs-string">"数据格式错误"</span>)
</code></pre><p>然后通过在Debug窗口中将Filter设置为$$$$来屏蔽掉暂时不想看到的其他信息</p><h2>不要用SQL的思维限制了CoreData的能力</h2><p>CoreData虽然主要是采用Sqlite来作为数据存储方案，不过对于它的数据对象操作不要完全套用Sql中的惯用思维。</p><p>一些例子</p><p>排序：</p><pre data-language="swift"><code><span class="hljs-comment">//Sql式的</span>
<span class="hljs-type">NSSortDescriptor</span>(key: <span class="hljs-string">"name"</span>, ascending: <span class="hljs-literal">true</span>)
<span class="hljs-comment">//更CoreData化，不会出现拼写错误</span>
<span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">Student</span>.name, ascending: <span class="hljs-literal">true</span>)
</code></pre><p>在断言中不适用子查询而直接比较对象：</p><pre data-language="swift"><code><span class="hljs-type">NSPredicate</span>(format: <span class="hljs-string">"itemData.item.name = %@"</span>,name)
</code></pre><p>Count:</p><pre data-language="swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">_getCount</span><span class="hljs-params">(entity:String,predicate:NSPredicate?)</span></span> -&gt; <span class="hljs-type">Int</span>{
        <span class="hljs-keyword">let</span> fetchRequest = <span class="hljs-type">NSFetchRequest</span>&lt;<span class="hljs-type">NSNumber</span>&gt;(entityName: entity)  
        fetchRequest.predicate = predicate
        fetchRequest.resultType = .countResultType
        
        <span class="hljs-keyword">do</span> {
            <span class="hljs-keyword">let</span> results  = <span class="hljs-keyword">try</span> context.fetch(fetchRequest)
            <span class="hljs-keyword">let</span> <span class="hljs-built_in">count</span> = results.first!.intValue
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>
        }
        <span class="hljs-keyword">catch</span> {
            #<span class="hljs-keyword">if</span> <span class="hljs-type">DEBUG</span>
            logDebug(<span class="hljs-string">"\(error.localizedDescription)"</span>)
            #endif
            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        }
    }
</code></pre><p>或者更加简单的count</p><pre data-language="swift"><code>@<span class="hljs-type">FetchRequest</span>(sortDescriptors: [<span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">Student</span>.name, ascending: <span class="hljs-literal">true</span>)],
              animation: .<span class="hljs-keyword">default</span>) 
<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> students: <span class="hljs-type">FetchedResults</span>&lt;<span class="hljs-type">Student</span>&gt;

sutudents.<span class="hljs-built_in">count</span>
</code></pre><p>对于数据量不大的情况，我们也可以不采用上面的动态predicate方式，在View中直接对获取后的数据进行操作，比如：</p><pre data-language="swift"><code>@<span class="hljs-type">FetchRequest</span>(sortDescriptors: [<span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">Student</span>.name, ascending: <span class="hljs-literal">true</span>)],
              animation: .<span class="hljs-keyword">default</span>) 
<span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> studentDatas: <span class="hljs-type">FetchedResults</span>&lt;<span class="hljs-type">Student</span>&gt;
@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> students:[<span class="hljs-type">Student</span>] = []
<span class="hljs-keyword">var</span> body:some <span class="hljs-type">View</span>{
  <span class="hljs-type">List</span>{
        <span class="hljs-type">ForEach</span>(students){ student <span class="hljs-keyword">in</span>
           <span class="hljs-type">Text</span>(student.viewModel.name)
         }
        }
        .onReceive(studentDatas.publisher){ <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
            students = studentDatas.<span class="hljs-built_in">filter</span>{ student <span class="hljs-keyword">in</span>
                student.viewModel.age &gt; <span class="hljs-number">10</span>
            }
        }
   }
}
</code></pre><p>总之数据皆对象</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/healthnote2-3rd-package</guid><title>介绍几个我在开发健康笔记2用到的Swift或SwiftUI第三方库</title><description>本文介绍了其中几个在健康笔记开发过程中使用的第三方的开源库</description><link>http://www.fatbobman.com/posts/healthnote2-3rd-package</link><pubDate>Tue, 27 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<h2><a href="https://github.com/SwiftUIX/SwiftUIX">SwiftUIX</a></h2><blockquote><p>SwiftUIX试图弥补仍处于新生阶段的SwiftUI框架的空白，提供了广泛的组件，扩展和实用程序套件来补充标准库。 迄今为止，该项目是缺少的UIKit / AppKit功能的最完整的移植，力求使其以大多数类似于Apple的方式交付。 这个项目的目标是补充SwiftUI标准库，提供数百种扩展和视图，使开发人员可以轻松地通过SwiftUI的革命来构建应用程序。</p></blockquote><p>提供了非常多的苹果本应提供但没有提供的功能扩展。项目的发起者非常年轻，但mac的开发经验十分丰富。到目前为止一直保持的较高的更新频率和维护状态。这个库同时支持UIKit和Appkit，对于需要做苹果生态全平台的用户十分友好。由于目前SwiftUI的List和LazyVStack的问题还很多，他自己在开发中也深受其苦，前天在交流中，他已经决定重做CocoaList功能，尤其提高对Fetchrequest的支持。</p><p>对于进行SwiftUI开发的朋友，它是十分值得推荐的。</p><p>目前的问题是文档太少。不过对我来说也未尝不是一个好事。在研究它的用法过程中，给了我更多的机会阅读并学习它的代码，对SwiftUI，UIkit等有了更多的认识和了解。</p><h2><a href="https://github.com/danielgindi/Charts">Charts</a></h2><blockquote><p>denielgindi对著名的安卓图表库 MPAndroidChart的Swift移植。是目前不多的纯Swift解决方案。它的优势也是同时支持UIKit和Appkit，同时提供了不错的Demo社区活跃度。</p></blockquote><p>不过他的开发者好像不打算在3.x版本上在增加太多的功能，非常多目前急需并且已有解决方案的功能并没有被当前版本接受。所以整体的视觉呈现还是比较传统的。社区上对于功能的讨论不少，但合并的极少，4.0的版本好像也已经开发了不短的时间了，不过进度好像也不是特别理想。</p><p>从效率上讲，Charts应该是非常合格的了。</p><p><a href="https://www.hangge.com">航歌</a> 上面有非常详细的中文使用教程，对我的学习帮助很大。</p><p>为了健康笔记开发的需要，我在当前3.6的版本上合并了两个社区上较为成熟的解决方案：</p><ul><li>圆角Bar</li></ul><pre data-language="swift"><code>  dataSet.roundedCorners = [.topLeft,.topRight]
</code></pre><ul><li>渐变色Bar</li></ul><pre data-language="swift"><code>  dataSet.drawBarGradientEnabled = <span class="hljs-literal">true</span>
              dataSet.colors = [<span class="hljs-type">UIColor</span>(named: <span class="hljs-string">"barColor1"</span>)!, <span class="hljs-type">UIColor</span>(named: <span class="hljs-string">"barColor1"</span>)!, <span class="hljs-type">UIColor</span>(named: <span class="hljs-string">"barColor2"</span>)!]
              dataSet.gradientPositions = [<span class="hljs-number">0</span>, <span class="hljs-number">40</span>, <span class="hljs-number">100</span>]
</code></pre><p>由于当前的Charts本身并不支持对于图表滚动后停止事件的响应，我自己为它增加了停止响应。</p><pre data-language="swift"><code>        <span class="hljs-comment">//滚动终止时调用</span>
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chartScrollStop</span><span class="hljs-params">(<span class="hljs-number">_</span> chartView:ChartViewBase)</span></span>{
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"stopped"</span>)
        }
</code></pre><p>修改后的代码<a href="https://github.com/fatbobman/Charts">在此可以获得</a>。</p><h2><a href="https://github.com/siteline/SwiftUI-Introspect">Introspect</a></h2><blockquote><p>Introspect允许您获取SwiftUI视图的基础UIKit或AppKit元素。 例如，使用Introspect，您可以访问UITableView来修改分隔符，或访问UINavigationController来自定义选项卡栏。</p></blockquote><p>有一个非常推荐的利器。目前官方对于SwiftUI中的控件提供的可控选项很少，如果想做一些深度定制的话，通常就是自己写代码来重新包装UIkit控件。不过introspect提供了一个非常巧妙的办法通过简单的注入方式便可以对SwiftUI控件做更多的调整。</p><p>比如：</p><p>只有当内容超出显示范围才进行滚动</p><pre data-language="swift"><code><span class="hljs-type">ScrollView</span>{
    ....
}
.introspectScrollView{ scrollView <span class="hljs-keyword">in</span>
        crollView.isScrollEnabled = scrollView.contentSize.height &gt; scrollView.frame.height
               }
</code></pre><p>显示TextField的clear按钮</p><pre data-language="swift"><code><span class="hljs-type">TextField</span>(<span class="hljs-string">"note_noteName"</span>,text: $myState.noteName)
          .introspectTextField{ text <span class="hljs-keyword">in</span>
             text.clearButtonMode = .whileEditing
           }
</code></pre><p>对于新的控件它本身还没提供具体支持的也可以方便的注入</p><p>修改SwiftUI2.0中新提供的TextEditor背景色</p><pre data-language="swift"><code><span class="hljs-type">TextEditor</span>(text: $text)
                .introspect(selector: <span class="hljs-type">TargetViewSelector</span>.sibling){ textView <span class="hljs-keyword">in</span>
                    textView.backgroundColor = .clear
                }
</code></pre><p>等等。类似的用法在我整个的开发中的使用频率是很高的。</p><h2><a href="https://github.com/malcommac/SwiftDate">SwiftDate</a></h2><blockquote><p>使用Swift编写的时间日期处理库。同时支持苹果平台以及Linux。</p></blockquote><p>它提供了非常详尽的文档，航哥上也有非常好的中文教程。</p><p>由于健康笔记需要对数据进行不少处理，尤其是需要将相同时间粒度的数据进行合并比较。SwiftDate提供的Region方案提供了完美的解决途径。</p><p>在SwiftDate中，我多数使用它提供的DateInRegion来处理日期。通过</p><pre data-language="swift"><code><span class="hljs-type">SwiftDate</span>.defaultRegion = region
</code></pre><p>我几乎无需关心日期的本地化问题。而且它也提供了部分的日期时间的本地化显示方案（但并不完美）。</p><p>一些使用举例：</p><p>除非用户在app中设定了特定的时区，否则使用当前设备的默认设置：</p><pre data-language="swift"><code><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data = <span class="hljs-type">UserDefaults</span>.standard.data(forKey: <span class="hljs-string">"dateRegion"</span>),
           <span class="hljs-keyword">let</span> region = <span class="hljs-keyword">try</span>? <span class="hljs-type">JSONDecoder</span>().decode(<span class="hljs-type">Region</span>.<span class="hljs-keyword">self</span>, from: data) {
            <span class="hljs-type">SwiftDate</span>.defaultRegion = region
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-type">SwiftDate</span>.defaultRegion = <span class="hljs-type">Region</span>(calendar: <span class="hljs-type">Calendars</span>.gregorian, zone: <span class="hljs-type">Zones</span>.current, locale: <span class="hljs-type">Locales</span>.current)
        }
</code></pre><p>判断某个日期和指定日期的天数差（本地时区）：</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> startDate = <span class="hljs-type">DateInRegion</span>(datas.first!.viewModel.date1).dateTruncated(at: [.hour,.minute,.second])!
duration = date.difference(<span class="hljs-keyword">in</span>: .day, from: startDate) ?? <span class="hljs-number">0</span>
</code></pre><p>如果你的程序需要对日期进行频繁的处理或者有较多的本地化需求时，SwiftDate是非常好的选择！</p><h2><a href="https://github.com/fatbobman/SwiftUIOverlayContainer">SwiftUIOverlayContainer</a></h2><blockquote><p>SwiftUIOverlayContainer本身并不提供任何预置的视图样式，不过通过它，你有充分的自有度来实现自己需要的视图效果。OverlayContainer的主要目的在于帮助你完成动画、交互、样式定制等基础工作，使开发者能够将时间和精力仅需投入在视图本身的代码上。</p></blockquote><p>这是我自己写的一个库，这次通过它实现的屏幕侧边滑动菜单。</p><p>本来它的用途主要不是做这个的，暂时使用它来完成侧向滑动菜单也是权宜之计，表现尚可。</p><h2><a href="https://github.com/weichsel/ZIPFoundation">ZIPFoundation</a></h2><blockquote><p>ZIP Foundation是一个用于创建，读取和修改ZIP存档文件的库。 它是用Swift编写的，基于Apple的libcompression来实现高性能和高能效。</p></blockquote><p>小巧、高效，使用便捷。健康笔记在数据导入导出时，使用它来完成zip文件的操作。</p><p>比如解压备份数据：</p><pre data-language="swift"><code><span class="hljs-comment">//打开沙盒读取权限</span>
   <span class="hljs-number">_</span> = url.startAccessingSecurityScopedResource() 
<span class="hljs-comment">//解压</span>
   <span class="hljs-keyword">do</span> {
      <span class="hljs-keyword">try</span> <span class="hljs-type">FileManager</span>.<span class="hljs-keyword">default</span>.unzipItem(at: url, to: <span class="hljs-type">URL</span>(fileURLWithPath: <span class="hljs-type">NSTemporaryDirectory</span>()))
        }
        <span class="hljs-keyword">catch</span> {
          
        }
</code></pre><h2><a href="https://github.com/keitaoouchi/MarkdownView">MarkdownView</a></h2><blockquote><p>基于WKwebView实现的Markdown文件Viewer。对md的解析是通过调用js库来完成的。</p></blockquote><p>由于SwiftUI的Text文本排版能力几乎为零，因此我选择使用md格式来保存app所需的一些文字显示，比如隐私政策等。</p><p>MarkdownView的渲染效率一般，但我的显示需求并不大，所以感觉不明显。但它的开发者对js文件进行了加扰处理，所以如果你想对其中它所调用的例如mardown-it进行更多配置的话，就几乎不可能了。</p><p>另外，通过UIViewRepresentable对其进行封装，在SwiftUI下是无法正确获取frame的尺寸的，从而无法正确显示。我对于UIkit所知甚少，只能做了最简单的修改，勉强让其可以在SwiftUI下完成所需要的功能。</p><p>修改后的版本可在<a href="https://github.com/fatbobman/MarkdownView">这里下载</a></p><p>另外，我在UIViewRepresentable包装中增加了一些简单的修改，使其可以方便的将md中的图片，替换成Bundle中的本地图片。</p><p>调用代码 <a href="https://github.com/fatbobman/ShareCode/blob/main/MarkDownView.swift">下载</a></p><h2><a href="https://github.com/avielg/ExcelExport/blob/master/Sources/ExcelExport/ExcelExport.swift">ExcelExport</a></h2><blockquote><p>生成XSL文件的Swift代码。</p></blockquote><p>这段代码有一段时间了，不过去年又做了更新，不过我感觉更新后的版本还不如之前的。但它的新版本不支持Date的字段导出，老版本导出的Date字段格式在Excel中也有问题。我合并了两个版本，并且让其在命名上对SwiftUI更加友好。</p><p>修改后的代码 <a href="https://github.com/fatbobman/ShareCode/blob/main/ExcelExport">下载</a></p><p>必须对日期做如下处理，日期字段才能被Excel顺利识别</p><pre data-language="swift"><code> <span class="hljs-keyword">let</span> date = <span class="hljs-type">DateInRegion</span>(memo.viewModel.date).toFormat(<span class="hljs-string">"yyyy-MM-dd"</span>)
 <span class="hljs-keyword">let</span> time = <span class="hljs-type">DateInRegion</span>(memo.viewModel.date).toFormat(<span class="hljs-string">"HH:mm:ss.FFF"</span>)
 <span class="hljs-keyword">let</span> dateCell = <span class="hljs-type">ExcelCell</span>(date + <span class="hljs-string">"T"</span> + time,type: .dateTime)
</code></pre><p>上述的库都被使用在 <a href="https://apps.apple.com/us/app/health-notes-2/id1534513553">健康笔记2.0</a> 中。如想查看更多的演示，可以移步</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/healthNote2-development-memo-6</guid><title>健康笔记2.0开发随笔（六）</title><description>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同iOS14中的各种Bug和异常斗智斗勇。本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊iOS14、Xcode12以及SwiftUI2.0的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</description><link>http://www.fatbobman.com/posts/healthNote2-development-memo-6</link><pubDate>Mon, 26 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>收尾工作往往是最枯燥的。</p><p>最近这10几天，主要的工作都是查找bug，改进性能，反复测试数据的稳定性，以及更加枯燥的文档准备工作。</p><p>向app store提交反倒异常顺利，中间只出现了一次反复。苹果要我确认是否会滥用用户的数据，在明确回复不会之后就通过了。想想去年底健康笔记1.0的上线反复折腾了我10多天。</p><p>XCode 12中的StoreKit对于调试应用内的购买实在是太方便了，在开发的最后阶段，我将app分成了基础版和专业版。基础版其实已经能应对生活中绝大多数的需求了。通过StoreKit的模拟环境，我的应用内购买没有使用任何沙盒测试便一次性的开发调试成功，并且上线后也运行正常。极大的提高了效率！</p><p>在本次历时近两个月的开发过程中，基本上没走太多弯路。真正让我消耗精力的反倒是和iOS 14以及SwiftUI 2.0中的Bug斗智斗勇。很多奇怪的问题，在对自己代码反复的检查之后才能基本确认是系统的原因，然后还需要设法用最少的代码重现问题得以最终确认。从WWDC20过后，目前已经给苹果提交了10几条的Feedback。其中超过半数在不断的版本升级后得到了修复。</p><p>下面是我在这次的开发中使用的第三方库，我最近会对这些库进行详细的介绍：</p><ul><li>SwiftUIX</li><li>Charts</li><li>Introspect</li><li>ZIPFoundation</li><li>SwiftUIOverlayContainer</li><li>SwiftDate</li><li>MarkdownView</li></ul><p>iPad的适配工作量也比想象中的大。尽管SwiftUI己经提供了极大的方便，但如果想更好的利用iPad的特性的话，还是有不少工作需要完成的。</p><p>本地化也是这次开发的一个目标，难度不太大，但工作量不小。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/healthnote2-release</guid><title>健康笔记2.0正式版完成了!</title><description>经过了大半年的积累和准备,持续了2个月的开发,健康笔记2.0在昨天上线了.</description><link>http://www.fatbobman.com/posts/healthnote2-release</link><pubDate>Mon, 26 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>经过了大半年的积累和准备,持续了2个月的开发,健康笔记2.0在昨天上线了.</p><p>本次开发,我重写了健康笔记的全部代码,最后的结果个人还是比较满意的.</p><p>苹果在2020年无论从iOS,Swift,SwiftUI还是Xcode几个方面改进还是显著的,对我的帮助很大.</p><p>无论从功能、性能、UI表现上,2.0版都比1.0版有了较大提高.</p><p>在这里可以下载 <a href="https://apps.apple.com/us/app/health-notes-2/id1534513553"><img src="http://cdn.fatbobman.com/appStoreIcon.svg" alt="pic"/></a></p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/healthNote2-development-memo-5</guid><title>健康笔记2.0开发随笔（五）</title><description>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同iOS14中的各种Bug和异常斗智斗勇。本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊iOS14、Xcode12以及SwiftUI2.0的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</description><link>http://www.fatbobman.com/posts/healthNote2-development-memo-5</link><pubDate>Wed, 7 Oct 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>一晃国庆中秋长假即将结束，距离上次的随笔也有了一段时间。在最近的日子里，我一方面继续着开发的进程，同时还要付出相当的精力同iOS14中的各种Bug和异常斗智斗勇。</p><p>本篇随笔主要记录了这段时间碰到的一些问题，以及聊聊iOS14、Xcode12以及SwiftUI2.0的一些优缺点。想到哪、写到哪，可能逻辑会比较混乱。</p><h2>Bug实在多</h2><p>2020年苹果想在软件架构层面做出非常多的重要改变。big sur要支持arm，SwiftUI要真正做到一套代码顺利的多平台运行，iOS14也作出了在近几年肉眼可见的最大变化。不过可能是目标太多、太大，而时间又紧，至少到现在为止，bug层出不穷，改不胜改。尤其是随着版本的升级，竟然出现了不少前面完全不曾出现的bug，实在是令人心烦。</p><p>比如在iOS14.2beta2中，sheet的Delegate无法响应，而在之前的所有版本都没有问题。在iOS14.2beta2中，View的刷新时机有和之前有了细微的变化，在一些及特殊的情况下会出现刷新不同步。总之类似的错误一直在增加。</p><p>对于@FetchRequest中的数据进行修改，View不会自动更新，尽管14.2对于List做了修复，但在其他情况下，还是需要人为干预。</p><p>@FetechRequest的数据进行增减时，有时会有动画，有时没有动画。同样的代码，在不同的地方，有时会有动画，有时没有动画，而这些都是在SwiftUI1.0版本都不曾出现的问题。</p><p>在mac下通过catalyst运行app时，总是会出现假死情况（系统cup占用为0，就是app没有响应）。</p><p>Xcode12各种现实异常，这两天出现了一个异常奇怪的现象，当我编辑xcdatamodeld文件时，屏幕上出现了一篇白色区域遮盖了数据编辑区，我只能盲操作。而编辑其他任何文件都没有这种情况。</p><p>Xcode12的代码补全远不如Xcode11，总是补全后需要删除大量无用的补全信息。</p><p>fileImporter竟然不能通过手势取消，如果使用手势，会反复弹出sheet，除非你点击右上角的cancel。</p><p>Menu（SwiftUI新增的控件） 在被键盘遮挡后会出现异常，所以我目前只能把Menu放置在屏幕的上方</p><p>ContextMenu点选后总要闪烁一下，让人很不舒服。</p><p>在SwiftUI2中，对于键盘的自动避让本来是一个相当不错的设计，但总会导致大量的布局受键盘浮动的影响，反倒需要做更多的工作来避免这种情况，结果是好的想法但实现起来适得其反。</p><p>Xcode12的Debug区域会丢失，可以通过快捷键重新唤出。而且莫名其妙的总是默认不显示右侧的Debug Output窗口。</p><p>上面所说的都是最近让我特别心烦的一些bug，其他的实在是太多，就不一一例举了。</p><p>bug过多的结果就是导致我需要花费大量的时间来了判断是我自己的实现错误还是由于系统的bug导致的。如果确定是bug，还需要写不少的feedback给苹果，希望它能尽快修复。对于时间的浪费是十分巨大的。</p><p>为了判断是什么原因导致的，我目前在mac上安装了 两个版本的big sur(最新版、次新版)，三个版本的Xcode(11.7,12.01,12.2beta2),两个运行不同版本的iphone(14.2beta2,14.01),两个模拟器（14.2，14.01）。总之有够花费精力的。</p><p>不过这也是在一个尚未完全成熟的架构下，在一个巨大变化的时间点进行开发所要付出的必要代价。</p><h2>不小的进步</h2><p>上面进行了不少的吐槽，下面我们来说说苹果在今年给我们带来的进步和改善。</p><h3>Xcode12</h3><p>preview已经很成熟了，已经很少会出现崩溃或无法预览的情况。</p><p>在project嵌入playground非常方便，尤其是打开Build Active Scheme之后，可以在playground中直接使用第三方库。对于开发中进行试验测试提供了巨大的便利。</p><p>StoreKit的模拟环境非常有用，极大的提高了开发应用内付费的效率。可以在不提交app并建立资费的情况下便完成和调试所有和收费相关代码。不过我目前发现restore好像没有回馈，不知道是我的使用方法不对还是就是没有提供。</p><p>全屏开发模式支持直接在一次放置模拟器，提高了屏幕使用率，而且有助于注意力的提升。</p><p>SwiftUI liftcycle让跨平台开发更加便利。</p><h3>SwiftUI</h3><p>onChange是我对于今年SwiftUI改动最满意的地方。在onChange中的代码运行时机和View的update一直，基本可以保证正确的响应时机。</p><p>新的DatePicker在iOS上节省了显示的空间，让form更紧凑。不过选择后出现的闪烁还表示有进一步优化的空间</p><p>众多的新控件。进过我在本次开发中并没有使用太多的新控件，不过更多的选择还是有利于开发者的。</p><p>我目前最多使用的新控件有： toolbar menu lazyStack lazyGrid</p><p>在DSL中支持更复杂的逻辑判断。由于目前支持了if let,switch可以在DSL中用更少的代码实现更清晰的逻辑处理。</p><p>对于复杂的DSL的编译能力也有了提高</p><h3>Big Sur</h3><p>随着测试版本的不断提高，catalyst对于SwiftUI的支持越来越好。在最初的版本中，基本还是利用appkit的控件来代替uikit的控件，在目前的beta9下，显示效果已经和ipad上相差无几。只是用SwiftUI + catalyst来开发mac app已经越来越有可能。</p><h2>测试征集</h2><p>健康笔记2.0目前已经到了收尾阶段，除了图表部分之外，大多数的功能都已完成。我正在申请test flight的beta测试。如果你有兴趣进行测试，请将你的邮箱发送给我。</p><p>健康笔记2.0需要运行在iOS14以上的设备。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/healthNote2-development-memo-4</guid><title>健康笔记2.0开发随笔（四）</title><description>本周没有太多的精力和情绪用来写代码。这两天在原来统一sheet管理和实时Form的基础上，完成了可以控制取消手势的Sheet。这个是SwiftUI中一直以来的一个重要的缺失功能。 在SwiftUI中制作可以控制取消手势的Sheet</description><link>http://www.fatbobman.com/posts/healthNote2-development-memo-4</link><pubDate>Thu, 17 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>经过2周的治疗,我父亲终于脱离的生命危险。疫情的原因，医院只允许一个护工在身边照顾，病人长时间无法见到家属而导致了较严重的心理问题。综合考虑，周末已接回家。回家2天后，整个状况有了非常好的转变。在这次的治疗中，我提供给医院的我父亲这几年来的各方面身体指标数据起到了很重要的作用。</p><p>本周没有太多的精力和情绪用来写代码。这两天在原来统一sheet管理和实时Form的基础上，完成了可以控制取消手势的Sheet。这个是SwiftUI中一直以来的一个重要的缺失功能。 <a href="http://www.fatbobman.com/posts/swiftui-dismiss-sheet/">在SwiftUI中制作可以控制取消手势的Sheet</a></p><p>Xcode 12 beta6 的bug还是不少，这两天我竟然见到了3次四国画面。 SwiftUI 2.0的List问题也很多，甚至感觉比1.0更不稳定，而且效率有明显的问题。目前已将所有使用List的地方都暂时替换成了LazyVStack。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swiftui-dismiss-sheet</guid><title>在SwiftUI中制作可以控制取消手势的Sheet</title><description>在前面的两篇文章中，我们探讨了如何制作一个可以判断是否进行了修改的表单，以及如何统一管理app各个层级View的弹出Sheet。今天我们将他们合并在一起，完成整个项目的最终目的——在Sheet中制作一个可以实时响应的表单，并且sheet会感觉表单的情况响应取消手势。</description><link>http://www.fatbobman.com/posts/swiftui-dismiss-sheet</link><pubDate>Thu, 17 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>在前面的两篇文章中，我们探讨了如何制作一个可以判断是否进行了修改的表单，以及如何统一管理app各个层级View的弹出Sheet。今天我们将他们合并在一起，完成整个项目的最终目的——在Sheet中制作一个可以实时响应的表单，并且sheet会感觉表单的情况响应取消手势。</p></blockquote><p><a href="http://www.fatbobman.com/posts/swiftui-multiSheet/">在SwiftUI中,根据需求弹出不同的Sheet</a></p><p><a href="http://www.fatbobman.com/posts/swiftui-input-form/">如何在SwiftUI中创建一个实时响应的Form</a></p><h2>由来</h2><p>在之前Form的例子中，虽然我们可以根据表单是否进行了修改来对cancel、edit等做出不同的响应，但是我们并没有办法控制用户直接使用手势来取消sheet，为了不让用户绕过程序的判断检查，不得已使用了fullScreenCover来规避手势取消。不过在实际使用中，尽管全屏sheet提供了更多的屏幕可用空间，但还是会给使用者带来了操作逻辑不统一的体验。</p><p>在去年，我使用的解决方案是，屏蔽sheet的拖动手势。</p><pre data-language="swift"><code> .highPriorityGesture(<span class="hljs-type">DragGesture</span>())
</code></pre><p>这也是没有办法的办法。</p><p>后来，SwiftUI-lab中，Javier提出了他的解决方案<a href="https://swiftui-lab.com/modal-dismiss-gesture/">Dismiss Gesture for SwiftUI Modals</a>。这个方案基本上实现了我想要的全部功能。不过这个方案看起来有些怪异。</p><ol><li>数据和sheet控制混合在一起</li><li>对于sheet的控制过于繁琐，而且不直观</li></ol><p>前段时间<a href="https://gist.github.com/mobilinked/9b6086b3760bcf1e5432932dad0813c0">mobilinked</a>编写了一段用于控制sheet的代码，结构精巧，使用简单。</p><p>本文对于sheet的控制采用了mobilinked的基础代码，并针对Form的响应做出了对应的修改。</p><p>在进行下面的代码说明前，如果你还没有阅读前两篇文章的话，请阅读后再继续。</p><h2>目标</h2><ol><li>表单对输入的内容进行实时检查（是否有错误，是否有空白项）</li><li>表单将根据当前的状态决定是否允许sheet进行手势取消</li><li>当用户进行手势取消时，如果表单已经进行了修改，需要用户二次确认是否取消</li></ol><h2>代码简介</h2><p>由于本文代码中多数部分同Form示例代码类似，所以仅简述一下新增及修改的部分。</p><p>SheetManager</p><pre data-language="swift"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AIOSheetManager</span>:<span class="hljs-title">ObservableObject</span></span>{
    @<span class="hljs-type">Published</span>  <span class="hljs-keyword">var</span> action:<span class="hljs-type">AllInOneSheetAction?</span>
    <span class="hljs-keyword">var</span> unlock:<span class="hljs-type">Bool</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//false时无法下滑dismiss,由form程序维护</span>
    <span class="hljs-keyword">var</span> type:<span class="hljs-type">AllInOneSheetType</span> = .sheet <span class="hljs-comment">//sheet or fullScreenCover</span>
    <span class="hljs-keyword">var</span> dismissControl:<span class="hljs-type">Bool</span> = <span class="hljs-literal">true</span> <span class="hljs-comment">//是否启动dismiss阻止开关,true启动阻止</span>
    
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> showSheet = <span class="hljs-literal">false</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> showFullCoverScreen = <span class="hljs-literal">false</span>

    <span class="hljs-keyword">var</span> dismissed = <span class="hljs-type">PassthroughSubject</span>&lt;<span class="hljs-type">Bool</span>,<span class="hljs-type">Never</span>&gt;()
    <span class="hljs-keyword">var</span> dismissAction:(() -&gt; <span class="hljs-type">Void</span>)? = <span class="hljs-literal">nil</span>

    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AllInOneSheetType</span></span>{
        <span class="hljs-keyword">case</span> fullScreenCover
        <span class="hljs-keyword">case</span> sheet
    }
}
</code></pre><p>sheet控制代码</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MbModalHackView</span>: <span class="hljs-title">UIViewControllerRepresentable</span> </span>{
    <span class="hljs-keyword">let</span> manager:<span class="hljs-type">AIOSheetManager</span>

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeUIViewController</span><span class="hljs-params">(context: UIViewControllerRepresentableContext&lt;MbModalHackView&gt;)</span></span> -&gt; <span class="hljs-type">UIViewController</span> {
        <span class="hljs-type">UIViewController</span>()
    }

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateUIViewController</span><span class="hljs-params">(<span class="hljs-number">_</span> uiViewController: UIViewController, context: UIViewControllerRepresentableContext&lt;MbModalHackView&gt;)</span></span> {
        rootViewController(of: uiViewController).presentationController?.delegate = context.coordinator
    }

    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rootViewController</span><span class="hljs-params">(of uiViewController: UIViewController)</span></span> -&gt; <span class="hljs-type">UIViewController</span> {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> parent = uiViewController.parent {
            <span class="hljs-keyword">return</span> rootViewController(of: parent)
        }
        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> uiViewController
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeCoordinator</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Coordinator</span> {
        <span class="hljs-type">Coordinator</span>(manager: manager)
    }

    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Coordinator</span>: <span class="hljs-title">NSObject</span>, <span class="hljs-title">UIAdaptivePresentationControllerDelegate</span> </span>{
        <span class="hljs-keyword">let</span> manager:<span class="hljs-type">AIOSheetManager</span>
        <span class="hljs-keyword">init</span>(manager:<span class="hljs-type">AIOSheetManager</span>){
            <span class="hljs-keyword">self</span>.manager = manager
        }
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentationControllerShouldDismiss</span><span class="hljs-params">(<span class="hljs-number">_</span> presentationController: UIPresentationController)</span></span> -&gt; <span class="hljs-type">Bool</span> {
            <span class="hljs-keyword">guard</span> manager.dismissControl <span class="hljs-keyword">else</span> {<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>}
            <span class="hljs-keyword">return</span> manager.unlock
        }

        <span class="hljs-comment">//当阻止取消时,发送用户要求取消sheet命令</span>
        <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">presentationControllerDidAttemptToDismiss</span><span class="hljs-params">(<span class="hljs-number">_</span> presentationController: UIPresentationController)</span></span>{
            manager.dismissed.send(<span class="hljs-literal">true</span>)
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">allowAutoDismiss</span><span class="hljs-params">(<span class="hljs-number">_</span> manager:AIOSheetManager)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-keyword">self</span>
            .background(<span class="hljs-type">MbModalHackView</span>(manager: manager))

    }
}
</code></pre><p>包装</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XSheet</span>:<span class="hljs-title">ViewModifier</span></span>{
    @<span class="hljs-type">EnvironmentObject</span> <span class="hljs-keyword">var</span> manager:<span class="hljs-type">AIOSheetManager</span>
    @<span class="hljs-type">EnvironmentObject</span> <span class="hljs-keyword">var</span> store:<span class="hljs-type">Store</span>
    @<span class="hljs-type">Environment</span>(\.managedObjectContext) <span class="hljs-keyword">var</span> context
    <span class="hljs-keyword">var</span> onDismiss:()-&gt;<span class="hljs-type">Void</span>{
        <span class="hljs-keyword">return</span> {
            (manager.dismissAction ?? {})()
            manager.dismissAction = <span class="hljs-literal">nil</span>
            manager.action = <span class="hljs-literal">nil</span>
            manager.showSheet = <span class="hljs-literal">false</span>
            manager.showFullCoverScreen = <span class="hljs-literal">false</span>
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">body</span><span class="hljs-params">(content: Content)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span>{
            content
            
            <span class="hljs-type">Color</span>.clear
                .sheet(isPresented: $manager.showSheet,onDismiss: onDismiss){
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> action = manager.action
                        {
                            reducer(action)
                            .allowAutoDismiss(manager)
                            .environmentObject(manager)
                        }
                    
                }
            
            <span class="hljs-type">Color</span>.clear
                .fullScreenCover(isPresented: $manager.showFullCoverScreen,onDismiss: onDismiss){
                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> action = manager.action
                        {
                            reducer(action)
                                .allowAutoDismiss(manager)
                                .environmentObject(manager)
                        }
                }
        }
        .onChange(of: manager.action){ action <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">guard</span> action != <span class="hljs-literal">nil</span> <span class="hljs-keyword">else</span> {
                manager.showSheet = <span class="hljs-literal">false</span>
                manager.showFullCoverScreen = <span class="hljs-literal">false</span>
                <span class="hljs-keyword">return</span>
            }
            <span class="hljs-keyword">if</span> manager.type == .sheet {
                manager.showSheet = <span class="hljs-literal">true</span>
            }
            <span class="hljs-keyword">if</span> manager.type == .fullScreenCover{
                manager.showFullCoverScreen = <span class="hljs-literal">true</span>
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AllInOneSheetAction</span>:<span class="hljs-title">Identifiable</span>,<span class="hljs-title">Equatable</span></span>{
    <span class="hljs-keyword">case</span> show(student:<span class="hljs-type">Student</span>)
    <span class="hljs-keyword">case</span> edit(student:<span class="hljs-type">Student</span>)
    <span class="hljs-keyword">case</span> new
    
    
    <span class="hljs-keyword">var</span> id:<span class="hljs-type">UUID</span>{<span class="hljs-type">UUID</span>()}
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">XSheet</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reducer</span><span class="hljs-params">(<span class="hljs-number">_</span> action:AllInOneSheetAction)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">switch</span> action{
        <span class="hljs-keyword">case</span> .show(<span class="hljs-keyword">let</span> student):
            <span class="hljs-keyword">return</span> <span class="hljs-type">StudentManager</span>(action:.show, student:student)
        <span class="hljs-keyword">case</span> .new:
            <span class="hljs-keyword">return</span> <span class="hljs-type">StudentManager</span>(action: .new, student: <span class="hljs-literal">nil</span>)
        <span class="hljs-keyword">case</span> .edit(<span class="hljs-keyword">let</span> student):
            <span class="hljs-keyword">return</span> <span class="hljs-type">StudentManager</span>(action:.edit,student: student)
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">View</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">xsheet</span><span class="hljs-params">()</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">self</span>
            .modifier(<span class="hljs-type">XSheet</span>())
    }
}
</code></pre><p>调用方式</p><pre data-language="swift"><code><span class="hljs-type">NavigationView</span>{
    ...
}
.xsheet()


<span class="hljs-type">Button</span>(<span class="hljs-string">"New"</span>){
         sheetManager.type = .sheet  <span class="hljs-comment">//当前支持两种方式 sheet fullScreenCover</span>
         sheetManager.dismissControl = <span class="hljs-literal">true</span> <span class="hljs-comment">//打开控制</span>
         sheetManager.action = .new   <span class="hljs-comment">//设置统一sheet的action</span>
              }
</code></pre><p>Form代码的修改</p><p>为了让我们的表单代码能够管理sheet，并且可以响应用户的取消手势，对Form代码做了如下的修改：</p><pre data-language="swift"><code>    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> changed = <span class="hljs-literal">false</span>{
        <span class="hljs-keyword">didSet</span>{
            <span class="hljs-comment">//控制sheet是否允许dismiss</span>
            <span class="hljs-keyword">if</span> action == .show {
                sheetManager.unlock = <span class="hljs-literal">true</span>
            }
            <span class="hljs-keyword">else</span> {
                sheetManager.unlock = !changed
            }
        }
    }
</code></pre><pre data-language="swift"><code>新增
 .onReceive(sheetManager.dismissed){ value <span class="hljs-keyword">in</span>
                delConfirm.toggle()
            }
</code></pre><p>详细代码请访问我的<a href="https://github.com/fatbobman/DismissConfirmSheet">github</a></p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/healthNote2-development-memo-3</guid><title>健康笔记2.0开发随笔（三）</title><description>本周的由于其他琐事的原因,每天能够用于开发的时间基本上只能保证2-3个小时,所以进展不大.不过好在我也没有明确的进度指标.</description><link>http://www.fatbobman.com/posts/healthNote2-development-memo-3</link><pubDate>Sat, 5 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>由于家属突发疾病，最近每天都要出入医院，因此最近用于开发的时间很有限。</p><p>目前app已经完成了笔记、条目、数据的创建、编辑、显示、删除全部逻辑。如果不考虑图表、数据导入导出、交叉比对等功能，app的基本功能已经完成了。</p><p>在本次开发中，我着重调整了表单的开发方式，目前表单无论从响应，判断等方便都比上一版有了很大的提高。</p><p>本次我将以前分散的输入源（source of truth）统一到了一起，不仅更便于代码管理，同时也方便实现了很多以前无法或实现起来非常困难的功能。</p><p>关于表单的处理，可以参看我的文章<a href="http://www.fatbobman.com/posts/swiftui-input-form/">如何在SwiftUI中创建一个实时响应的Form</a>。</p><p>另外，由于我的app对于sheet的使用量也很多，所以也对sheet的响应做出了统一的管理，这方面我记录在另一篇文章中<a href="http://www.fatbobman.com/posts/swiftui-multiSheet/">在SwiftUI中,根据需求弹出不同的Sheet</a>。</p><p>时间有限，随便记录一点。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swiftui-input-form</guid><title>如何在SwiftUI中创建一个实时响应的Form</title><description>我的app健康笔记主要是对数据的收集、管理，所以对于表单的实时检查、响应的要求比较高。因此制作一个对用于输入响应及时、反馈准确的Form十分重要。本文尝试提出一个SwiftUI下的Form开发思路。</description><link>http://www.fatbobman.com/posts/swiftui-input-form</link><pubDate>Fri, 4 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>我的app健康笔记主要是对数据的收集、管理，所以对于表单的实时检查、响应的要求比较高。因此制作一个对用于输入响应及时、反馈准确的Form十分重要。本文尝试提出一个SwiftUI下的Form开发思路。</p></blockquote><h2>健康笔记1.0的时候</h2><p>在开发健康笔记1.0的使用，当时由于iOS13尚不支持onChange，当时主要使用类似的检查方式：</p><h2>对于简单情况</h2><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>

<span class="hljs-type">TextField</span>(<span class="hljs-string">"name"</span>,text:$name)
     .foregroundColor(name.<span class="hljs-built_in">count</span>.isEmpty ? .red : .black)
</code></pre><h2>稍复杂的情况</h2><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> age = <span class="hljs-string">""</span>

<span class="hljs-type">TextField</span>(<span class="hljs-string">"name"</span>,text:$name)
    .foregroundColor(!checkName() ? .red : .black)
<span class="hljs-type">TextField</span>(<span class="hljs-string">"age"</span>,text:$name)
     .keyboardType(.decimalPad)
     .foregroundColor(!checkAge() ? .red : .black)

<span class="hljs-type">Button</span>(<span class="hljs-string">"Save"</span>){
   <span class="hljs-comment">//保存</span>
}
.disable(!(checkName()&amp;&amp;checkeAge))

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">chekcName</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Bool</span> {
   <span class="hljs-keyword">return</span> name.<span class="hljs-built_in">count</span> &gt; <span class="hljs-number">0</span> &amp;&amp; name.<span class="hljs-built_in">count</span> &lt;= <span class="hljs-number">10</span> 
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkAge</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Bool</span> {
   <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> age = <span class="hljs-type">Double</span>(age) <span class="hljs-keyword">else</span> {<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>}
   <span class="hljs-keyword">return</span> age &gt; <span class="hljs-number">10</span> &amp;&amp; age &lt; <span class="hljs-number">20</span>
}
</code></pre><p>其实之前对于很复杂的表单，我也是采用了Combine的方式来做验证的。</p><p>不过Publisher的和View的刷新周期之间有一个响应的差距，也就是说，第一个输入的判断需要到第二个输入时才会返回结果。如此一来，只能将判断逻辑都写在View中。不过如果需要利用网络验证的部分，仍然是使用Publisher来处理的。它的响应由于使用OnReceive所以不会出现上面的判断时间差。</p><h2>健康笔记2.0的处理方式</h2><p>在我目前开发的健康笔记2.0中，由于iOS 14支持了onChange,让开发者在View有了非常方便的处理逻辑判断的时机。</p><p>以下是目前开发中的画面：</p><img src="http://cdn.fatbobman.com/swiftui-form-formDemo.gif" alt="demo"/><h2>用MVVM的方式来编写Form</h2><p>在使用SwiftUI进行开发中，我们不仅需要使用MVVM的思想来考虑app的架构，对于每一个View都可以把它当做一个mini的app来对待。</p><p>在下面的例子中，我们需要完成如下的功能：</p><ol><li>显示档案、编辑档案、新建档案都使用同一个代码</li><li>对于用户的每一次输入都给出及时和准确的反馈</li><li>只有用户的数据完全满足需求时（各个输入项都满足检查条件同时在编辑状态下，当前修改数据要与原始数据不同），才允许用户保存。</li><li>如果用户已经修改或创建了数据，用户取消时需要二次确认</li><li>在用户显示档案时，可以一键切换到编辑模式</li></ol><p><em>如果你所需要创建的FormView功能简单，请千万不要使用下列的方法。下列代码仅在创建较复杂的表单时才会发挥优势。</em></p><p>完成后的视频如下：</p><img src="http://cdn.fatbobman.com/swiftui-form-studentDemo.gif" alt="demo"/><p>下载 (当前代码已和 <a href="https://zhuanlan.zhihu.com/p/245663226">在SwiftUI中制作可以控制取消手势的Sheet</a> 合并)</p><p><a href="https://github.com/fatbobman/DismissConfirmSheet">源代码</a></p><p>为输入准备数据源</p><p>不同于创建多个@State数据源来处理数据，我现在将所有需要录入的数据统一放到了一个数据源中</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyState</span>:<span class="hljs-title">Equatable</span></span>{
    <span class="hljs-keyword">var</span> name:<span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> sex:<span class="hljs-type">Int</span>
    <span class="hljs-keyword">var</span> birthday:<span class="hljs-type">Date</span>
}
</code></pre><p>让View响应不同的动作</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">StudentAction</span></span>{
    <span class="hljs-keyword">case</span> show,edit,new
}
</code></pre><p><strong>有了上述的准备，我们便可以创建表单的构造方法了：</strong></p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StudentManager</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">EnvironmentObject</span> <span class="hljs-keyword">var</span> store:<span class="hljs-type">Store</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> action:<span class="hljs-type">StudentAction</span>
    <span class="hljs-keyword">let</span> student:<span class="hljs-type">Student?</span>
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> defaultState:<span class="hljs-type">MyState</span>  <span class="hljs-comment">//用于保存初始数据，可以用来比较，或者在我的app中，可以恢复用户之前的值</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> myState:<span class="hljs-type">MyState</span> <span class="hljs-comment">//数据源</span>
    
    @<span class="hljs-type">Environment</span>(\.presentationMode) <span class="hljs-keyword">var</span> presentationMode

<span class="hljs-keyword">init</span>(action:<span class="hljs-type">StudentAction</span>,student:<span class="hljs-type">Student?</span>){
        _action = <span class="hljs-type">State</span>(wrappedValue: action)
        <span class="hljs-keyword">self</span>.student = student
        
        <span class="hljs-keyword">switch</span> action{
        <span class="hljs-keyword">case</span> .new:
            <span class="hljs-keyword">self</span>.defaultState = <span class="hljs-type">MyState</span>(name: <span class="hljs-string">""</span>,sex:<span class="hljs-number">0</span>, birthday: <span class="hljs-type">Date</span>())
            _myState = <span class="hljs-type">State</span>(wrappedValue: <span class="hljs-type">MyState</span>(name: <span class="hljs-string">""</span>, sex:<span class="hljs-number">0</span>, birthday: <span class="hljs-type">Date</span>()))
        <span class="hljs-keyword">case</span> .edit,.show:
            <span class="hljs-keyword">self</span>.defaultState = <span class="hljs-type">MyState</span>(name: student?.name ?? <span class="hljs-string">""</span>, sex:<span class="hljs-type">Int</span>(student?.sex ?? <span class="hljs-number">0</span>) , birthday: student?.birthday ?? <span class="hljs-type">Date</span>())
            _myState = <span class="hljs-type">State</span>(wrappedValue: <span class="hljs-type">MyState</span>(name: student?.name ?? <span class="hljs-string">""</span>, sex:<span class="hljs-type">Int</span>(student?.sex ?? <span class="hljs-number">0</span>), birthday: student?.birthday ?? <span class="hljs-type">Date</span>()))
        }
    }
  
}
</code></pre><p>准备表单显示内容</p><pre data-language="swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nameView</span><span class="hljs-params">()</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-type">HStack</span>{
            <span class="hljs-type">Text</span>(<span class="hljs-string">"姓名:"</span>)
            <span class="hljs-keyword">if</span> action == .show {
                <span class="hljs-type">Spacer</span>()
                <span class="hljs-type">Text</span>(defaultState.name)
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-type">TextField</span>(<span class="hljs-string">"学生姓名"</span>,text:$myState.name)
                    .multilineTextAlignment(.trailing)
            }
        }
    }
</code></pre><p>合成显示内容</p><pre data-language="swift"><code><span class="hljs-type">Form</span>{
             nameView()
             sexView()
             birthdayView()
             errorView()
      }
</code></pre><p>对每个输入项目进行验证</p><pre data-language="swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkName</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">if</span> myState.name.isEmpty {
            errors.append(<span class="hljs-string">"必须填写姓名"</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
        }
    }
</code></pre><p>处理所有的验证信息</p><pre data-language="swift"><code><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkAll</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">if</span> action == .show {<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>}
        errors.removeAll()
        <span class="hljs-keyword">let</span> r1 = checkName()
        <span class="hljs-keyword">let</span> r2 = checkSex()
        <span class="hljs-keyword">let</span> r3 = checkBirthday()
        <span class="hljs-keyword">let</span> r4 = checkChange()
        <span class="hljs-keyword">return</span> r1&amp;&amp;r2&amp;&amp;r3&amp;&amp;r4
    }
</code></pre><p>通过onChange来进行校验</p><pre data-language="swift"><code>.onChange(of: myState){ <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
         confirm =  checkAll()
       }
<span class="hljs-comment">//由于onChange必须在数据源发生变化时才会激发，所以在View最初显示时便进行一次验证</span>
.onAppear{
     confirm =  checkAll()
   }
</code></pre><p>对toolbar的内容进行处理</p><pre data-language="swift"><code><span class="hljs-type">ToolbarItem</span>(placement: <span class="hljs-type">ToolbarItemPlacement</span>.navigationBarTrailing){
                    <span class="hljs-keyword">if</span> action == .show {
                        <span class="hljs-type">Button</span>(<span class="hljs-string">"编辑"</span>){
                            action = .edit
                            confirm = <span class="hljs-literal">false</span>
                        }
                    }
                    <span class="hljs-keyword">else</span> {
                    <span class="hljs-type">Button</span>(<span class="hljs-string">"确定"</span>){
                        <span class="hljs-keyword">if</span> action == .new {
                        presentationMode.wrappedValue.dismiss()
                        store.newStudent(viewModel: myState)
                        }
                        <span class="hljs-keyword">if</span> action == .edit{
                            presentationMode.wrappedValue.dismiss()
                            store.editStudent(viewModel: myState, student: student!)
                        }
                    }
                    .disabled(!confirm)
                    }
</code></pre><p>更详尽的内容可以参看<a href="https://github.com/fatbobman/DismissConfirmSheet">源代码</a></p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swiftui-multiSheet</guid><title>在SwiftUI中,根据需求弹出不同的Sheet</title><description>Sheet是一个我比较喜欢的交互形式，它可以很好的控制用户的操作行为，让用户的交互逻辑单线条化。在iOS14上，SwiftUI增加了fullCover，支持了全屏的Sheet方式，让开发者又了更多的选择。</description><link>http://www.fatbobman.com/posts/swiftui-multiSheet</link><pubDate>Fri, 4 Sep 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>Sheet是一个我比较喜欢的交互形式，它可以很好的控制用户的操作行为，让用户的交互逻辑单线条化。在iOS14上，SwiftUI增加了fullCover，支持了全屏的Sheet方式，让开发者又了更多的选择。</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> showView1 = <span class="hljs-literal">false</span>
@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> showView2 = <span class="hljs-literal">false</span>

<span class="hljs-type">List</span>{
    <span class="hljs-type">Button</span>(<span class="hljs-string">"View1"</span>){
      showView1.toggle()
    }
  .sheet(isPresented:$showView1){
    <span class="hljs-type">Text</span>(<span class="hljs-string">"View1"</span>)
  }
  
  <span class="hljs-type">Button</span>(<span class="hljs-string">"View2"</span>){
    showView2.toggle()
  }
  .sheet(isPresented:$showView2){
    <span class="hljs-type">Text</span>(<span class="hljs-string">"View2"</span>)
  }
}
</code></pre><p>上述代码，我们可以通过点击不同的按钮而弹出相对应的View。</p><p>不过它有两个缺点：</p><ol><li>如果你的代码有多处需要使用不同view作为sheet的情况，你需要声明多个对应的开关值</li><li>如果你的View结构比较复杂，在比较内部的地方，上述代码很可能无法激发sheet的显示（这个问题在ios13上就存在，在ios14上仍有这样的情况。我至今也没有完全总结出规律）</li></ol><h2>使用Item来对应不同的View</h2><p>好在sheet提供了另外一种激活方式</p><pre data-language="swift"><code>.sheet(item: <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Identifiable?</span>&gt;, content: (<span class="hljs-type">Identifiable</span>) -&gt; <span class="hljs-type">View</span>)
</code></pre><p>我们可以使用它来完成只响应一个激活变量，而显示所需的不同View</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">View1</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">Environment</span>(\.presentationMode) <span class="hljs-keyword">var</span> presentationMode
    <span class="hljs-keyword">let</span> text:<span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">NavigationView</span>{
            <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Text</span>(text)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"View1"</span>)
            }
                .toolbar{
                    <span class="hljs-type">ToolbarItem</span>(placement: <span class="hljs-type">ToolbarItemPlacement</span>.navigationBarLeading){
                        <span class="hljs-type">Button</span>(<span class="hljs-string">"cancel"</span>){
                            presentationMode.wrappedValue.dismiss()
                        }
                    }
                }
        }
    }
    
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">View2</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">Environment</span>(\.presentationMode) <span class="hljs-keyword">var</span> presentationMode
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">NavigationView</span>{
            <span class="hljs-type">Text</span>(<span class="hljs-string">"View2"</span>)
                .toolbar{
                    <span class="hljs-type">ToolbarItem</span>(placement: <span class="hljs-type">ToolbarItemPlacement</span>.navigationBarLeading){
                        <span class="hljs-type">Button</span>(<span class="hljs-string">"cancel"</span>){
                            presentationMode.wrappedValue.dismiss()
                        }
                    }
                }
        }
    }
    
}
</code></pre><p>先准备两个需要显示的View</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SheetUsingAnyView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> sheetView:<span class="hljs-type">AnyView?</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">NavigationView</span>{
            <span class="hljs-type">List</span>{
                <span class="hljs-type">Button</span>(<span class="hljs-string">"View1"</span>){
                    sheetView = <span class="hljs-type">AnyView</span>(<span class="hljs-type">View1</span>(text:<span class="hljs-string">"Hello world"</span>))
                }
                <span class="hljs-type">Button</span>(<span class="hljs-string">"View2"</span>){
                    sheetView = <span class="hljs-type">AnyView</span>(<span class="hljs-type">View2</span>())
                }
            }
            .listStyle(<span class="hljs-type">InsetGroupedListStyle</span>())
            .sheet(item: $sheetView){ view <span class="hljs-keyword">in</span>
               view
            }
            .navigationTitle(<span class="hljs-string">"AnyView"</span>)
            .navigationBarTitleDisplayMode(.inline)
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">AnyView</span>:<span class="hljs-title">Identifiable</span></span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> id:<span class="hljs-type">UUID</span>{<span class="hljs-type">UUID</span>()}
}
</code></pre><p>通过上述代码，我们便可以通过给sheetView赋予不同的值来实现弹出对应的View。</p><p>这个解决方案非常的便捷，不过也存在两个问题：</p><ol><li>在极个别的情况下，当app进入后台（此时app的sheet处于显示状态），再从后台重新显示时会出现程序崩溃情况。这个问题在ios13 和目前的 ios14（测试到beta5）都可能出现。不过出现的前提是你的代码的显示层级要足够复杂，如果代码比较简单，通常是可以正常运行的。</li></ol><p>对于这个崩溃的情况，错误和调试代码给的信息都很不准确，估计应该和View的初始化冲突有关。</p><ol start="2"><li>指令不清晰。如果赋值给sheetView的View参数很多，你的代码的可读性会比较差</li></ol><h2>采用Reducer的思路解决问题</h2><p>其实对于每一个View，我们也都可以按照MVVM的思路来构建它自己的mini状态机（我的另一篇关于Form的文章也是这样的思路）。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SheetUsingEnum</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> sheetAction:<span class="hljs-type">SheetAction?</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">NavigationView</span>{
            <span class="hljs-type">List</span>{
                <span class="hljs-type">Button</span>(<span class="hljs-string">"view1"</span>){
                    sheetAction = .view1(text:<span class="hljs-string">"Test"</span>)
                }
                <span class="hljs-type">Button</span>(<span class="hljs-string">"view2"</span>){
                    sheetAction = .view2
                }
            }
            .listStyle(<span class="hljs-type">InsetGroupedListStyle</span>())
            .sheet(item: $sheetAction){ action <span class="hljs-keyword">in</span>
                getActionView(action)
            }
            .navigationTitle(<span class="hljs-string">"Enum"</span>)
            .navigationBarTitleDisplayMode(.inline)
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getActionView</span><span class="hljs-params">(<span class="hljs-number">_</span> action:SheetAction)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-keyword">switch</span> action{
        <span class="hljs-keyword">case</span> .view1(<span class="hljs-keyword">let</span> text):
            <span class="hljs-keyword">return</span> <span class="hljs-type">AnyView</span>(<span class="hljs-type">View1</span>(text: text))
        <span class="hljs-keyword">case</span> .view2:
            <span class="hljs-keyword">return</span> <span class="hljs-type">AnyView</span>(<span class="hljs-type">View2</span>())
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SheetAction</span>:<span class="hljs-title">Identifiable</span></span>{
    <span class="hljs-keyword">case</span> view1(text:<span class="hljs-type">String</span>)
    <span class="hljs-keyword">case</span> view2
    
    <span class="hljs-keyword">var</span> id:<span class="hljs-type">UUID</span>{
        <span class="hljs-type">UUID</span>()
    }
}
</code></pre><p>比较直接使用AnyView，代码量稍微增多了点，不过第一没有了崩溃的可能性，同时代码的易读性也得到了提高。</p><h2>解决某些View无法激活Sheet的问题</h2><p>关于在某些View上无法激活Sheet，我目前的解决方案是bind它的父View的sheetAction，通过父View来激活Sheet。通过枚举的相关值来传递所需的数据。</p><p><strong>更新</strong>: 在iOS14下,使用item来激活sheet,在某些特殊场合可能会导致app(打开sheet的情况下)从后台返回时会发生错误甚至崩溃.所以上述代码中对于sheet的激活,已经作出了更改.更改后的代码已经统一到了<a href="http://www.fatbobman.com/posts/swiftui-dismiss-sheet/">在SwiftUI中制作可以控制取消手势的Sheet</a></p><p><a href="https://github.com/fatbobman/DismissConfirmSheet">可以在此下载项目完整代码</a></p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/healthNote2-development-memo-2</guid><title>健康笔记2.0开发随笔(二)</title><description>本周的由于其他琐事的原因,每天能够用于开发的时间基本上只能保证2-3个小时,所以进展不大.不过好在我也没有明确的进度指标.</description><link>http://www.fatbobman.com/posts/healthNote2-development-memo-2</link><pubDate>Mon, 24 Aug 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>本周的由于其他琐事的原因,每天能够用于开发的时间基本上只能保证2-3个小时,所以进展不大.不过好在我也没有明确的进度指标.</p><p>由于2.0在功能上同1.0的区别并不太大,所以在功能需求设计上不需要花费太多的时间.这半年来我自己也基本总结了一个自己用起来比较顺手的MVVM框架所以在最开始的1周,并不用太费力变完成了一个最简陋ui的原型版.</p><p>尽管叫原型版,但数据流、数据库操作等待基础代码都是要用于正式版中的.</p><p>在上周,苹果发布了Xcode12的beta5,其中提供了在SwiftUI lifecycle下的CoreData模版.所用的思路和我现在差不多.都是使用static来保证上下文的唯一性.另外苹果也提供了一个用于preview的思路,创建了一个in-memory 的Sqllite.这个也和我现在的途径差距不大,我现在是直接通过生成Sample NSManageObject给Preview来实现的.反正都是可以在preview中比较好的支持CoreData数据.</p><p>preview在Xcode12中得到了很大的加强,崩溃的机率明显下降很多.我目前几乎所有的View都可以完美的preview出来.</p><p>本次升级我对于app的UI的还是有点企图心的,最初也希望能够制作成一个比较有风格的app.不过在仔细权衡过后,还是放弃了.放弃的理由也十分简单,对于个人开发者或者小型团队开发者,如果没有好的审美判断力、美工执行力、交互逻辑的设计能力,一个貌似具有个人风格的设计很可能会以惨败告终.</p><p>最终还是决定以iOS的原生UIKit基础上来进行设计.不过即使苹果的原生控件已经比较有美感,不过想要好的色彩搭配、合适的布局、顺畅的交互仍然不是一件容易的事情.</p><p>专业的事情还是要找专业的解决方案.最终,我在gumroad.com上找到了一个自己比较喜欢的控件设计包<a href="https://gumroad.com/l/iostoolkit"><strong>Figma iOS UI kit</strong></a>,以99美金买了下来.</p><p>这个包的比较适合开发iOS原生的app.由于它同时提供了light和dark两个模式下的对应Demo,所以指导性还是很强的.</p><p>在研究这个模版的设计文件过程中我才发现,一个看似简单的控件其实里面有着非常多的细节.我试图在SwiftUI中在保证性能的情况下,实现更多的细节.</p><p>这是我目前一部分View的设计稿</p><img src="http://cdn.fatbobman.com/healthnotes-develop-memo-2-1.jpg" alt="截屏2020-08-24 下午3.53.25"/><img src="http://cdn.fatbobman.com/healthnotes-develop-memo-2-2.jpg" alt="截屏2020-08-24 下午3.54.24"/><p>目前已经针对完成的这一小部分开始编写代码了.之所以在没有完全完成设计的情况下便开始写代码,主要的原因是为了检查我在代码上对设计的还原度,同时也看一下当前的设计在实际运行状况下是否合理,以便总结经验完成下一步的全面设计.</p><p><em>figma功能上同Sketch差不多,而且最低门槛还是免费的.不过它对于网络的外网连接状况要求比较高.</em></p><p>在编写代码的时候,还是能够明显感觉到和设计之间的差别的,有些地方要做取舍,有些地方在实机上的显示又不尽如人意.只有不断的磨合才能增长经验.</p><img src="http://cdn.fatbobman.com/healthnotes-develop-memo-2-3.jpg" alt="截屏2020-08-24 下午4.13.08"/><p>总体而言使用Figma或Sketch进行的设计在SwiftUI中的还原度还是很高的.开发难度也不大.</p><p>在本周开发过程中,出现了一个让我比较头疼的地方,不过最终还是解决了.</p><p>在2.0中,我打算使用类似iOS邮件程序的侧滑菜单进行交互,不过当数据量增大时,显示变得异常卡顿.最终发现了问题出在List中不正确的使用了ForEach.具体关于这部分的内容,我已经记录在了另一篇文章中<a href="http://www.fatbobman.com/posts/swiftui-list-foreach/">聊一下SwiftUI中的List和ForEach</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swiftui-list-foreach</guid><title>聊一下SwiftUI中的List和ForEach</title><description>在SwiftUI中使用List可以非常方便快速的制作各种列表.List其实就是对UITableView进行的封装.</description><link>http://www.fatbobman.com/posts/swiftui-list-foreach</link><pubDate>Mon, 24 Aug 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>在SwiftUI中使用List可以非常方便快速的制作各种列表.List其实就是对UITableView进行的封装(更多List的具体用法请参阅<a href="https://zhuanlan.zhihu.com/p/110749923">List基本用法</a>).</p><p>在List中添加动态内容,我们可以使用两种方式</p><h3>直接使用List自己提供的动态内容构造方法</h3><pre data-language="swift"><code>  <span class="hljs-type">List</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">100</span>){ i <span class="hljs-keyword">in</span>
    <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(id)"</span>)
  }
</code></pre><h3>在List中使用ForEach</h3><pre data-language="swift"><code>  <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">100</span>){ i <span class="hljs-keyword">in</span>
      <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(id)"</span>)
    }
  }
</code></pre><p>在碰到我最近出现的问题之前,我一直以为上述两种用法除了极个别的区别外,基本没有什么不同.</p><p>当时知道的区别:</p><h3>使用ForEach可以在同一List中,添加多个动态源,且可添加静态内容</h3><pre data-language="swift"><code>  <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(items,id:\.<span class="hljs-keyword">self</span>){ item <span class="hljs-keyword">in</span>
      <span class="hljs-type">Text</span>(item)
    }
    <span class="hljs-type">Text</span>(<span class="hljs-string">"其他内容"</span>)
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>){ i <span class="hljs-keyword">in</span>
      <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(i)"</span>)
    }
  }
</code></pre><h3>使用ForEach对于动态内容可以控制版式</h3><pre data-language="swift"><code>  <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>){ i <span class="hljs-keyword">in</span>
      <span class="hljs-type">Rectangle</span>()
        .listRowInsets(<span class="hljs-type">EdgeInsets</span>()) <span class="hljs-comment">//可以控制边界insets</span>
    }
  }
  
  <span class="hljs-type">List</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10</span>){ i <span class="hljs-keyword">in</span>
     <span class="hljs-type">Rectangle</span>()
        .listRowInsets(<span class="hljs-type">EdgeInsets</span>()) 
        <span class="hljs-comment">// 不可以控制边界insets.   .listRowInsets(EdgeInsets())在List中只对静态内容有效</span>
  }
</code></pre><p>基于以上的区别,我在大多数的时候均采用ForEach在List中装填列表内容,并且都取得了预想的效果.</p><p>但是在最近我在开发一个类似于iOS邮件app的列表时发生了让我无语的状态——列表卡顿到完全无法忍耐.</p><p>通过下面的视频可以看到让我痛苦的app表现</p><video src="http://cdn.fatbobman.com/swiftui-list-foreach-10ForEach.mp4" controls = "controls"></video><p>只有十条记录时的状态.非常丝滑</p><pre data-language="swift"><code> <span class="hljs-type">List</span>{
    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10000</span>){ i <span class="hljs-keyword">in</span>
        <span class="hljs-type">Cell</span>(id: i)
          .listRowInsets(<span class="hljs-type">EdgeInsets</span>())
          .swipeCell(cellPosition: .both, leftSlot: slot1, rightSlot: slot1)
        }
    }
</code></pre><video src="http://cdn.fatbobman.com/swiftui-list-foreach-10000MyList.mp4" controls = "controls"></video><p>10000条记录的样子</p><p>在10条记录时一切都很完美,但当记录设置为10000条时,完全卡成了ppt的状态.尤其是View初始化便占有了大量的时间.</p><p>起初我认为可能是我写的滑动菜单的问题,但在自己检查代码后排出了这个选项.为了更好的了解在List中Cell的生命周期状态,写了下面的测试代码.</p><pre data-language="swift"><code>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cell</span>:<span class="hljs-title">View</span></span>{
        <span class="hljs-keyword">let</span> id:<span class="hljs-type">Int</span>
        @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> t = <span class="hljs-type">Test</span>()
        <span class="hljs-keyword">init</span>(id:<span class="hljs-type">Int</span>){
            <span class="hljs-keyword">self</span>.id = id
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"init:\(id)"</span>)
        }
        <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
            <span class="hljs-type">Rectangle</span>()
                .fill(<span class="hljs-type">Color</span>.blue)
                .overlay(
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(id)"</span>)
                )
                .onAppear{
                    t.id = id
                }
        }
        
        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span>:<span class="hljs-title">ObservableObject</span></span>{
            <span class="hljs-keyword">var</span> id:<span class="hljs-type">Int</span> = <span class="hljs-number">0</span>{
                <span class="hljs-keyword">didSet</span>{
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"get value \(id)"</span>)
                }
            }
            <span class="hljs-keyword">init</span>(){
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"init object"</span>)
            }
            <span class="hljs-keyword">deinit</span> {
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"deinit:\(id)"</span>)
            }
        }
    }
    
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>:<span class="hljs-title">ObservableObject</span></span>{
        @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> currentID:<span class="hljs-type">Int</span> = <span class="hljs-number">0</span>
    }
</code></pre><p>执行后,发现了一个奇怪的现象:<strong>在List中,如果用ForEach处理数据源,所有的数据源的View竟然都要在List创建时进行初始化,这完全违背了tableView的本来意图</strong>.</p><p>将上面的代码的数据源切换到List的方式进行测试</p><pre data-language="swift"><code> <span class="hljs-type">List</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">10000</span>){ i <span class="hljs-keyword">in</span>
        <span class="hljs-type">Cell</span>(id: i)
          .listRowInsets(<span class="hljs-type">EdgeInsets</span>())
          .swipeCell(cellPosition: .both, leftSlot: slot1, rightSlot: slot1)
    }
</code></pre><video src="http://cdn.fatbobman.com/swiftui-list-foreach-10000withoutForEach.mp4" controls = "controls"></video><p>熟悉的丝滑又回来了.</p><p><strong>ForEach要预先处理所有数据,提前准备View.并且初始化后,并不自动释放这些View(即使不可见)!</strong>具体可以使用上面的测试代码通过Debug来分析.</p><p>不流畅的原因已经找到了,不过由于List处理的数据源并不能设置listRowInsets,尤其在iOS14下,苹果非常奇怪的屏蔽了不少通过UITableView来设置List的属性的途径,所以为了既能保证性能,又能保证显示需求,只好通过自己包装UITableView来同时满足上述两个条件.</p><p>好在我一直使用<a href="https://github.com/SwiftUIX/SwiftUIX">SwiftUIX</a>这个第三方库,节省了自己写封装代码的时间.将代码做了进一步调整,当前的问题得以解决.</p><pre data-language="swift"><code> <span class="hljs-type">CocoaList</span>(item){ i <span class="hljs-keyword">in</span>
           <span class="hljs-type">Cell</span>(id: i)
           .frame(height:<span class="hljs-number">100</span>)
           .listRowInsets(<span class="hljs-type">EdgeInsets</span>())
           .swipeCell(cellPosition: .both, leftSlot: slot1, rightSlot: slot1)
       }.edgesIgnoringSafeArea(.all)
</code></pre><video src="http://cdn.fatbobman.com/swiftui-list-foreach-10000MyList.mp4" controls = "controls"></video><p>通过这次碰到的问题,我知道了可以在什么情况下使用ForEach.通过这篇文章记录下来,希望其他人少走这样的弯路.</p><p><strong>后记:</strong></p><p>我已经向苹果反馈了这个问题,希望他们能够进行调整吧(最近苹果对于开发者的feedback回应还是挺及时的,Xcode12发布后,我提交了5个feedback,已经有4个获得了反馈,3个在最新版得到了解决).</p><p><strong>遗憾:</strong></p><p>目前的解决方案使我失去了使用ScrollViewReader的机会.</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/healthNote2-development-memo-1</guid><title>健康笔记2.0开发随笔（一）</title><description>健康笔记从2020年1月上线以来，至今已经过了大半年的时间（可以从[老人新兵 —— 一款iOS app的开发手记](https://zhuanlan.zhihu.com/p/103822455)了解健康笔记app的由来）。在这段时间里，我对于Swift、SwiftUI、CoreData等都有了进一步的了解和认识。在开发1.0版本时所面对的问题和疑惑多数都得到了解决。</description><link>http://www.fatbobman.com/posts/healthNote2-development-memo-1</link><pubDate>Mon, 17 Aug 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>健康笔记从2020年1月上线以来，至今已经过了大半年的时间（可以从<a href="https://zhuanlan.zhihu.com/p/103822455">老人新兵 —— 一款iOS app的开发手记</a>了解健康笔记app的由来）。在这段时间里，我对于Swift、SwiftUI、CoreData等都有了进一步的了解和认识。在开发1.0版本时所面对的问题和疑惑多数都得到了解决。</p></blockquote><p>最近随着iOS14发布的临近，同时也想将这短时间来学习的知识进行更系统的整理和应用，于是便将健康笔记2.0的开发工作提上了日程，并已经着手进行中。</p><h2>健康笔记2.0的规</h2><ul><li>功能</li></ul><p>健康笔记1.0目前的功能已基本能够满足我个人的日常使用，在上线这段时间内，我也根据用户提出的建议增加了部分新功能。因此在2.0上，app核心功能的增加并不是太多，主要集中在两点：</p><ul><li>数据类型</li></ul><p>1.0中当前支持两种数据类型，一种是数字型（仅记录一个数字+日期），另一个是选项型（自定义选项内容+日期），在2.0中，新增了其他5中数据类型包括：双数字型、数字选项型、起始时间型等。使用者可以记录生活中更多种类的内容。</p><ul><li>数据导入导出</li></ul><p>1.0中已经提供了对于数字卡片、条目等内容的数据各自的导出支持（csv,pdf,xslx）,2.0版中将提供同一的导出入口，并将提供导入功能。用户可以有更多段选择保管并使用自己的数据，比如将自己创建的卡片分享给其他用户，或者重新导入自己保存的离线数据等。</p><p>既然是一次大版本的更新，虽然在功能上的改变并非太多，但在其他地方的变化还是会很大的，更多的变化都会在后文中提到。</p><h2>开发环境、框架</h2><p>Xcode12 + SwiftUI2.0 ，主要的原因如下：</p><ul><li>从WWDC20以来我一直在跟踪并学习iOS14下的新特性（我的最近的文章大多都有关于此），以及SwiftU2.0中提供的新功能。在规划初始，我打算在2.0中使用不少的新功能来完成自己的构思。由于iOS14对于硬件的支持完全涵盖的之前iOS13的机型，相信对于iOS13的用户来说，更新的阻力不会太大。</li></ul><ul><li>当前的用户数并不多，历史包袱较小。从上线来，目前健康笔记的总下载量才刚刚超过1000，因此让我可以轻装上阵，有较大的调整空间。</li><li>1.0版本中很多的规划、设计不完善。最近几个月，我已经很少向1.0版本中增加新的功能了，主要原因就是最开始的结构设计不合理、代码混乱。如果强行添加更多的功能，只会导致留下更多的隐患，反倒不利于今后的调整。所以在2.0中，决定将之前的数据结构设计进行了较大的改变，将1.0的代码全部推翻重写。</li><li>数据迁移的问题。由于1.0的数据结构设计不佳，我打算在2.0中进行大变化，这样会导致CoreData的数据迁移面临严峻的考验。在1.0版本的数据小升级中，我已经领教到了CoreData的迁移机制所带来的便利性和难以控制的双面问题。尽管可以通过编写自己的CoreData迁移代码来解决结构大变化时所面临的难题，不过为了不留下隐患、给将来的扩充留下更自由的空间，还是决定放弃了使用CoreData的迁移机制。</li><li>我本来就打算在2.0中进一步加强数据的导入导出，所以对于1.0版本的用户，我将提供安全的数据迁移能力，平滑的过度到2.0上。</li></ul><p>结果就是：用户将重新在app store上下载健康笔记2.0app(不是在1.0上更新)，2.0将支持iOS14、macOS 11及以上的系统。之前的健康笔记1.0用户数据都可以安全方便的手动转移到2.0版本上。</p><ul><li>支持多平台</li></ul><p>2.0将支持iPhone,iPad和macOS。</p><p>SwiftUI本身对于多平台的支持就非常出色，不过为了能够在不同的硬件平台下更好的发挥其各自的特点，我还是决定为支持多平台做更多针对性的调整。</p><ul><li>iPhone下仍同1.0一样强制竖屏使用。</li></ul><ul><li>iPad下强制横屏使用，并采用了和iPhone下完全不同的布局。</li></ul><ul><li>macOS下不使用Catalyst，而使用原生的macOS target进行编写。虽然加大了工作量，但可以更好的适配桌面操作，尤其是提供同手指操作完全不同键鼠交互逻辑，并采用更适合桌面平台的布局和控件操作。</li></ul><ul><li>我在最近编写的Swift库中，基本上都提供了跨平台的支持。</li></ul><ul><li>由于决定了进行完全的跨平台开发（uikit+appkit），因此在选择第三方库的限制将会更多。<ul></ul></li></ul><ul><li>多语种</li></ul><p>健康笔记的本身的文字量并不多，因此单纯从文本内容的角度来看，多语种支持并不复杂。不过由于涉及了不少的数据显示、日期计算等，在真正进行多语种支持的时候还是遇到了不少挑战。</p><p>在目前的开发版本中，已经可以让用户在app中单独设置语言、时区而不完全依赖系统设定。</p><p>目前仍没有想好的多语种支持问题主要存在于Demo数据的加载上。我希望能找到一个工作量较小、数据量较小的解决方案。</p><h2>代码结构</h2><p>健康笔记2.0将代码完全推翻重写，其中极为重要的一个原因是我想实现一个自己认可的能适用于SwiftUI的MVVM结构。</p><p>我在开发1.0版本的时候才接触到MVVM，在最初的开发过程中，基本上是按照别人提供的代码逻辑来完成的。在实际的使用中一方面发现了很多自己不理解或用起来不顺手的地方，同时在不断的学习中，也发现了很多传统MVVM不完适应SwiftUI框架的问题。最近几个月，我一直在学习并研究适用于SwfitUI的MVVM结构，2.0的开发中这些学习结果将得到充分的检验机会。</p><p>Xcode12中提供了 SwiftUI lifecycle，从程序入口点，到App Delegate、Scene Delegate响应都有了彻底地改变，如何设计一个更适合Swfit2.0的状态机在不少论坛进行了讨论和分析。我目前在开发中采用的结构对这些都做了有针对性的调整。并且为多平台，多语种都提供不错的响应支持。同时为了便于使用Preview，对于CoreData的声明和注入也做了针对性的调整。</p><p>之后，我会专门写一篇关于这方面的文章和大家一起研究谈探讨。</p><h2>商业计划</h2><p>没有。</p><p>由于编写代码仅是我的个人爱好，对于健康笔记这个项目，我完全是为了满足自己的需要而开发的。因此，在健康笔记上我是没有任何商业规划和愿望与想法的。只要我的精力允许，身体状态ok，我就会坚持吧这个app完善下去。</p><p>我将在开发过程中，不定时地更新随笔。一方面对自己的思路进行一个梳理，同时也希望能够给其他的个人开发者提供一点参考。</p><p><a href="https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewSoftware?id=1492861358">健康笔记1.0下载</a></p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swifui-overlay</guid><title>SwiftUIOverlayContainer ——可以实现各种自定义样式弹出视图的SwitUI库</title><description>SwiftUI目前可以提供sheet,fullScreenCover,alert,actionsheet等弹出视图用于丰富UI交互。不过种类还是有些单调。为了能够更方便的编写各种弹出式窗口的代码，我写了一个简单的SwiftUI库 —— SwiftUIOverlayContainer。</description><link>http://www.fatbobman.com/posts/swifui-overlay</link><pubDate>Wed, 12 Aug 2020 16:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI目前可以提供sheet,fullScreenCover,alert,actionsheet等弹出视图用于丰富UI交互。不过种类还是有些单调。为了能够更方便的编写各种弹出式窗口的代码，我写了一个简单的SwiftUI库 —— SwiftUIOverlayContainer。</p></blockquote><p>SwiftUIOverlayContainer本身并不提供任何预置的视图样式，不过通过它，你有充分的自有度来实现自己需要的视图效果。OverlayContainer的主要目的在于帮助你完成动画、交互、样式定制等基础工作，使开发者能够将时间和精力仅需投入在视图本身的代码上。</p><p><a href="https://github.com/fatbobman/SwiftUIOverlayContainer">SwiftUIOverlayContainer</a></p><video src="http://cdn.fatbobman.com/swiftui-overlay-demo.mp4" controls = "controls">你的浏览器不支持本视频</video><p>库代码已经修改可以直接在xcode11下使用</p><p>代码思路受到了<a href="https://link.zhihu.com/?target=https%3A//github.com/AndreaMiotto/PartialSheet">PartialSheet</a>很大的影响,并使用了其部分代码。</p><h2>使用方法</h2><ol><li>Add a <strong>OverlayContainerManager</strong> instance as an <em>environment object</em> to your Root View in you <em>SceneDelegate</em>or App</li></ol><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-keyword">let</span> manager = <span class="hljs-type">OverlayContainerManager</span>()
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">ContentView</span>()
                .environmentObject(manager)
        }
    }
}
</code></pre><ol><li>Add the <strong>OverlayView</strong> to your <em>Root View</em>, and if you want give it a style. In your RootView file at the end of the builder add the following modifier:</li></ol><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
       ...
       .addOverlayContainer(style: &lt;<span class="hljs-type">OverlayContainerStyle</span>&gt;)
    }
}
</code></pre><ol><li>In anyone of your views add a reference to the <em>environment object</em> and than just call the <code>showOverlayView&lt;T&gt;(_ onDismiss: (() -&gt; Void)? = nil, @ViewBuilder content: @escaping () -&gt; T) where T: View</code> func whenever you want like this:</li></ol><pre data-language="swift"><code>@<span class="hljs-type">EnvironmentObject</span> <span class="hljs-keyword">var</span> manager: <span class="hljs-type">OverlayContainerManager</span>

...

<span class="hljs-type">Button</span>(action: {
    <span class="hljs-keyword">self</span>.manager.showOverlayView({
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"dismissed"</span>)
    }) {
         <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Text</span>(<span class="hljs-string">"This is Overlay View"</span>)
         }
    }
}, label: {
    <span class="hljs-type">Text</span>(<span class="hljs-string">"Show overlyView"</span>)
})
</code></pre><h3>样式说明</h3><pre data-language="swift"><code><span class="hljs-keyword">let</span> style2 = <span class="hljs-type">OverlayContainerStyle</span>(
                                   alignment: .leading,  <span class="hljs-comment">//容器对齐位置</span>
                                   coverColor: <span class="hljs-type">Color</span>.gray.opacity(<span class="hljs-number">0.3</span>), <span class="hljs-comment">//覆盖色</span>
                                   shadow:.<span class="hljs-keyword">init</span> (color: <span class="hljs-type">Color</span>.black.opacity(<span class="hljs-number">0.3</span>), radius: <span class="hljs-number">20</span>, x: <span class="hljs-number">2</span>, y: <span class="hljs-number">0</span>), <span class="hljs-comment">//阴影样式</span>
                                   blur: <span class="hljs-literal">nil</span>,  <span class="hljs-comment">//模糊样式</span>
                                   animation: .easeInOut ,  <span class="hljs-comment">//动画曲线</span>
                                   transition:.move(edge:.leading),  <span class="hljs-comment">//进出动画效果</span>
                                   animatable: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//是否显示动画</span>
                                   autoHide: <span class="hljs-literal">nil</span>,  <span class="hljs-comment">//是否自动隐藏,可设置秒数</span>
                                   enableDrag: <span class="hljs-literal">true</span>,  <span class="hljs-comment">//是否允许滑动取消,目前只支持 .leading,.trailing,.bottom,.top</span>
                                   clickDismiss: <span class="hljs-literal">true</span>) <span class="hljs-comment">//是否支持显示后,点击屏幕其他位置取消</span>
</code></pre><p>更多具体应用,请参看 代码DEMO</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swipeCell</guid><title>用SwiftUI实现iOS mail程序的侧滑菜单</title><description>随着SwiftUI2.0的不断完善，我觉得是时候将我的app做一个较大的升级了。之前一直想在app中实现类似iOS 邮件程序那样优雅的侧滑菜单效果，在网上也找了一下，实现的较好的是适用于UIKit的，基本上没有能够很好的适配SwiftUI的项目库。最终自己在Xcode12实现了一个。</description><link>http://www.fatbobman.com/posts/swipeCell</link><pubDate>Wed, 12 Aug 2020 14:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>随着SwiftUI2.0的不断完善，我觉得是时候将我的app做一个较大的升级了。之前一直想在app中实现类似iOS 邮件程序那样优雅的侧滑菜单效果，在网上也找了一下，实现的较好的是适用于UIKit的，基本上没有能够很好的适配SwiftUI的项目库。最终自己在Xcode12实现了一个。</p></blockquote><p>SwipeCell 是一个用Swift 5.3开发的 SwiftUI库.目标是为了实现类似iOS Mail程序实现的左右滑动菜单功能. SwipeCell 需要 XCode 12 ,iOS 14</p><p><a href="https://github.com/fatbobman/SwipeCell">SwipeCell GitHub</a></p><video src="http://cdn.fatbobman.com/SwipeCellDemoVideo.mp4" controls = "controls">你的浏览器不支持本视频</video><h2>配置Button</h2><pre data-language="swift"><code><span class="hljs-keyword">let</span> button1 = <span class="hljs-type">SwipeCellButton</span>(buttonStyle: .titleAndImage,
                title: <span class="hljs-string">"Mark"</span>, 
                systemImage: <span class="hljs-string">"bookmark"</span>,
                titleColor: .white, 
                imageColor: .white, 
                view: <span class="hljs-literal">nil</span>,   
                backgroundColor: .green,
                action: {bookmark.toggle()},
                feedback:<span class="hljs-literal">true</span>
                )
<span class="hljs-comment">//你可以将按钮设置成任意View从而实现更复杂的设计以及动态效果</span>
<span class="hljs-keyword">let</span> button3 = <span class="hljs-type">SwipeCellButton</span>(buttonStyle: .view, title:<span class="hljs-string">""</span>,systemImage: <span class="hljs-string">""</span>, view: {
    <span class="hljs-type">AnyView</span>(
        <span class="hljs-type">Group</span>{
            <span class="hljs-keyword">if</span> unread {
                <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"envelope.badge"</span>)
                    .foregroundColor(.white)
                    .font(.title)
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"envelope.open"</span>)
                    .foregroundColor(.white)
                    .font(.title)
            }
        }
    )
}, backgroundColor: .orange, action: {unread.toggle()}, feedback: <span class="hljs-literal">false</span>)
</code></pre><h2>配置Slot</h2><pre data-language="swift"><code><span class="hljs-keyword">let</span> slot1 = <span class="hljs-type">SwipeCellSlot</span>(slots: [button2,button1])
<span class="hljs-keyword">let</span> slot2 = <span class="hljs-type">SwipeCellSlot</span>(slots: [button4], slotStyle: .destructive, buttonWidth: <span class="hljs-number">60</span>) 
<span class="hljs-keyword">let</span> slot3 = <span class="hljs-type">SwipeCellSlot</span>(slots: [button2,button1],slotStyle: .destructiveDelay)
</code></pre><h2>装配</h2><pre data-language="swift"><code>cellView()
    .swipeCell(cellPosition: .<span class="hljs-keyword">left</span>, leftSlot: slot4, rightSlot: <span class="hljs-literal">nil</span>)
</code></pre><p>更多的配置选项</p><pre data-language="swift"><code>cellView()
    .swipeCell(cellPosition: .both, 
                leftSlot: slot1, 
                rightSlot: slot1 ,
                swipeCellStyle: <span class="hljs-type">SwipeCellStyle</span>(
                            alignment: .leading,
                            dismissWidth: <span class="hljs-number">20</span>,
                            appearWidth: <span class="hljs-number">20</span>,
                            destructiveWidth: <span class="hljs-number">240</span>, 
                            vibrationForButton: .error, 
                            vibrationForDestructive: .heavy, 
                            autoResetTime: <span class="hljs-number">3</span>)
                            )
</code></pre><h2>滚动列表自动消除</h2><p>For List</p><pre data-language="swift"><code><span class="hljs-type">List</span>{
    ...
    }
    .dismissSwipeCell()
}
</code></pre><p>For single cell in ScrollView</p><pre data-language="swift"><code><span class="hljs-type">ScrollView</span>{
    <span class="hljs-type">VStack</span>{
        <span class="hljs-type">Text</span>(<span class="hljs-string">"Mail Title"</span>)
            .dismissSwipeCellForScrollView() 
        <span class="hljs-type">Text</span>(<span class="hljs-string">"Mail Content"</span>)
        ....
    }
    .frame(maxWidth:.infinity,maxHeight: .infinity)
}
.swipeCell(cellPosition: .both, leftSlot: leftSlot, rightSlot: rightSlot,clip: <span class="hljs-literal">false</span>)
</code></pre><p>For LazyVStack in ScrollView</p><pre data-language="swift"><code><span class="hljs-type">ScrollView</span>{
    <span class="hljs-type">LazyVStack</span>{
    <span class="hljs-type">ForEach</span>(lists,id:\.<span class="hljs-keyword">self</span>){ item <span class="hljs-keyword">in</span>
       <span class="hljs-type">Text</span>(<span class="hljs-string">"Swipe in scrollView:\(item)"</span>)
        .frame(height:<span class="hljs-number">80</span>)
        .swipeCell(cellPosition: .both, leftSlot:slot, rightSlot: slot)
        .dismissSwipeCellForScrollViewForLazyVStack()
    }
    }
}
</code></pre><ul><li>dismissSwipeCell 在editmode下支持选择</li><li>dismissSwipeCellForScrollView 用于ScrollView,通常用于只有一个Cell的场景,比如说Mail中的邮件内容显示.参看Demo中的演示</li><li>dismissSwipeCellForScrollViewForLazyVStack 用于ScrollView中使用LazyVStack场景.个别时候会打断滑动菜单出现动画.个人觉得如无特别需要还是使用List代替LazyVStack比较好.</li></ul><p>由于SwiftUI没有很好的方案能够获取滚动状态,所以采用了 <a href="https://github.com/siteline/SwiftUI-Introspect.git">Introspect</a>实现的上述功能.</p><p>destructiveDelay 形式的 button，需要在action中添加 dismissDestructiveDelayButton()已保证在alter执行后，Cell复位</p><h2>当前问题</h2><ul><li>动画细节仍然不足</li><li>EditMode模式下仍有不足</li></ul><h2>欢迎多提宝贵意见</h2><p>SwipeCell is available under the <a href="https://github.com/fatbobman/SwipeCell/blob/main/LICENSE.md">MIT license</a>.</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/howto-swiftui-import-export</guid><title>HowTo —— SwiftUI2.0 文件导入导出</title><description>SwiftUI2.0中新增了原生的文件导入导出功能。需注意的是对于不同目录下文件的导出行为会有不同，不同平台下对于权限的处理也不同。</description><link>http://www.fatbobman.com/posts/howto-swiftui-import-export</link><pubDate>Tue, 28 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0中新增了原生的文件导入导出功能。需注意的是对于不同目录下文件的导出行为会有不同，不同平台下对于权限的处理也不同。</p></blockquote><h2>更新</h2><p>目前SwiftUI大幅度的修改了导入导出的用法.</p><p>fileImporter fileExporter fileMover 分别对应 导入、导出、移动</p><p>示例如下:</p><pre data-language="swift"><code>  .fileImporter(isPresented: showImport, allowedContentTypes: [.<span class="hljs-built_in">zip</span>], onCompletion: {
            result <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">switch</span> result{
            <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> url):
                <span class="hljs-built_in">print</span>(store.dataHandler.importData(url))
            <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
                <span class="hljs-built_in">print</span>(error)
            }
            
            showImport.wrappedValue = <span class="hljs-literal">false</span>
  })
</code></pre><p>系统会自动弹出一个sheet,目前的fileImporter有bug,如果使用手势取消sheet,会很难二次呼出.只能使用cancel来取消.</p><p>其实我更喜欢之前的用法,不过现在以前的用法已经被废弃了.</p><hr><h2>原文章</h2><hr><h2>importFiles</h2><pre data-language="swift"><code>@<span class="hljs-type">Environment</span>(\.importFiles) <span class="hljs-keyword">var</span> importFile

importFile.callAsFunction(singleOfType: [.plainText]){ result <span class="hljs-keyword">in</span>}
</code></pre><h2>exportFiles</h2><pre data-language="swift"><code>@<span class="hljs-type">Environment</span>(\.exportFiles) <span class="hljs-keyword">var</span> exportFile

<span class="hljs-keyword">try</span>! exportFile.callAsFunction(<span class="hljs-type">FileWrapper</span>(url: <span class="hljs-type">URL</span>(fileURLWithPath:filePath), options: .immediate), contentType: .plainText){result <span class="hljs-keyword">in</span>}
</code></pre><h2>示例代码</h2><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ExportImportTest</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">Environment</span>(\.importFiles) <span class="hljs-keyword">var</span> importFile
    @<span class="hljs-type">Environment</span>(\.exportFiles) <span class="hljs-keyword">var</span> exportFile
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> text:<span class="hljs-type">String</span> = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>{
            <span class="hljs-type">Button</span>(<span class="hljs-string">"生成文件"</span>){
                <span class="hljs-keyword">let</span> filePath = <span class="hljs-type">NSTemporaryDirectory</span>() + <span class="hljs-string">"test.txt"</span>
                <span class="hljs-keyword">let</span> outputText = <span class="hljs-string">"Hello World!"</span>
                <span class="hljs-keyword">do</span> {
                    <span class="hljs-keyword">try</span> outputText.write(toFile: filePath, atomically: <span class="hljs-literal">true</span>, encoding: .utf8)
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"测试文件已生成"</span>)
                }
                <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> error {
                    <span class="hljs-built_in">print</span>(error)
                }
            }
            
            <span class="hljs-type">Button</span>(<span class="hljs-string">"导入文件importFiles"</span>){
                importFile.callAsFunction(singleOfType: [.plainText]){ result <span class="hljs-keyword">in</span>
                    <span class="hljs-keyword">switch</span> result{
                    <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> url):
                        <span class="hljs-built_in">print</span>(url)
                        <span class="hljs-keyword">do</span> {
                            <span class="hljs-comment">//iOS的沙盒机制保护需要我们申请临时调用url的权限</span>
                            <span class="hljs-number">_</span> = url.startAccessingSecurityScopedResource()
                            <span class="hljs-keyword">let</span> fileData = <span class="hljs-keyword">try</span> <span class="hljs-type">Data</span>(contentsOf: url)
                            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> text = <span class="hljs-type">String</span>(data:fileData,encoding: .utf8) {
                                <span class="hljs-keyword">self</span>.text = text
                                <span class="hljs-built_in">print</span>(text)
                            }
                            url.stopAccessingSecurityScopedResource()
                        }
                        <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> error {
                            <span class="hljs-built_in">print</span>(error)
                        }
                    <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
                        <span class="hljs-built_in">print</span>(error)
                    <span class="hljs-keyword">case</span> .<span class="hljs-keyword">none</span>:
                        <span class="hljs-keyword">break</span>
                    }
                }
            }
            
            <span class="hljs-type">Button</span>(<span class="hljs-string">"导出文件exportFiles"</span>){
                <span class="hljs-comment">//exportFile.callAsFunction(moving: URL, completion:  ) 移动文件,源文件会被删除</span>
                <span class="hljs-comment">//move如果出错(比如没有找到源文件,程序会崩溃)</span>
                <span class="hljs-comment">//从临时目录导出文件无论是否使用move,源文件都会被删除</span>
                <span class="hljs-comment">//个人比较倾向于FileWrapper的调用方式</span>
                <span class="hljs-keyword">let</span> filePath = <span class="hljs-type">NSTemporaryDirectory</span>() + <span class="hljs-string">"test.txt"</span>
                <span class="hljs-keyword">do</span> {
                    <span class="hljs-keyword">try</span> exportFile.callAsFunction(<span class="hljs-type">FileWrapper</span>(url: <span class="hljs-type">URL</span>(fileURLWithPath:filePath), options: .immediate), contentType: .plainText){result <span class="hljs-keyword">in</span>
                        <span class="hljs-keyword">switch</span> result{
                        <span class="hljs-keyword">case</span> .success(<span class="hljs-keyword">let</span> url):
                            <span class="hljs-built_in">print</span>(<span class="hljs-string">"文件导出成功:\(url)"</span>)
                        <span class="hljs-keyword">case</span> .failure(<span class="hljs-keyword">let</span> error):
                            <span class="hljs-built_in">print</span>(error)
                        <span class="hljs-keyword">case</span> .<span class="hljs-keyword">none</span>:
                            <span class="hljs-keyword">break</span>
                        }
                    }
                }
                <span class="hljs-keyword">catch</span> <span class="hljs-keyword">let</span> error {
                    <span class="hljs-built_in">print</span>(error)
                }
            }
            
            <span class="hljs-type">Text</span>(<span class="hljs-string">"导入文件内容:\(text)"</span>)
        }
    }
}
</code></pre><blockquote><p><strong>macOS下需要将项目配置中的 App Sandbox - User Selected File 设置为 读写</strong></p></blockquote><video src="http://cdn.fatbobman.com/howto-swiftui-import-export-video.mp4" controls = "controls">你的浏览器不支持本视频</video><h2>遗憾</h2><p>没有提供原生的activityViewController。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/howto-swiftui-scrollviewReader</guid><title>HowTo —— SwiftUI2.0使用ScrollViewReader定位滚动位置</title><description>SwiftUI2.0增加了滚动定位功能,已经可以较轻松的适应大多数场景的应用。实现手段完全不同于之前民间的各种解决方案,并不是通过设置具体的offset来进行定位,而是使用id来进行位置标记。</description><link>http://www.fatbobman.com/posts/howto-swiftui-scrollviewReader</link><pubDate>Thu, 23 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0增加了滚动定位功能,已经可以较轻松的适应大多数场景的应用。实现手段完全不同于之前民间的各种解决方案,并不是通过设置具体的offset来进行定位,而是使用id来进行位置标记。</p></blockquote><h2>基本用法——实现从右向左滚动</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ScrollReaderTest</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ScrollView</span>(.horizontal) {
            <span class="hljs-comment">//类似GeometryReader的使用方式，设定滚动定位区域</span>
            <span class="hljs-type">ScrollViewReader</span>{ proxy <span class="hljs-keyword">in</span>
                <span class="hljs-type">Rectangle</span>()
                    .fill(<span class="hljs-type">LinearGradient</span>(
                      gradient: <span class="hljs-type">Gradient</span>(colors: [.blue,.red]),
                      startPoint: .leading,
                      endPoint: .trailing))
                    .frame(width: <span class="hljs-number">1000</span>, height: <span class="hljs-number">300</span>, alignment: .center)
                    .id(<span class="hljs-string">"rec"</span>) <span class="hljs-comment">//为ScrollView中需要定位的View设置id</span>
                    .onAppear {
                        <span class="hljs-comment">//滚动到指定id的位置，按照anchor的设置来对齐</span>
                        proxy.scrollTo(<span class="hljs-string">"rec"</span>,anchor:.trailing)
                  }
            }
        }
    }
}
</code></pre><h2>通过按钮来滚动到指定位置</h2><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ScrollReadeTest</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> list = <span class="hljs-type">ScrollItem</span>.items(<span class="hljs-number">300</span>)
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> position:<span class="hljs-type">Int</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
      <span class="hljs-type">NavigationView</span>{
        <span class="hljs-type">ScrollView</span>{
            <span class="hljs-type">ScrollViewReader</span>{ proxy <span class="hljs-keyword">in</span>
                <span class="hljs-type">LazyVStack</span>{
                    <span class="hljs-type">ForEach</span>(list,id:\.id){ item <span class="hljs-keyword">in</span>
                        <span class="hljs-type">Text</span>(item.title).id(item.id)
                    }
                }
                .onChange(of: position) { positon <span class="hljs-keyword">in</span>
                    <span class="hljs-keyword">switch</span> position{
                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: 
                        <span class="hljs-keyword">let</span> id = list.first!.id
                        withAnimation(<span class="hljs-type">Animation</span>.easeInOut){
                            proxy.scrollTo(id,anchor:.top)
                        }
                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                        
                        <span class="hljs-keyword">let</span> id = list[<span class="hljs-type">Int</span>(list.<span class="hljs-built_in">count</span> / <span class="hljs-number">2</span>)].id
                        withAnimation(<span class="hljs-type">Animation</span>.easeInOut){
                            proxy.scrollTo(id,anchor:.center)
                        }
                    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:
                        <span class="hljs-keyword">let</span> id = list.last!.id
                        withAnimation(<span class="hljs-type">Animation</span>.easeInOut){
                            proxy.scrollTo(id,anchor:.bottom)
                        }
                    <span class="hljs-keyword">default</span>:
                        <span class="hljs-keyword">break</span>
                    }
                }
            }
        }
        .navigationTitle(<span class="hljs-string">"滚动定位"</span>)
        
        .toolbar {
            <span class="hljs-type">ToolbarItem</span>(placement:.automatic) {
                <span class="hljs-type">HStack</span>{
                    <span class="hljs-type">Button</span>(<span class="hljs-string">"top"</span>){
                        position = <span class="hljs-number">1</span>
                    }
                    <span class="hljs-type">Button</span>(<span class="hljs-string">"mid"</span>){
                        position = <span class="hljs-number">2</span>
                    }
                    <span class="hljs-type">Button</span>(<span class="hljs-string">"end"</span>){
                        position = <span class="hljs-number">3</span>
                    }
                }
            }
         }
      }
   }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ScrollItem</span>:<span class="hljs-title">Identifiable</span></span>{
    <span class="hljs-keyword">var</span> id = <span class="hljs-type">UUID</span>()
    <span class="hljs-keyword">var</span> title:<span class="hljs-type">String</span>
    
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">items</span><span class="hljs-params">(<span class="hljs-number">_</span> <span class="hljs-built_in">count</span>:Int)</span></span> -&gt; [<span class="hljs-type">ScrollItem</span>]{
        <span class="hljs-keyword">var</span> result:[<span class="hljs-type">ScrollItem</span>] = []
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..&lt;<span class="hljs-built_in">count</span>{
            result.append(<span class="hljs-type">ScrollItem</span>(title:<span class="hljs-type">String</span>(<span class="hljs-string">"index:\(i) title:\(Int.random(in: 1000...5000))"</span>)))
        }
        <span class="hljs-keyword">return</span> result
    }
}
</code></pre><video src="http://cdn.fatbobman.com/howto-swiftui-scrollviewReader-video.mp4" controls="controls">你的浏览器不支持本视频</video><h2>遗憾</h2><p>没有简单的手段记录当前的滚动位置。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/howto-swiftui-progressView</guid><title>HowTo —— SwiftUI2.0 使用ProgressView显示进度条</title><description>SwiftUI2.0 新增了一些便捷的内置控件，比如说Label、ProgressView等。其基本形态都很普通，不过都支持自定义style。官方的意图也比较明显，通过内置控件，规范代码、提高原型编写速度，如需要更精细控制可通过扩展style来完成。</description><link>http://www.fatbobman.com/posts/howto-swiftui-progressView</link><pubDate>Sun, 12 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0 新增了一些便捷的内置控件，比如说Label、ProgressView等。其基本形态都很普通，不过都支持自定义style。官方的意图也比较明显，通过内置控件，规范代码、提高原型编写速度，如需要更精细控制可通过扩展style来完成。</p></blockquote><h2>经典小菊花</h2><pre data-language="swift"><code><span class="hljs-type">ProgressView</span>()
</code></pre><img src="http://cdn.fatbobman.com/howto-swiftui-progressView-progress1.png" alt="progress1"/><h2>线性进度条</h2><pre data-language="swift"><code><span class="hljs-type">ProgressView</span>(<span class="hljs-string">"完成量"</span>, value: <span class="hljs-number">50</span>, total: <span class="hljs-number">100</span>)
</code></pre><img src="http://cdn.fatbobman.com/howto-swiftui-progressView-progress2.png" alt="截屏2020-07-11 下午4.09.34"/><h2>代码示例</h2><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ProgressTest</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> timer = <span class="hljs-type">Timer</span>.<span class="hljs-type">TimerPublisher</span>(interval: <span class="hljs-number">0.03</span>, runLoop: .main, mode: .common).autoconnect()
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> value:<span class="hljs-type">Double</span> = <span class="hljs-number">0.0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>{
            <span class="hljs-comment">//无法定义颜色</span>
            <span class="hljs-type">ProgressView</span>()
            
            <span class="hljs-comment">//无法隐藏Label</span>
            <span class="hljs-type">ProgressView</span>(<span class="hljs-string">"完成量"</span>, value: value, total: <span class="hljs-number">100</span>)
                .accentColor(.red)
            <span class="hljs-comment">//自定义Style</span>
            <span class="hljs-type">ProgressView</span>(<span class="hljs-string">"工程进度"</span>,value: value, total: <span class="hljs-number">100</span>)
                .progressViewStyle(<span class="hljs-type">MyProgressViewStyle</span>())
        }
        .onAppear {
            timer = <span class="hljs-type">Timer</span>.<span class="hljs-type">TimerPublisher</span>(interval: <span class="hljs-number">0.03</span>, runLoop: .main, mode: .common).autoconnect()
        }
        .onReceive(timer) { <span class="hljs-number">_</span> <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">100</span> {
                value += <span class="hljs-number">2</span>
            }
        }
    }
}

<span class="hljs-comment">//定义方法都大同小异。</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyProgressViewStyle</span>:<span class="hljs-title">ProgressViewStyle</span></span>{
    <span class="hljs-keyword">let</span> foregroundColor:<span class="hljs-type">Color</span>
    <span class="hljs-keyword">let</span> backgroundColor:<span class="hljs-type">Color</span>
    <span class="hljs-keyword">init</span>(foregroundColor:<span class="hljs-type">Color</span> = .blue,backgroundColor:<span class="hljs-type">Color</span> = .orange){
        <span class="hljs-keyword">self</span>.foregroundColor = foregroundColor
        <span class="hljs-keyword">self</span>.backgroundColor = backgroundColor
    }
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBody</span><span class="hljs-params">(configuration: Configuration)</span></span> -&gt; some <span class="hljs-type">View</span> {
        <span class="hljs-type">GeometryReader</span>{ proxy <span class="hljs-keyword">in</span>
            <span class="hljs-type">ZStack</span>(alignment:.topLeading){
            backgroundColor
            <span class="hljs-type">Rectangle</span>()
                .fill(foregroundColor)
                .frame(width:proxy.size.width * <span class="hljs-type">CGFloat</span>(configuration.fractionCompleted ?? <span class="hljs-number">0.0</span>))
            }.clipShape(<span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>))
            .overlay(
                    configuration.label
                        .foregroundColor(.white)
            )
        }
    }
}
</code></pre><video src="http://cdn.fatbobman.com/howto-swiftui-progressView-video.mov" controls = "controls">你的浏览器不支持本视频</video>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/howto-swiftui-onOpenUrl</guid><title>HowTo —— 使用onOpenURL处理Universal Links</title><description>SwiftUI2.0由于可以采用新的代码架构（Life Cycle SwiftUI App）来组织app,因此提供了onOpenURL来处理Univeresal Links。不同于在AppDelegate或SceneDelegate中的解决方案，onOpenURL作为一个view modifier，你可以在任意View上注册你的app的URL处理机制。</description><link>http://www.fatbobman.com/posts/howto-swiftui-onOpenUrl</link><pubDate>Sat, 11 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0由于可以采用新的代码架构（Life Cycle SwiftUI App）来组织app,因此提供了onOpenURL来处理Univeresal Links。不同于在AppDelegate或SceneDelegate中的解决方案，onOpenURL作为一个view modifier，你可以在任意View上注册你的app的URL处理机制。关于如何为自己的app创建URL Scheme，请参阅<a href="https://developer.apple.com/documentation/uikit/inter-process_communication/allowing_apps_and_websites_to_link_to_your_content/defining_a_custom_url_scheme_for_your_app">苹果的官方文档</a>。</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-type">VStack</span>{
   <span class="hljs-type">Text</span>(<span class="hljs-string">"Hello World"</span>)
}
.onOpenURL{ url <span class="hljs-keyword">in</span>
    <span class="hljs-comment">//做点啥</span>
}
</code></pre><h2>示例代码</h2><p>首先在项目中设置URL</p><img src="http://cdn.fatbobman.com/howto-swiftui-onOpenURL-URL.png" alt="URL"/><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> tabSelection:<span class="hljs-type">TabSelection</span> = .news
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> show = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">TabView</span>(selection:$tabSelection){
            <span class="hljs-type">Text</span>(<span class="hljs-string">"News"</span>)
                .tabItem {<span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"newspaper"</span>)}
                .tag(<span class="hljs-type">TabSelection</span>.news)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"Music"</span>)
                .tabItem {<span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"music.quarternote.3"</span>)}
                .tag(<span class="hljs-type">TabSelection</span>.music)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"Settings"</span>)
                .tabItem {<span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"dial.max"</span>)}
                .tag(<span class="hljs-type">TabSelection</span>.settings)
        }
        .sheet(isPresented: $show) {
            <span class="hljs-type">Text</span>(<span class="hljs-string">"URL调用参数错误"</span>)
        }
        .onOpenURL { url <span class="hljs-keyword">in</span>
            <span class="hljs-keyword">let</span> selection = url.host
            <span class="hljs-keyword">switch</span> selection{
            <span class="hljs-keyword">case</span> <span class="hljs-string">"news"</span>:
                tabSelection = .news
            <span class="hljs-keyword">case</span> <span class="hljs-string">"music"</span>:
                tabSelection = .music
            <span class="hljs-keyword">case</span> <span class="hljs-string">"settings"</span>:
                tabSelection = .settings
            <span class="hljs-keyword">default</span>:
                show = <span class="hljs-literal">true</span>
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">TabSelection</span>:<span class="hljs-title">Hashable</span></span>{
    <span class="hljs-keyword">case</span> news,music,settings
}
</code></pre><blockquote><p>macOS目前暂不支持，应该会在正式版本提供。</p></blockquote><video src="http://cdn.fatbobman.com/howto-swiftui-onOpenURL-video.mp4" controls = "controls">你的浏览器不支持本视频</video><h2>特别注意</h2><ul><li>onOpenURL只有在项目采用Swift App的方式管理Life Cycle才会响应</li></ul><ul><li>在代码中可以添加多个onOpenURL，注册在不同的View上，当采用URL访问时，每个闭包都会响应。这样可以针对不同的View做出各自需要的调整。</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/howto-swiftui-toolbar</guid><title>HowTo —— SwiftUI2.0 使用ToolBar替代navigationbarItems</title><description>SwiftUI2.0为了实现更好的多平台支持同时需要兼顾1.0版本代码兼容性，提供了一些与已有控件功能上类似但名称和用法全新的控件。比如ToolBar, navigationTitle等。Toolbar可以实现navigationbarItems的全部功能，并新增了在多平台下的适配。采用了全新的语法，代码更易阅读。</description><link>http://www.fatbobman.com/posts/howto-swiftui-toolbar</link><pubDate>Fri, 10 Jul 2020 14:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0为了实现更好的多平台支持同时需要兼顾1.0版本代码兼容性，提供了一些与已有控件功能上类似但名称和用法全新的控件。比如ToolBar, navigationTitle等。Toolbar可以实现navigationbarItems的全部功能，并新增了在多平台下的适配。采用了全新的语法，代码更易阅读。 <strong>在当前的Xcode Version 12.0 beta 2 (12A6163b)版本下，ToolBar在macOS下仍然有非常多的问题。</strong></p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ToolBarTest</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
      <span class="hljs-type">NavigationView</span>{
        <span class="hljs-type">Text</span>(<span class="hljs-string">"ToolBar 演示"</span>)
            .toolbar{
                <span class="hljs-type">ToolbarItem</span>(placement:.automatic){
                    <span class="hljs-type">HStack</span>(spacing:<span class="hljs-number">20</span>){
                        <span class="hljs-type">Button</span>(action:{<span class="hljs-built_in">print</span>(<span class="hljs-string">"wave"</span>)}){
                            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"waveform.path.badge.plus"</span>)
                                .foregroundColor(.purple)
                                .scaleEffect(<span class="hljs-number">1.5</span>, anchor: .center)
                        }
                        
                    }
                }
                <span class="hljs-comment">//placement设置放置位置，ToolBarItem中的View解析不会完全和预期一致，不知道是特别限制还是bug.比如说无法显示多彩符号，无法使用Spacer等。</span>
                <span class="hljs-type">ToolbarItem</span>(placement: .bottomBar){
                    <span class="hljs-type">HStack</span>(spacing:<span class="hljs-number">100</span>){
                        <span class="hljs-type">Button</span>(action:{<span class="hljs-built_in">print</span>(<span class="hljs-string">"lt"</span>)}){
                            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"lt.rectangle.roundedtop.fill"</span>)
                                .foregroundColor(.purple)
                                .scaleEffect(<span class="hljs-number">1.5</span>, anchor: .center)
                        }
                        
                        <span class="hljs-type">Button</span>(action:{<span class="hljs-built_in">print</span>(<span class="hljs-string">"rt"</span>)}){
                            <span class="hljs-type">Image</span>(systemName: <span class="hljs-string">"rt.rectangle.roundedtop.fill"</span>)
                                .foregroundColor(.purple)
                                .scaleEffect(<span class="hljs-number">1.5</span>, anchor: .center)
                        }
                    }
                }
            }
        }
    }
}
</code></pre><img src="http://cdn.fatbobman.com/howto-swiftui-toolbar-toolbar1.png width=300" alt="截屏2020-07-10 上午9.01.52"/><h2>多平台适配</h2><p>为了能够更好的适配多平台，placment提供了automatic这样的多平台自适应选项。placement有些值全平台可用，有些只支持部分平台，还有一部分的可在多平台运行不过只能在部分平台正确显示。</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ToolBarTest</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> placementSelection:<span class="hljs-type">Placement</span> = .automatic
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> placement:<span class="hljs-type">ToolbarItemPlacement</span> = .automatic
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> show = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">NavigationView</span>{
            <span class="hljs-type">VStack</span>{
                <span class="hljs-type">Picker</span>(<span class="hljs-string">"placement:"</span>,selection:$placementSelection){
                    <span class="hljs-type">ForEach</span>(<span class="hljs-type">Placement</span>.allCases,id:\.<span class="hljs-keyword">self</span>){ placement <span class="hljs-keyword">in</span>
                        <span class="hljs-type">Text</span>(placement.rawValue)
                            .tag(placement)
                    }
                }
                .labelsHidden()
                .padding(.all, <span class="hljs-number">10</span>)
                .onChange(of: placementSelection) { value <span class="hljs-keyword">in</span>
                    <span class="hljs-keyword">switch</span> value{
                    <span class="hljs-keyword">case</span> .automatic:
                        placement = .automatic
                    <span class="hljs-keyword">case</span> .principal:
                        placement = .principal <span class="hljs-comment">//iOS不显示</span>
                    <span class="hljs-keyword">case</span> .navigation:
                        placement = .navigation
                    <span class="hljs-keyword">case</span> .primaryAction:
                        placement = .primaryAction
                    <span class="hljs-keyword">case</span> .status:
                        placement = .status <span class="hljs-comment">//iOS不显示</span>
                    <span class="hljs-keyword">case</span> .confirmationAction:
                        placement = .confirmationAction <span class="hljs-comment">//iOS不显示</span>
                    <span class="hljs-keyword">case</span> .cancellationAction:
                        placement = .cancellationAction <span class="hljs-comment">//iOS不显示</span>
                    <span class="hljs-keyword">case</span> .destructiveAction:
                        placement = .destructiveAction <span class="hljs-comment">//iOS不显示</span>
                    #<span class="hljs-keyword">if</span> os(iOS)
                    <span class="hljs-keyword">case</span> .bottomBar:
                        placement = .bottomBar
                    <span class="hljs-comment">//不知道为什么有bug,设置后不显示</span>
                    <span class="hljs-comment">//ToolbarItem(placement:.bottomBar)可以显示</span>
                    <span class="hljs-keyword">case</span> .navigationBarLeading:
                        placement = .navigationBarLeading
                    <span class="hljs-keyword">case</span> .navigationBarTrailing:
                        placement = .navigationBarTrailing
                    #endif
                    }
                }
                <span class="hljs-comment">//在macOS下如果需要显式设置是否显示ToolBar,需要设置id,iOS下可以不用设置</span>
                <span class="hljs-comment">//当前在macOS下,如果不显式关闭可能导致不同View的ToolBar混合到了一起,或者重复出现.不知道是否是bug还是设计逻辑</span>
                .toolbar(id:<span class="hljs-string">"ToolBar"</span>) {
                    <span class="hljs-type">ToolbarItem</span>(id:<span class="hljs-string">"1"</span>,placement:placement,showsByDefault:show) {
                        <span class="hljs-type">Button</span>(<span class="hljs-string">"确定"</span>){
                            
                        }
                    }
                }
                .navigationTitle(<span class="hljs-string">"Toolbar演示"</span>)
                
                #<span class="hljs-keyword">if</span> os(macOS)
                <span class="hljs-type">Toggle</span>(<span class="hljs-string">"显示ToolBar"</span>,isOn:$show)
                <span class="hljs-type">Spacer</span>()
                #endif
            } .frame(maxWidth:.infinity,maxHeight: .infinity)
        }
        
    }
}

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Placement</span>:<span class="hljs-title">String</span>,<span class="hljs-title">CaseIterable</span></span>{
    <span class="hljs-keyword">case</span> automatic,principal,navigation
    <span class="hljs-keyword">case</span> primaryAction,status,confirmationAction
    <span class="hljs-keyword">case</span> cancellationAction,destructiveAction
    #<span class="hljs-keyword">if</span> os(iOS)
    <span class="hljs-keyword">case</span> navigationBarLeading,navigationBarTrailing,bottomBar
    #endif
}
</code></pre><video src="http://cdn.fatbobman.com/howto-swiftui-toolbar-video.mp4" controls = "controls">你的浏览器不支持本视频</video><blockquote><p>macOS下不同placement的演示</p></blockquote><p><strong>遗憾</strong></p><p>macOS目前bug较多，ToolBarItem对于View的解析还不完整，ToolBarContentBuilder不支持逻辑判断。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/howto-swiftui-link-openurl</guid><title>HowTo —— SwiftUI2.0 使用Link或openURL打开URL scheme</title><description>SwiftUI2.0提供了原生的打开URL scheme的功能，我们可以十分方便的在代码中调用其他的app。</description><link>http://www.fatbobman.com/posts/howto-swiftui-link-openurl</link><pubDate>Fri, 10 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0提供了原生的打开URL scheme的功能，我们可以十分方便的在代码中调用其他的app。</p></blockquote><h2>Link</h2><p>类似于 NavigationLink ,直接打开URL scheme对应的app</p><pre data-language="swift"><code><span class="hljs-type">Link</span>(<span class="hljs-string">"openURL"</span>,destination:safariUrl)
</code></pre><h2>openURL</h2><p>本次在SwiftUI2.0中，苹果提供了若干个通过Environment注入的调用系统操作的方法。比如 exportFiles,importFiles,openURL等。</p><pre data-language="swift"><code>@<span class="hljs-type">Environment</span>(\.openURL) <span class="hljs-keyword">var</span> openURL
openURL.callAsFunction(url)
</code></pre><h2>代码范例</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">URLTest</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">Environment</span>(\.openURL) <span class="hljs-keyword">var</span> openURL
    <span class="hljs-keyword">let</span> safariUrl = <span class="hljs-type">URL</span>(string:<span class="hljs-string">"http://www.apple.com"</span>)!
    <span class="hljs-keyword">let</span> mailUrl = <span class="hljs-type">URL</span>(string:<span class="hljs-string">"mailto:foo@example.com?cc=bar@example.com&amp;subject=Hello%20Wrold&amp;body=Testing!"</span>)!
    <span class="hljs-keyword">let</span> phoneURl = <span class="hljs-type">URL</span>(string:<span class="hljs-string">"tel:12345678"</span>)!
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>{
            <span class="hljs-type">Link</span>(<span class="hljs-string">"使用safari打开网页"</span>,destination:safariUrl)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"发送邮件"</span>){
                openURL.callAsFunction(mailUrl){ result <span class="hljs-keyword">in</span>
                    <span class="hljs-built_in">print</span>(result)
                }
            }
            <span class="hljs-type">Link</span>(destination: phoneURl){
                <span class="hljs-type">Label</span>(<span class="hljs-string">"拨打电话"</span>,systemImage:<span class="hljs-string">"phone.circle"</span>)
            }
        }
    }
}
</code></pre><blockquote><p>模拟器仅支持极少数的URL，最好使用真机测试 <a href="https://developer.apple.com/library/archive/featuredarticles/iPhoneURLScheme_Reference/PhoneLinks/PhoneLinks.html#//apple_ref/doc/uid/TP40007899-CH6-SW1">苹果官方提供的一些URL scheme</a></p></blockquote><video src="http://cdn.fatbobman.com/howto-swiftui-openurl-video.mp4" controls = "controls">你的浏览器不支持本视频</video>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/howto-swiftui-grid</guid><title>HowTO —— SwiftUI2.0 原生的Grid</title><description>SwiftUI的第一版中，官方并没有提供UICollectionView的对应功能。开发者需要自行包装或者依赖很多第三方库。SwiftUI2.0中，苹果通过LazyVGrid、LazyHGrid提供了Grid控件。该控件的实现很有SwiftUI的风格，和众多的第三方库有显著的区别。</description><link>http://www.fatbobman.com/posts/howto-swiftui-grid</link><pubDate>Fri, 10 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI的第一版中，官方并没有提供UICollectionView的对应功能。开发者需要自行包装或者依赖很多第三方库。SwiftUI2.0中，苹果通过LazyVGrid、LazyHGrid提供了Grid控件。该控件的实现很有SwiftUI的风格，和众多的第三方库有显著的区别。</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GridTest1</span>: <span class="hljs-title">View</span> </span>{
    
    <span class="hljs-keyword">let</span> columns = [
        <span class="hljs-type">GridItem</span>(.adaptive(minimum: <span class="hljs-number">50</span>))
        <span class="hljs-comment">//adaptive自适应，在一行或一列中放入尽可能多的Item</span>
        <span class="hljs-comment">//fixed完全固定的尺寸 GridItem(.fixed(50)), 需显式设置每行或每列中放入的item数量</span>
        <span class="hljs-comment">//flexible用法类似fixed，不过每个item的尺寸可以弹性调整，同样需要显式设置item数量</span>
        <span class="hljs-comment">//可以混用</span>
    ]
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ScrollView</span>{
            <span class="hljs-type">LazyVGrid</span>(columns: columns, <span class="hljs-comment">//行列设置数据</span>
                      alignment: .center,
                      spacing: <span class="hljs-number">20</span>,  <span class="hljs-comment">//item行或列宽</span>
                      pinnedViews: [.sectionHeaders] 
                      <span class="hljs-comment">//如果有section,将header或footer在滚动中固定</span>
            ){
                <span class="hljs-type">Section</span>(header:<span class="hljs-type">Text</span>(<span class="hljs-string">"Header"</span>)){
                    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>...<span class="hljs-number">1000</span>,id:\.<span class="hljs-keyword">self</span>){ id <span class="hljs-keyword">in</span>
                        <span class="hljs-type">Text</span>(<span class="hljs-type">String</span>(id))
                            .foregroundColor(.white)
                            .padding(.all, <span class="hljs-number">10</span>)
                            .background(<span class="hljs-type">Rectangle</span>().fill(<span class="hljs-type">Color</span>.orange))
                    }
                }
            }
        }
    }
}
</code></pre><img src="http://cdn.fatbobman.com/howto-swiftui-grid1.png" alt="image-20200709202554829"/><h2>LazyVGrid和LazyHGrid混合使用</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CombineGrid</span>: <span class="hljs-title">View</span> </span>{
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ScrollView</span>{
            <span class="hljs-type">LazyVGrid</span>(columns: [<span class="hljs-type">GridItem</span>(.adaptive(minimum:<span class="hljs-number">40</span>))], alignment: .center, spacing: <span class="hljs-number">10</span>){
                <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>...<span class="hljs-number">40</span>,id:\.<span class="hljs-keyword">self</span>){ id <span class="hljs-keyword">in</span>
                    cell(id:id,color:.red)
                }
            }
            <span class="hljs-comment">//横向滚动</span>
            <span class="hljs-type">ScrollView</span>(.horizontal) {
                <span class="hljs-type">LazyHGrid</span>(rows: [<span class="hljs-type">GridItem</span>(.fixed(<span class="hljs-number">50</span>)),<span class="hljs-type">GridItem</span>(.fixed(<span class="hljs-number">50</span>))]){
                    <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>...<span class="hljs-number">100</span>,id:\.<span class="hljs-keyword">self</span>){id <span class="hljs-keyword">in</span>
                        cell(id:id,color:.green)
                    }
                }
            }
            .frame(height: <span class="hljs-number">240</span>, alignment: .center)
            <span class="hljs-type">LazyVGrid</span>(columns: [<span class="hljs-type">GridItem</span>(.adaptive(minimum:<span class="hljs-number">40</span>))], alignment: .center, spacing: <span class="hljs-number">10</span>){
                <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>...<span class="hljs-number">100</span>,id:\.<span class="hljs-keyword">self</span>){ id <span class="hljs-keyword">in</span>
                    cell(id:id,color:.blue)
                }
            }
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cell</span><span class="hljs-params">(id:Int,color:Color)</span></span> -&gt; some <span class="hljs-type">View</span>{
        <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)
            .fill(color)
            .frame(width: <span class="hljs-number">50</span>, height: <span class="hljs-number">50</span>)
            .overlay(<span class="hljs-type">Text</span>(<span class="hljs-string">"\(id)"</span>).foregroundColor(.white))
    }
}
</code></pre><img src="http://cdn.fatbobman.com/howto-swiftui-grid2.png" alt="image-20200709205047655"/><blockquote><p><strong>这段代码快速向上滚动时显示正常，如果向上滚动速度较慢，中部的LazyHGrid会显示异常。应该是bug。当前环境Xcode Version 12.0 beta 2 (12A6163b)</strong></p></blockquote><h2>各种参数混合的例子</h2><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GridTest</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> data = (<span class="hljs-number">1</span>...<span class="hljs-number">1000</span>).<span class="hljs-built_in">map</span>{i <span class="hljs-keyword">in</span> <span class="hljs-type">CellView</span>(item:i, width: <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: <span class="hljs-number">30</span>...<span class="hljs-number">100</span>)), height: <span class="hljs-type">CGFloat</span>(<span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: <span class="hljs-number">40</span>...<span class="hljs-number">80</span>)))}
    
    <span class="hljs-keyword">let</span> column1 = [
        <span class="hljs-type">GridItem</span>(.adaptive(minimum: <span class="hljs-number">40</span>, maximum: <span class="hljs-number">80</span>))
    ]
    <span class="hljs-keyword">let</span> column2 = [
        <span class="hljs-type">GridItem</span>(.flexible()),
        <span class="hljs-type">GridItem</span>(.flexible()),
        <span class="hljs-type">GridItem</span>(.flexible()),
        <span class="hljs-type">GridItem</span>(.flexible()),
        <span class="hljs-type">GridItem</span>(.flexible()),
    ]
    <span class="hljs-keyword">let</span> column3 = [
        <span class="hljs-type">GridItem</span>(.fixed(<span class="hljs-number">100</span>)),
        <span class="hljs-type">GridItem</span>(.fixed(<span class="hljs-number">100</span>)),
        <span class="hljs-type">GridItem</span>(.fixed(<span class="hljs-number">100</span>)),
        <span class="hljs-type">GridItem</span>(.fixed(<span class="hljs-number">100</span>)),
        <span class="hljs-type">GridItem</span>(.fixed(<span class="hljs-number">100</span>)),
    ]
    
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> selection = <span class="hljs-number">1</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> alignment:<span class="hljs-type">HorizontalAlignment</span> = .leading
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> alignmentSelection = <span class="hljs-number">0</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> spacing:<span class="hljs-type">CGFloat</span> = <span class="hljs-number">10</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Picker</span>(<span class="hljs-string">""</span>, selection: $selection){
                <span class="hljs-type">Text</span>(<span class="hljs-string">"adaptive"</span>).tag(<span class="hljs-number">0</span>)
                <span class="hljs-type">Text</span>(<span class="hljs-string">"flexible"</span>).tag(<span class="hljs-number">1</span>)
                <span class="hljs-type">Text</span>(<span class="hljs-string">"fixed"</span>).tag(<span class="hljs-number">2</span>)
            }
            .pickerStyle(<span class="hljs-type">SegmentedPickerStyle</span>())
            .labelsHidden()
            <span class="hljs-type">Picker</span>(<span class="hljs-string">""</span>,selection:$alignmentSelection){
                <span class="hljs-type">Text</span>(<span class="hljs-string">"leading"</span>).tag(<span class="hljs-number">0</span>)
                <span class="hljs-type">Text</span>(<span class="hljs-string">"center"</span>).tag(<span class="hljs-number">1</span>)
                <span class="hljs-type">Text</span>(<span class="hljs-string">"trailing"</span>).tag(<span class="hljs-number">2</span>)
            }
            .pickerStyle(<span class="hljs-type">SegmentedPickerStyle</span>())
            .labelsHidden()
            <span class="hljs-type">Slider</span>(value: $spacing, <span class="hljs-keyword">in</span>: -<span class="hljs-number">100</span>...<span class="hljs-number">100</span>){<span class="hljs-type">Text</span>(<span class="hljs-string">"spacing"</span>)}
            <span class="hljs-type">Text</span>(<span class="hljs-string">"\(spacing)"</span>)
                .onChange(of: alignmentSelection) { value <span class="hljs-keyword">in</span>
                    <span class="hljs-keyword">switch</span> value{
                    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                        alignment = .leading
                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                        alignment = .center
                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:
                        alignment = .trailing
                    <span class="hljs-keyword">default</span>:
                        <span class="hljs-keyword">break</span>
                    }
                }
            <span class="hljs-type">Button</span>(<span class="hljs-string">"shuffle"</span>){
                withAnimation(<span class="hljs-type">Animation</span>.easeInOut){
                    data.shuffle()
                }
            }
            <span class="hljs-type">ScrollView</span>{
                <span class="hljs-keyword">let</span> colums = [column1,column2,column3]
                <span class="hljs-type">LazyVGrid</span>(columns: colums[selection], alignment: alignment, spacing: spacing, pinnedViews: [.sectionHeaders]){
                    <span class="hljs-type">Section</span>(header: <span class="hljs-type">Text</span>(<span class="hljs-string">"header"</span>)){
                        <span class="hljs-type">ForEach</span>(data,id:\.id){ view <span class="hljs-keyword">in</span>
                            view
                        }
                    }
                }
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CellView</span>:<span class="hljs-title">View</span>,<span class="hljs-title">Identifiable</span></span>{
    <span class="hljs-keyword">let</span> id = <span class="hljs-type">UUID</span>()
    <span class="hljs-keyword">let</span> item:<span class="hljs-type">Int</span>
    <span class="hljs-keyword">let</span> width:<span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> height:<span class="hljs-type">CGFloat</span>
    <span class="hljs-keyword">let</span> colors:[<span class="hljs-type">Color</span>] = [.red,.blue,.yellow,.purple,.pink,.green]
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Rectangle</span>()
            .fill(colors.randomElement() ?? <span class="hljs-type">Color</span>.gray)
            .frame(width: width, height: height, alignment: .center)
            .overlay(<span class="hljs-type">Text</span>(<span class="hljs-string">"\(item)"</span>).font(.caption2))
    }
}
</code></pre><blockquote><p>**由于是Lazy显式，所以如果没有将全部cell滚动显示出来便进行shuffle操作，没有创建的cell将不会以动画的方式进行移动。</p></blockquote><video src="http://cdn.fatbobman.com/howto-swiftui-gridvideo.mov" controls = "controls" >你的浏览器不支持本视频</video><p>目前LazyGrid没有自动避碰的能力，也无法实现Waterfall Grid的效果。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/howto-swiftui-label</guid><title>HowTo —— SwiftUI2.0如何使用Label</title><description>SwiftUI2.0中新增了Label控件，方便我们添加由图片和文字组成的标签.</description><link>http://www.fatbobman.com/posts/howto-swiftui-label</link><pubDate>Thu, 9 Jul 2020 13:05:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0中新增了Label控件，方便我们添加由图片和文字组成的标签</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-type">Label</span>(<span class="hljs-string">"Hello World"</span>,systemImage:<span class="hljs-string">"person.badge.plus"</span>)
</code></pre><img src="http://cdn.fatbobman.com/howto-swiftui-label1.png" alt="image-20200709174029886"/><h2>支持自定义标签风格</h2><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LabelTest</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>(<span class="hljs-type">LabelItem</span>.labels(),id:\.id){ label <span class="hljs-keyword">in</span>
            <span class="hljs-type">Label</span>(label.title,systemImage:label.image)
                .foregroundColor(.blue)
                .labelStyle(<span class="hljs-type">MyLabelStyle</span>(color:label.color))
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyLabelStyle</span>:<span class="hljs-title">LabelStyle</span></span>{
    <span class="hljs-keyword">let</span> color:<span class="hljs-type">Color</span>
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBody</span><span class="hljs-params">(configuration: <span class="hljs-keyword">Self</span>.Configuration)</span></span> -&gt; some <span class="hljs-type">View</span>{
       <span class="hljs-type">HStack</span>{
            configuration.icon <span class="hljs-comment">//View,不能精细控制</span>
                .font(.title)
                .foregroundColor(color) <span class="hljs-comment">//颜色是叠加上去的，并不能准确显示</span>
            configuration.title  <span class="hljs-comment">//View,不能精细控制</span>
                .foregroundColor(.blue)
            <span class="hljs-type">Spacer</span>()
        }.padding(.all, <span class="hljs-number">10</span>)
        .background(
            <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)
                .fill(<span class="hljs-type">Color</span>.yellow)
        )
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LabelItem</span>:<span class="hljs-title">Identifiable</span></span>{
    <span class="hljs-keyword">let</span> id = <span class="hljs-type">UUID</span>()
    <span class="hljs-keyword">let</span> title:<span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> image:<span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> color:<span class="hljs-type">Color</span>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">labels</span><span class="hljs-params">()</span></span> -&gt; [<span class="hljs-type">LabelItem</span>] {
        <span class="hljs-keyword">return</span> [
       <span class="hljs-type">LabelItem</span>(title: <span class="hljs-string">"Label1"</span>, image: <span class="hljs-string">"pencil.tip.crop.circle.badge.plus"</span>, color: .red),
       <span class="hljs-type">LabelItem</span>(title: <span class="hljs-string">"df"</span>, image: <span class="hljs-string">"person.crop.circle.fill.badge.plus"</span>, color: .blue),
        ]
    }
}
</code></pre><img src="http://cdn.fatbobman.com/howto-swiftui-label2.png" alt="image-20200709175339008"/><h2>使用自己的Label控件，更多控制力</h2><p>Label能够提高开发效率，不过并不能精细控制，下面代码使用自定义MyLabel，可以支持SF2.0提供的彩色符号。</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LabelTest</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> multiColor = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
        <span class="hljs-type">Toggle</span>(<span class="hljs-string">"彩色符号"</span>, isOn: $multiColor).padding(.horizontal, <span class="hljs-number">20</span>)
        <span class="hljs-type">List</span>(<span class="hljs-type">LabelItem</span>.labels(),id:\.id){ label <span class="hljs-keyword">in</span>         
              <span class="hljs-type">MyLabel</span>(title:label.title,
                      systemImage:label.image,
                      color:label.color,
                      multiColor:multiColor)
        }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LabelItem</span>:<span class="hljs-title">Identifiable</span></span>{
    <span class="hljs-keyword">let</span> id = <span class="hljs-type">UUID</span>()
    <span class="hljs-keyword">let</span> title:<span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> image:<span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> color:<span class="hljs-type">Color</span>
    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">labels</span><span class="hljs-params">()</span></span> -&gt; [<span class="hljs-type">LabelItem</span>] {
        <span class="hljs-keyword">return</span> [
       <span class="hljs-type">LabelItem</span>(title: <span class="hljs-string">"Label1"</span>, image: <span class="hljs-string">"pencil.tip.crop.circle.badge.plus"</span>, color: .red),
       <span class="hljs-type">LabelItem</span>(title: <span class="hljs-string">"df"</span>, image: <span class="hljs-string">"person.crop.circle.fill.badge.plus"</span>, color: .blue),
        ]
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyLabel</span>:<span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">let</span> title:<span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> systemImage:<span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> color:<span class="hljs-type">Color</span>
    <span class="hljs-keyword">let</span> multiColor:<span class="hljs-type">Bool</span>
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">HStack</span>{
            <span class="hljs-type">Image</span>(systemName: systemImage)
                .renderingMode(multiColor ? .original : .template)
                .foregroundColor(multiColor ? .clear : color)
            <span class="hljs-type">Text</span>(title)
                .bold()
                .foregroundColor(.blue)
            <span class="hljs-type">Spacer</span>()
        }
        .padding(.all, <span class="hljs-number">10</span>)
        .background(
            <span class="hljs-type">RoundedRectangle</span>(cornerRadius: <span class="hljs-number">10</span>)
                .fill(<span class="hljs-type">Color</span>.yellow)
        )
    }
}
</code></pre><img src="http://cdn.fatbobman.com/howto-swiftui-label3.png" alt="image-20200709180353538"/>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/howto-swiftui-lazyStack</guid><title>HowTo —— SwiftU2.0 LazyVStack,LazyHStack</title><description>SwiftUI2.0提供了LazyVStack和LazyHStack，其作用是只有当View在可见区域内才进行渲染，这样可以大大大提高app执行效率</description><link>http://www.fatbobman.com/posts/howto-swiftui-lazyStack</link><pubDate>Thu, 9 Jul 2020 13:05:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>SwiftUI2.0提供了LazyVStack和LazyHStack，其作用是只有当View在可见区域内才进行渲染，这样可以大大大提高app执行效率。由于VStack或HStack导致的效率问题，在<a href="https://zhuanlan.zhihu.com/p/111151515">SwiftUI List (3) —— List、Form、VStack</a>文章中有简单的比较。</p></blockquote><h2>基本用法</h2><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LazyStack</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ScrollView</span>{
            <span class="hljs-type">LazyVStack</span>{ <span class="hljs-comment">//换成VStack作比较新数据创建的时机</span>
                <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>...<span class="hljs-number">1000</span>,id:\.<span class="hljs-keyword">self</span>){ id <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Text</span>(<span class="hljs-type">LazyItem</span>(id:id).title)
                }
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LazyItem</span></span>{
    <span class="hljs-keyword">let</span> id:<span class="hljs-type">Int</span>
    <span class="hljs-keyword">let</span> title:<span class="hljs-type">String</span>
    <span class="hljs-keyword">init</span>(id:<span class="hljs-type">Int</span>){
        <span class="hljs-keyword">self</span>.id = id
        <span class="hljs-keyword">self</span>.title = <span class="hljs-string">"id:\(id)"</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"init new object:\(id)"</span>) 
    }
}
</code></pre><h2>使用Lazy特性创建不间断的列表显示</h2><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LazyStack</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> list = (<span class="hljs-number">0</span>...<span class="hljs-number">40</span>).<span class="hljs-built_in">map</span>{<span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-type">Item</span>(number:<span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: <span class="hljs-number">1000</span>...<span class="hljs-number">5000</span>))}
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> loading = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
        <span class="hljs-type">Text</span>(<span class="hljs-string">"count:\(list.count)"</span>)
        <span class="hljs-comment">//数据数量，在LazyVStack下数据在每次刷新后才会增加，在VStack下，数据会一直增加。</span>
        <span class="hljs-type">ScrollView</span>{
            <span class="hljs-type">LazyVStack</span>{ <span class="hljs-comment">//换成VStack作比较</span>
                <span class="hljs-type">ForEach</span>(list,id:\.id){ item <span class="hljs-keyword">in</span>
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"id:\(item.number)"</span>)
                        .onAppear {
                            moreItem(id: item.id)
                        }
                }
            }
            <span class="hljs-keyword">if</span> loading {
                <span class="hljs-type">ProgressView</span>()
            }
        }
        }
    }
    
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">moreItem</span><span class="hljs-params">(id:UUID)</span></span>{
       <span class="hljs-comment">//如果是最后一个数据则获取新数据</span>
        <span class="hljs-keyword">if</span> id == list.last!.id &amp;&amp; loading != <span class="hljs-literal">true</span> {
            loading = <span class="hljs-literal">true</span>
            <span class="hljs-comment">//增加延时，模拟异步数据获取效果</span>
            <span class="hljs-type">DispatchQueue</span>.main.asyncAfter(deadline: .now() + <span class="hljs-number">1</span>){
                <span class="hljs-comment">//数据模拟，也可获取网络数据</span>
                list.append(contentsOf: (<span class="hljs-number">0</span>...<span class="hljs-number">30</span>)
                            .<span class="hljs-built_in">map</span>{<span class="hljs-number">_</span> <span class="hljs-keyword">in</span> <span class="hljs-type">Item</span>(number:<span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: <span class="hljs-number">1000</span>...<span class="hljs-number">5000</span>))})
                loading = <span class="hljs-literal">false</span>
            }
        }
        
    }
}

 <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Item</span>:<span class="hljs-title">Identifiable</span></span>{
    <span class="hljs-keyword">let</span> id = <span class="hljs-type">UUID</span>()
    <span class="hljs-keyword">let</span> number:<span class="hljs-type">Int</span>
}
</code></pre><p>LazyHStack的用法同LazyVStack一样</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/howto-swiftui-map</guid><title>HowTo—— Swift2.0在视图中显示地图</title><description>Swift2.0中，苹果添加了Map，让开发者可以非常容易的在View中添加需要的地图元素。本文简单介绍了其用法</description><link>http://www.fatbobman.com/posts/howto-swiftui-map</link><pubDate>Thu, 9 Jul 2020 13:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>Swift2.0中，苹果添加了Map，让开发者可以非常容易的在View中添加需要的地图元素。</p></blockquote><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI
<span class="hljs-keyword">import</span> MapKit

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MapView</span>: <span class="hljs-title">View</span></span>{
    <span class="hljs-comment">//设置初始显示区域</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> region:<span class="hljs-type">MKCoordinateRegion</span> = <span class="hljs-type">MKCoordinateRegion</span>(
        center: <span class="hljs-type">CLLocationCoordinate2D</span>(latitude: <span class="hljs-number">38.92083</span>, longitude: <span class="hljs-number">121.63917</span>),
        span: <span class="hljs-type">MKCoordinateSpan</span>(latitudeDelta: <span class="hljs-number">0.5</span>, longitudeDelta: <span class="hljs-number">0.5</span>)
    )
    
    <span class="hljs-comment">//设置是否持续跟踪用户当前位置</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> trackmode = <span class="hljs-type">MapUserTrackingMode</span>.follow
    
    <span class="hljs-comment">//设置标记点信息</span>
    <span class="hljs-keyword">let</span> dots:[<span class="hljs-type">MapDot</span>] = [
        <span class="hljs-type">MapDot</span>(title:<span class="hljs-string">"point1"</span>,
               coordinate:<span class="hljs-type">CLLocationCoordinate2D</span>(latitude: <span class="hljs-number">38.92083</span>, longitude: <span class="hljs-number">121.63917</span>),
               color:.red),
        <span class="hljs-type">MapDot</span>(title:<span class="hljs-string">"point2"</span>,
               coordinate:<span class="hljs-type">CLLocationCoordinate2D</span>(latitude: <span class="hljs-number">38.92183</span>, longitude: <span class="hljs-number">121.62717</span>),
               color:.blue)
    ]
    
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> store = <span class="hljs-type">Store</span>()
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">ZStack</span>(alignment:.bottom){
            <span class="hljs-type">Map</span>(coordinateRegion: $region,
                interactionModes: .all, <span class="hljs-comment">//.pan .zoom .all</span>
                showsUserLocation: <span class="hljs-literal">true</span>, <span class="hljs-comment">//是否显示用户当前位置</span>
                userTrackingMode:$trackmode, <span class="hljs-comment">//是否更新用户位置</span>
                annotationItems:dots <span class="hljs-comment">//标记点数据</span>
            ){item <span class="hljs-keyword">in</span>
                <span class="hljs-comment">//标记点显示,也可以直接使用内置的MapPin,不过MapPin无法响应用户输入</span>
                <span class="hljs-type">MapAnnotation</span>(coordinate: item.coordinate  ){
                    <span class="hljs-comment">//不知道是否是bug,目前iOS下无法显示Text,maxOS可以显示</span>
                    <span class="hljs-type">Label</span>(item.title, systemImage: <span class="hljs-string">"star.fill"</span>)
                        .font(.body)
                        .foregroundColor(item.color)
                        .onTapGesture {
                            <span class="hljs-built_in">print</span>(item.title)
                        }
                }
            }
        }
        .edgesIgnoringSafeArea(.all)
    }
}

<span class="hljs-comment">//标记点数据,要求符合Identifiable</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MapDot</span>:<span class="hljs-title">Identifiable</span></span>{
    <span class="hljs-keyword">let</span> id = <span class="hljs-type">UUID</span>()
    <span class="hljs-keyword">let</span> title:<span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> coordinate:<span class="hljs-type">CLLocationCoordinate2D</span>
    <span class="hljs-keyword">let</span> color:<span class="hljs-type">Color</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>:<span class="hljs-title">ObservableObject</span> </span>{
    <span class="hljs-keyword">let</span> manager = <span class="hljs-type">CLLocationManager</span>()
    <span class="hljs-keyword">init</span>() {
        <span class="hljs-comment">//请求位置访问权限.需要在plist中设置 Privacy - Location When In Use Usage Description</span>
        <span class="hljs-comment">//如果不需要显示当前用户位置,则无需申请权限</span>
        #<span class="hljs-keyword">if</span> os(iOS)
            manager.requestWhenInUseAuthorization()
        #endif
    }
}
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swiftui2-new-feature-2</guid><title>SwiftUI2.0 —— App、Scene、新的代码结构（二）</title><description>在上篇文章中我们简单了解了App、Scene，以及几个内置Scene的应用。在本文中，我们着重探讨在SwiftUI2.0新的代码结构下如果更高效的组织Data Flow。</description><link>http://www.fatbobman.com/posts/swiftui2-new-feature-2</link><pubDate>Wed, 8 Jul 2020 14:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>在<a href="http://www.fatbobman.com/posts/swiftui2-new-feature-1/">上篇文章</a>中我们简单了解了App、Scene，以及几个内置Scene的应用。在本文中，我们着重探讨在SwiftUI2.0新的代码结构下如果更高效的组织Data Flow。</p></blockquote><h2>新特性</h2><h3>@AppStorage</h3><p>AppStorage是苹果官方提供的用于操作UserDefault的属性包装器。这个功能在Swift提供了propertyWrapper特性后，已经有众多的开发者编写了类似的代码。功能上没有任何特别之处，不过名称对应了新的App协议，让人更容易了解其可适用的周期。</p><ul><li>数据可持久化，app退出后数据仍保留</li><li>仅包装了UserDefault，数据可以UserDefault正常读取</li><li>可保存的数据类型同UserDefault，不适合保存复杂类型数据</li><li>在app的任意View层级都可适用，不过在app层使用并不起作用（不报错）</li></ul><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AppStorageTest</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-comment">//不报错，不过不起作用</span>
    <span class="hljs-comment">//@AppStorage("count") var count = 0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">RootView</span>()
            <span class="hljs-type">CountView</span>()
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RootView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">AppStorage</span>(<span class="hljs-string">"count"</span>) <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>{
            <span class="hljs-type">Button</span>(<span class="hljs-string">"+1"</span>){
                <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CountView</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">AppStorage</span>(<span class="hljs-string">"count"</span>) <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">Text</span>(<span class="hljs-string">"Count:\(count)"</span>)
    }
}
</code></pre><h3>@SceneStorage</h3><p>使用方法同@AppStorage十分类似，不过其作用域仅限于当前Scene。</p><ul><li>数据作用域仅限于Scene中</li><li>生命周期同Scene一致，当前在PadOS下，如果强制退出一个两分屏显示的app,系统在下次打开app时有时会保留上次的Scene信息。不过，如果如果单独退出一个Scene，数据则失效</li><li>支持的类型基本等同于@AppStorage，适合保存轻量数据</li><li>比较适合保存基于Scene的特质信息，比如TabView的选择，独立布局等数据</li></ul><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewAllApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span>{
            <span class="hljs-type">ContentView1</span>()
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">SceneStorage</span>(<span class="hljs-string">"tabSeleted"</span>) <span class="hljs-keyword">var</span> selection = <span class="hljs-number">2</span>
    <span class="hljs-keyword">var</span> body:some <span class="hljs-type">View</span>{
        <span class="hljs-type">TabView</span>(selection:$selection){
            <span class="hljs-type">Text</span>(<span class="hljs-string">"1"</span>).tabItem { <span class="hljs-type">Text</span>(<span class="hljs-string">"1"</span>) }.tag(<span class="hljs-number">1</span>)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"2"</span>).tabItem { <span class="hljs-type">Text</span>(<span class="hljs-string">"2"</span>) }.tag(<span class="hljs-number">2</span>)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"3"</span>).tabItem { <span class="hljs-type">Text</span>(<span class="hljs-string">"3"</span>) }.tag(<span class="hljs-number">3</span>)
        }
    }
}
</code></pre><img src="http://cdn.fatbobman.com/swiftui2-new-feature-2-sceneStorage.png" alt="abc"/><p>&gt;<strong><em>上述代码在PadOS下运行正常，不过在macOS下程序会报错。估计应该是bug</em></strong></p><h2>Data Flow</h2><h3>手段</h3><p>苹果在SwiftUI2.0中添加了@AppStorage @SceneStorage @StateObject 等新的属性包装器，我根据自己的理解对目前SwiftUI提供的部分属性包装器做了如下总结：</p><img src="http://cdn.fatbobman.com/swiftui2-new-feature-2-propertyWrapperSheet.png" alt="propertyWrapperSheet"/><p>经过此次升级后，SwiftUI已经大大的完善了各个层级数据的生命周期管理，对不同的类型、不同的场合、不同的用途都提供了解决方案，为编写符合SwiftUI的Data Flow提供了便利，我们可以根据自己的需要选择适合的Source of truth手段。</p><p>想了解其中的更多细节，可以参看我的其他文章：</p><p><a href="http://www.fatbobman.com/posts/swiftUI-state/">@State 研究</a></p><p><a href="http://www.fatbobman.com/posts/stateobject/">@StateObject研究</a></p><p><a href="http://www.fatbobman.com/posts/observableObject-study/">ObservableObject研究——想说爱你不容易</a></p><h3>变化</h3><p>在SwiftUI1.0中，我们通常会在AppDelegate中创建需要生命周期与app一致的数据（比如CoreData的Container），在SceneDelegate中创建Store之类的数据源，并通过.environmentObject注入。不过随着SwiftUI2.0在程序入口方面的变化，以及采取的全新Delegate响应方式，我们可以通过更简洁、清晰的代码完成上述工作。</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewAllApp</span>: <span class="hljs-title">App</span> </span>{
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> store = <span class="hljs-type">Store</span>()
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span>{
            <span class="hljs-type">ContentView</span>()
                .environmentObject(store)
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>:<span class="hljs-title">ObservableObject</span></span>{
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
}
</code></pre><p>上述例子中，将</p><pre data-language="swift"><code>@<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> store = <span class="hljs-type">Store</span>()
</code></pre><p>换成</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> store = <span class="hljs-type">Store</span>()
</code></pre><p>目前来说是一样的。</p><p><em>虽然目前SceneBuilder、CommandBuilder对Dynamic update和逻辑判断尚不支持，我相信应该在不久的将来，或许我们就可以使用类似下面的代码来完成很多有趣的工作了,**当前代码无法执行</em>**</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewAllApp</span>: <span class="hljs-title">App</span> </span>{
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> store = <span class="hljs-type">Store</span>()
    @<span class="hljs-type">SceneBuilder</span> <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-comment">//@SceneBuilder目前不支持判断，不过将来应该会加上</span>
        <span class="hljs-keyword">if</span> store.scene == <span class="hljs-number">0</span> {
        <span class="hljs-type">WindowGroup</span>{
            <span class="hljs-type">ContentView1</span>()
                .environmentObject(store)
        }
        .onChange(of: store.number){ value <span class="hljs-keyword">in</span>
            <span class="hljs-built_in">print</span>(value)
        }
        .commands{
            <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"DynamicButton"</span>){
                <span class="hljs-comment">//目前无法动态切换内容，怀疑是bug，已反馈</span>
                <span class="hljs-keyword">switch</span> store.number{
                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:
                    <span class="hljs-type">Button</span>(<span class="hljs-string">"0"</span>){}
                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:
                    <span class="hljs-type">Button</span>(<span class="hljs-string">"1"</span>){}
                <span class="hljs-keyword">default</span>:
                    <span class="hljs-type">Button</span>(<span class="hljs-string">"other"</span>){}
                }
            }
        }
        }
        <span class="hljs-keyword">else</span> {
         <span class="hljs-type">DocumentGroup</span>(newDocment:<span class="hljs-type">TextFile</span>()){ file <span class="hljs-keyword">in</span>
              <span class="hljs-type">TextEditorView</span>(document:file.$document)
         }
        }
        
        <span class="hljs-type">Settings</span>{
            <span class="hljs-type">VStack</span>{
               <span class="hljs-comment">//可正常变换</span>
                <span class="hljs-type">Text</span>(<span class="hljs-string">"\(store.number)"</span>)
                    .padding(.all, <span class="hljs-number">50</span>)
            }
        }

    }
}


<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView1</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">EnvironmentObject</span> <span class="hljs-keyword">var</span> store:<span class="hljs-type">Store</span>
    <span class="hljs-keyword">var</span> body:some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
        <span class="hljs-type">Picker</span>(<span class="hljs-string">"select"</span>,selection:$store.number){
            <span class="hljs-type">Text</span>(<span class="hljs-string">"0"</span>).tag(<span class="hljs-number">0</span>)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"1"</span>).tag(<span class="hljs-number">1</span>)
            <span class="hljs-type">Text</span>(<span class="hljs-string">"2"</span>).tag(<span class="hljs-number">2</span>)
        }
        .pickerStyle(<span class="hljs-type">SegmentedPickerStyle</span>())
        .padding()
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>:<span class="hljs-title">ObservableObject</span></span>{
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> number = <span class="hljs-number">0</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> scene = <span class="hljs-number">0</span>
}
</code></pre><h3>跨平台代码</h3><p>在<a href="https://zhuanlan.zhihu.com/p/152624613">上篇文章</a>我们介绍了新的@UIApplicationDelegateAdaptor的使用方法，我们也可以直接创建一个支持Delegate的store。</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> SwiftUI

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>:<span class="hljs-title">NSObject</span>,<span class="hljs-title">ObservableObject</span></span>{
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
}

#<span class="hljs-keyword">if</span> os(iOS)
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Store</span>:<span class="hljs-title">UIApplicationDelegate</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">application</span><span class="hljs-params">(<span class="hljs-number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : <span class="hljs-keyword">Any</span>]? = <span class="hljs-literal">nil</span>)</span></span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"launch"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
}
#endif

@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AllInOneApp</span>: <span class="hljs-title">App</span> </span>{
    #<span class="hljs-keyword">if</span> os(iOS)
    @<span class="hljs-type">UIApplicationDelegateAdaptor</span>(<span class="hljs-type">Store</span>.<span class="hljs-keyword">self</span>) <span class="hljs-keyword">var</span> store
    #<span class="hljs-keyword">else</span>
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> store = <span class="hljs-type">Store</span>()
    #endif
    
    @<span class="hljs-type">Environment</span>(\.scenePhase) <span class="hljs-keyword">var</span> phase

    @<span class="hljs-type">SceneBuilder</span> <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
            <span class="hljs-type">WindowGroup</span> {
                <span class="hljs-type">RootView</span>()
                    .environmentObject(store)
            }
            .onChange(of: phase){phase <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">switch</span> phase{
                <span class="hljs-keyword">case</span> .active:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"active"</span>)
                <span class="hljs-keyword">case</span> .inactive:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"inactive"</span>)
                <span class="hljs-keyword">case</span> .background:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"background"</span>)
                @unknown <span class="hljs-keyword">default</span>:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"for future"</span>)
                }

            }
      
        #<span class="hljs-keyword">if</span> os(macOS)
        <span class="hljs-type">Settings</span>{
            <span class="hljs-type">Text</span>(<span class="hljs-string">"偏好设置"</span>).padding(.all, <span class="hljs-number">50</span>)
        }
        #endif
    }
}
</code></pre><h2>总结</h2><p>在<a href="http://www.fatbobman.com/posts/observableObject-study/">ObservableObject研究——想说爱你不容易</a>中，我们探讨过SwiftUI更倾向于我们不要创建一个沉重的Singel source of truth,而是将每个功能模块作为独立的状态机（一起组合成一个大的状态app），使用能够对生命周期和作用域更精确可控的手段创建区域性的source of truth。</p><p>从SwiftUI第一个版本升级的内容来看，目前SwiftUI仍是这样的思路。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swiftui2-new-feature-1</guid><title>SwiftUI2.0 —— App、Scene、新的代码结构（一）</title><description>本文简单介绍了SwiftUI2.0中全新提供的App协议、Scene协议，浅谈了在全新的代码结构下如何组织Data Flow，并提供了SwiftUI2.0中预置的Scene的一些使用示例。当前运行环境为 Xcode Version 12.0 beta (12A6159), macOS Big Sur 11.0 Beta版(20A4299v)。</description><link>http://www.fatbobman.com/posts/swiftui2-new-feature-1</link><pubDate>Wed, 8 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文简单介绍了SwiftUI2.0中全新提供的App协议、Scene协议，浅谈了在全新的代码结构下如何组织Data Flow，并提供了SwiftUI2.0中预置的Scene的一些使用示例。 当前运行环境为 Xcode Version 12.0 beta (12A6159), macOS Big Sur 11.0 Beta版(20A4299v)。</p></blockquote><p>WWDC20中，苹果为开发者带来了基于SwiftUI的全新项目模板。使用该模板，将使项目代码变得异常简洁、清晰。</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewAllApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">Text</span>(<span class="hljs-string">"Hello world"</span>)
        }
    }
}
</code></pre><p>上述代码可以在屏幕上完成Hello world的显示，且能够运行于iOS和macOS平台下。</p><h2>基本概念</h2><h3>App</h3><p>SwiftUI2.0提供的全新协议。通过声明一个符合App协议的结构来创建一个程序，并通过计算属性body来实现程序的内容。</p><ul><li>通过@main(swift5.3 新特性)设定程序的入口，每个项目只能有一个进入点</li><li>管理整个app的生命周期</li></ul><ul><li>在这个作用域下声明的常量、变量其生命周期与整个app是完全一致的。</li></ul><h3>Scene</h3><p>场景是视图（View）层次结构的容器。通过在App实例的body中组合一个或多个符合Scene协议的实例来呈现具体程序。</p><ul><li>生命周期由系统管理</li><li>系统会根据运行平台的不同而调整场景的展示行为（比如相同的代码在iOS和macOS下的呈现不同，或者某些场景仅能运行于特定的平台）</li><li>SwiftUI2.0提供了几个预置的场景，用户也可以自己编写符合Scene协议的场景。上述代码中便是使用的一个预置场景WindowGroup</li></ul><p>通过App和Scene的加入，绝不是仅仅减少代码量这么简单。通过这个明确的层级设定，我们可以更好的掌握在不同作用域下各个部分的生命周期、更精准数据传递、以及更便利的多平台代码共享。本文后面会用具体代码来逐个阐述。</p><p><em>App和Scene都是通过各自的functionBuilder来解析的，也就是说，新的模板从程序的入口开始便是使用DSL来描述的。</em></p><h2>程序系统事件响应</h2><p>由于去除了AppDelegate.swift和SceneDelegate.swift，SwiftUI2.0提供了新的方法来让程序响应系统事件。</p><h3>针对AppDelegate.swift</h3><p>在iOS系统下，通过使用@UIApplicationDelegateAdaptor可以方便的实现之前AppDelegate.swfit中提供的功能：</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewAllApp</span>: <span class="hljs-title">App</span> </span>{
   @<span class="hljs-type">UIApplicationDelegateAdaptor</span>(<span class="hljs-type">AppDelegate</span>.<span class="hljs-keyword">self</span>) <span class="hljs-keyword">var</span> appDelegate
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">Text</span>(<span class="hljs-string">"Hello world"</span>)
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span>:<span class="hljs-title">NSObject</span>,<span class="hljs-title">UIApplicationDelegate</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">application</span><span class="hljs-params">(<span class="hljs-number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : <span class="hljs-keyword">Any</span>]? = <span class="hljs-literal">nil</span>)</span></span> -&gt; <span class="hljs-type">Bool</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"launch"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
}
</code></pre><p>由于目前还是测试版，虽然很多的事件已经定义，但现在并没有响应。估计很快会增加修改过来</p><h3>针对SceneDelegate.swift</h3><p>通过新增添的EnvironmentKey <strong>scenePhase</strong> 和新的<strong>.onChange</strong> 方法，SwiftUI提供了一个更加有趣的场景事件解决方案：</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewAllApp</span>: <span class="hljs-title">App</span> </span>{
    @<span class="hljs-type">Environment</span>(\.scenePhase) <span class="hljs-keyword">var</span> phase
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
           <span class="hljs-type">ContentView</span>()
        }
        .onChange(of: phase){phase <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">switch</span> phase{
                <span class="hljs-keyword">case</span> .active:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"active"</span>)
                <span class="hljs-keyword">case</span> .inactive:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"inactive"</span>)
                <span class="hljs-keyword">case</span> .background:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"background"</span>)
                @unknown <span class="hljs-keyword">default</span>:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"for future"</span>)
                }

          }
    }
}
</code></pre><p>同样是由于测试版的原因，该响应目前并没有完成。不过这段代码目前来看是iOS和macOS都通用的</p><h3>更新</h3><p>目前发现如果在View中，可以获取scenePhase的状态更新。下来代码目前可以正常执行</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>:<span class="hljs-title">View</span></span>{ 
  @<span class="hljs-type">Environment</span>(\.scenePhase) <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> scenePhase
 <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
  <span class="hljs-type">WindowGroup</span> {
   <span class="hljs-type">ContentView</span>()
  }
  .onChange(of: phase){phase <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">switch</span> phase{
                <span class="hljs-keyword">case</span> .active:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"active"</span>)
                <span class="hljs-keyword">case</span> .inactive:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"inactive"</span>)
                <span class="hljs-keyword">case</span> .background:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"background"</span>)
                @unknown <span class="hljs-keyword">default</span>:
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"for future"</span>)
                }
         }
   }
}
</code></pre><h2>预置场景</h2><ul><li><strong>WKNotificationScene</strong> 仅适用于watchOS7.0，用于响应指定类别的远程或本地通知。目前还没有研究。</li></ul><ul><li><strong>WindowGroup</strong></li></ul><p>最常用的场景，可以呈现一组结构相同的窗口。使用该场景，我们无需在代码上做修改，只需要在项目中设定是否支持多窗口，系统将会按照运行平台的特性自动管理。</p><p>在iOS中，只能呈现一个运行窗口。</p><p>在PadOS中（如打开多窗口支持），最多可以打开两个运行窗口，可以分屏显示，也可以全屏独立显示。</p><p>在macOS中，可以打开多个窗口，并通过程序菜单中的窗口菜单来进行多窗口管理。</p><p>最开始的代码在三个平台下的状态：</p><img src="http://cdn.fatbobman.com/swiftui2-new-feature-1-windowGroup.png" alt="windowGroup"/><p>如果在一个WindowGroup里加入多个View,呈现状态有点类似VStack。</p><p>在一个Scene中加入多个WindowGroup，只有最前面的可以被显示。</p><ul><li><strong>DocumentGroup</strong></li></ul><p>创建一个可处理指定文件类型的窗口。在iOS和PadOS下都首先会呈现文件管理器，点击文件，进入对应的View来处理。macOS下，通过菜单中的文件操作来选择或创建文件。</p><p>通过创建一个符合FileDocument的结构来定义支持哪种格式，以及打开和保存的工作。</p><pre data-language="swift"><code>  <span class="hljs-comment">//纯文本格式文件。write的方法用于描述如何写入文件，如果不需写入可为空。</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TextFile</span>: <span class="hljs-title">FileDocument</span> </span>{
      <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> readableContentTypes = [<span class="hljs-type">UTType</span>.plainText]
      <span class="hljs-keyword">var</span> text = <span class="hljs-string">""</span>
      <span class="hljs-keyword">init</span>(initialText: <span class="hljs-type">String</span> = <span class="hljs-string">""</span>) {
          text = initialText
      }
      <span class="hljs-keyword">init</span>(fileWrapper: <span class="hljs-type">FileWrapper</span>, contentType: <span class="hljs-type">UTType</span>) <span class="hljs-keyword">throws</span> {
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data = fileWrapper.regularFileContents {
              text = <span class="hljs-type">String</span>(decoding: data, <span class="hljs-keyword">as</span>: <span class="hljs-type">UTF8</span>.<span class="hljs-keyword">self</span>)
          }
      }
      <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(to fileWrapper: <span class="hljs-keyword">inout</span> FileWrapper, contentType: UTType)</span></span> <span class="hljs-keyword">throws</span> {
          <span class="hljs-keyword">let</span> data = <span class="hljs-type">Data</span>(text.utf8)
          <span class="hljs-keyword">let</span> file = <span class="hljs-type">FileWrapper</span>(regularFileWithContents: data)
          fileWrapper = file
      }
  }
  <span class="hljs-comment">//图片文件，由于需要转换成UIImage，该代码只支持iOS或PadOS</span>
  #<span class="hljs-keyword">if</span> os(iOS)
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ImageFile</span>: <span class="hljs-title">FileDocument</span> </span>{
      <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> readableContentTypes = [<span class="hljs-type">UTType</span>.image]
      <span class="hljs-keyword">var</span> image = <span class="hljs-type">UIImage</span>()
      <span class="hljs-keyword">init</span>(initialImage: <span class="hljs-type">UIImage</span> = <span class="hljs-type">UIImage</span>()) {
          image = initialImage
      }
    
      <span class="hljs-keyword">init</span>(fileWrapper: <span class="hljs-type">FileWrapper</span>, contentType: <span class="hljs-type">UTType</span>) <span class="hljs-keyword">throws</span> {
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> data = fileWrapper.regularFileContents {
              image =   <span class="hljs-type">UIImage</span>(data: data) ?? <span class="hljs-type">UIImage</span>()
          }
      }
  
      <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(to fileWrapper: <span class="hljs-keyword">inout</span> FileWrapper, contentType: UTType)</span></span> <span class="hljs-keyword">throws</span> { }
  }
  #endif
</code></pre><p>调用</p><pre data-language="swift"><code>  <span class="hljs-keyword">import</span> SwiftUI
  #<span class="hljs-keyword">if</span> os(iOS)
  <span class="hljs-keyword">import</span> UIKit
  #endif
  <span class="hljs-keyword">import</span> UniformTypeIdentifiers
  
  @main
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewAllApp</span>: <span class="hljs-title">App</span> </span>{
     @<span class="hljs-type">SceneBuilder</span> <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
          <span class="hljs-comment">//可读写</span>
          <span class="hljs-type">DocumentGroup</span>(newDocument: <span class="hljs-type">TextFile</span>()) { file <span class="hljs-keyword">in</span>
                  <span class="hljs-type">TextEditorView</span>(document: file.$document)
          }
          
          #<span class="hljs-keyword">if</span> os(iOS)
          <span class="hljs-comment">//只读</span>
          <span class="hljs-type">DocumentGroup</span>(viewing: <span class="hljs-type">ImageFile</span>.<span class="hljs-keyword">self</span>) { file <span class="hljs-keyword">in</span>
                  <span class="hljs-type">ImageViewerView</span>(file: file.$document)
            }
          #endif
      }
  }
  
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TextEditorView</span>: <span class="hljs-title">View</span> </span>{
      @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> document: <span class="hljs-type">TextFile</span>
      @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
      <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
          <span class="hljs-type">VStack</span>{
          <span class="hljs-type">TextEditor</span>(text: $document.text)
              .padding()
          }
          .background(<span class="hljs-type">Color</span>.gray)
      }
  }
  
  #<span class="hljs-keyword">if</span> os(iOS)
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ImageViewerView</span>:<span class="hljs-title">View</span></span>{
      @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> document:<span class="hljs-type">ImageFile</span>
      <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
          <span class="hljs-type">Image</span>(uiImage: document.image)
              .resizable(resizingMode: .stretch)
              .aspectRatio(contentMode: .fit)
      }
  }
  #endif
</code></pre><img src="http://cdn.fatbobman.com/swiftui2-new-feature-1-documentGroup.png" alt="DocumentGroup"/><p>可以将多个DocumentGroup放入Scene中，程序将会一并支持每个DocumentGroup所定义的文件类型。上述代码使程序可以创建、编辑纯文本文件，并且可以浏览图片文件。</p><p>在macOS上，需要在macOS.entitlements中设置com.apple.security.files.user-selected.read-write为真才能完成写入。</p><p>当在Scene中加入多个场景时，需要使用@SceneBuilder或用Group将多个场景涵盖起来。</p><p>macOS下当同时加入WindowGroup和DocumentGroup时，两个功能都可以正常运行。iOS或PadOS下，只有顺序在最前面的被显示。</p><p>由于测试版的原因，目前仍有大量的功能无法实现或有问题。比如仍无法在iOS上通过fileDocument提供的filename来设置文件名，或者无法在创建新文件时选择格式等</p><ul><li><strong>Settings</strong></li></ul><p>只用于macOS,用于编写程序的偏好设置窗口。</p><pre data-language="swift"><code>  #<span class="hljs-keyword">if</span> os(macOS)
      <span class="hljs-type">Settings</span>{
        <span class="hljs-type">Text</span>(<span class="hljs-string">"偏好设置"</span>).padding(.all, <span class="hljs-number">50</span>)
      }
  #endif
</code></pre><img src="http://cdn.fatbobman.com/swiftui2-new-feature-1-settings.jpg" alt="Settings"/><h2>其他</h2><ul><li><strong>onChange</strong> 监视指定的值，在值改变时执行指定的action。在scenePhase的用法介绍中有使用的范例</li></ul><ul><li><strong>onCommands</strong> 在macOS下设置程序的菜单。具体的使用方法请查看<a href="https://zhuanlan.zhihu.com/p/152127847">SwiftUI2.0 —— Commands（macOS菜单）</a></li></ul><ul><li><strong>defaultAppStorage</strong> 如果不想使用系统缺省UserDefault.standard，可以自行设置存储位置，使用的几率不高。</li></ul><h2>小结</h2><p>至此，本文简单介绍了SwiftUI2.0新增的App和Scene，下篇文章我们将探讨在新的层次结构下如何组织我们代码的Data Flow。</p><p>当前的@AppBuilder和@SceneBuilder的功能都十分的基础，不包含任何的逻辑判断功能，因此目前我还没有办法实现根据条件来选择性的展示所需的Scene。相信苹果应该会在未来增加这样的能力</p><p><em>本文的代码为了能够在多平台使用，所以增加了不少编译判断，如果你只是在iOS,或macOS下开发SwiftUI，则可根据各自平台简化代码。另外Xcode12中的代码补全对于Target的设定很敏感，如果你发现无法对某些平台的特定语句进行补全，请查看是否将Scheme设置到对应的平台。</em></p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/focusedBinding</guid><title>@FocusedBinding 浅谈</title><description>在苹果WWDC20中视频中出现了下面的代码，介绍了一个新的属性包装器@FocusedBinding。由于仍处于测试阶段，当前的代码并不能被正确的执行。@FocusedBinding的资料苹果披露的也很少，网上也没有相关的信息。出于个人兴趣，我对它进行了简单的研究。尽管@FocusedBinding在目前Xcode Version 12.0 beta 2 (12A6163b)的版本上运行还有很多问题，但我基本上对其有了一定的了解。</description><link>http://www.fatbobman.com/posts/focusedBinding</link><pubDate>Sun, 5 Jul 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>在苹果WWDC20中视频中出现了下面的代码，介绍了一个新的属性包装器@FocusedBinding。由于仍处于测试阶段，当前的代码并不能被正确的执行。@FocusedBinding的资料苹果披露的也很少，网上也没有相关的信息。出于个人兴趣，我对它进行了简单的研究。尽管@FocusedBinding在目前Xcode Version 12.0 beta 2 (12A6163b)的版本上运行还有很多问题，但我基本上对其有了一定的了解。</p></blockquote><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BookCommands</span>: <span class="hljs-title">Commands</span> </span>{
 @<span class="hljs-type">FocusedBinding</span>(\.selectedBook) <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> selectedBook: <span class="hljs-type">Book?</span>
  <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Commands</span> {
    <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"Book"</span>) {
        <span class="hljs-type">Section</span> {
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Update Progress..."</span>, action: updateProgress)
                .keyboardShortcut(<span class="hljs-string">"u"</span>)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Mark Completed"</span>, action: markCompleted)
                .keyboardShortcut(<span class="hljs-string">"C"</span>)
        }
        .disabled(selectedBook == <span class="hljs-literal">nil</span>)
    }
  }

   <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">updateProgress</span><span class="hljs-params">()</span></span> {
       selectedBook?.updateProgress()
   }
   <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">markCompleted</span><span class="hljs-params">()</span></span> {
       selectedBook?.markCompleted()
   }
}
</code></pre><h2>用途</h2><p><strong>在任意视图（View）之间数据共享、修改、绑定操作。</strong></p><p>在SwiftUI1.0中，我们可以使用EnvironmentKey向子视图传递数据，使用PreferenceKey向父视图传递数据。如果我们想在不在同一视图树上的两个平行视图间进行数据传递的话，通常需要使用Single of truth或者通过NotificationCenter来进行。</p><p>在SwiftUI2.0中，苹果引入了@FocusedBinding和@FocusedValue来解决这个问题。通过定义FocusedValueKey，我们可以在任意的视图之间，无需通过Single of truth，便可以直接进行数据共享、修改、绑定。</p><p>在<a href="https://zhuanlan.zhihu.com/p/152127847">SwiftUI2.0 —— Commands（macOS菜单）</a>这篇文章中，我们通过了Single of truth的方式，在App这个层级，使Commnads可以同其他视图进行数据共享。通过WWDC提供的例子，我们可以看出，苹果希望能够提供一种其他的解决方案，完成上述的功能。同样，这种方案也使我们拥有了可以在任意视图（无论是否在同一颗树上，是否有联系）之间进行数据交换。</p><h2>使用方法</h2><p>其基本的使用方式和Environment很类似，都需要首先定义指定的Key</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FocusedMessageKey</span>:<span class="hljs-title">FocusedValueKey</span></span>{
    <span class="hljs-comment">//同EnvironmentKey不同，FocusedValueKey没有缺省值，且必须是一个可选值。为了下面的演示，在这里我们将数据类型设置为Binding&lt;String&gt;,可以设置为任意值类型数据</span>
    <span class="hljs-keyword">typealias</span> <span class="hljs-type">Value</span> = <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">String</span>&gt;
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">FocusedValues</span></span>{
    
    <span class="hljs-keyword">var</span> message:<span class="hljs-type">Binding</span>&lt;<span class="hljs-type">String</span>&gt;?{
        <span class="hljs-keyword">get</span>{<span class="hljs-keyword">self</span>[<span class="hljs-type">FocusedMessageKey</span>.<span class="hljs-keyword">self</span>]}
        <span class="hljs-keyword">set</span>{<span class="hljs-keyword">self</span>[<span class="hljs-type">FocusedMessageKey</span>.<span class="hljs-keyword">self</span>] = newValue}
    }
}
</code></pre><p>由于可以使用在任意视图，所以数据无需注入。和EnvironmentKey不同（只在当前注入的视图树之下有效），数据在全域有效。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ShowView</span>:<span class="hljs-title">View</span></span>{
    <span class="hljs-comment">//调用方式同@Environment几乎一致,使用@FocusedValue或@FocusedBinding需不同的引用方式</span>
    @<span class="hljs-type">FocusedValue</span>(\.message) <span class="hljs-keyword">var</span> focusedMessage
    <span class="hljs-comment">//@FocusedBinding(\.message) var focusedMessage1</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
        <span class="hljs-type">Text</span>(<span class="hljs-string">"focused:\(focusedMessage?.wrappedValue ?? "</span><span class="hljs-string">")"</span>)
        <span class="hljs-comment">//Text("focused:\(focusedMessage1 ?? "")")</span>
        }
    }
}
</code></pre><p>在另一视图对该FocusedValueKey数据进行修改。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InputView1</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> text = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
        <span class="hljs-type">TextField</span>(<span class="hljs-string">"input1:"</span>,text:$text)
            .textFieldStyle(<span class="hljs-type">RoundedBorderTextFieldStyle</span>())
            <span class="hljs-comment">//使message和text同步</span>
            .focusedValue(\.message, $text)
        }
    }
}
</code></pre><p>可以在多个视图对同一FocusedValueKey进行修改</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InputView2</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> text = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> body:some <span class="hljs-type">View</span>{
        <span class="hljs-type">TextField</span>(<span class="hljs-string">"input2:"</span>,text:$text)
            .textFieldStyle(<span class="hljs-type">RoundedBorderTextFieldStyle</span>())
            .focusedValue(\.message, $text)
    }
}
</code></pre><p>最后组装在一起</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RootView</span>: <span class="hljs-title">View</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-comment">//三个视图是平行关系，在之前使用Environment或者Preference都无法在这三个视图间进行数据传递、共享</span>
            <span class="hljs-type">InputView1</span>()
            <span class="hljs-type">InputView2</span>()
            <span class="hljs-type">ShowView</span>()
        }
        .padding(.all, <span class="hljs-number">20</span>)
        .frame(maxWidth:.infinity, maxHeight: .infinity)
    }
}
</code></pre><video src="http://cdn.fatbobman.com/focusebinding-video.mov" controls="controls">您的浏览器不支持播放该视频！</video><p>目前在iOS下无法获取FocusedValueKey数值，文档中标识是支持iOS的，应该在未来会解决</p><h2>如何用，怎么用？</h2><p>FoccusedBinding的引入，进一步完善了SwiftUI不同视图中数据操作的功能。不过个人建议还是不要滥用此功能。</p><p>由于我们可以在任意视图中修改key中的值，一旦滥用，很可能再度陷入代码难以管理的窘境。</p><p>对于一些功能很简单，无需使用MVVM逻辑的代码，或者Single of truth过于臃肿（<a href="http://www.fatbobman.com/posts/observableObject-study/">ObservableObject研究——想说爱你不容易</a>），可能导致app响应问题的代码，可以考虑使用上述的方案。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swiftUI2-commands</guid><title>SwiftUI2.0 —— Commands（macOS菜单）</title><description>本文介绍了SwiftUI 2.0中，如何为macOS平台添加菜单。苹果在SwiftUI2.0中增加了Multiplatform项目模板，使得同一套代码，仅需少量的适配便可以同时满足iOS以及macOS的需要。对于macOS上运行的app,拥有自定义的菜单是一个十分重要的平台特征。对于没有macOS开发经验的我来说，学习如何设计开发菜单变得十分有趣且必要。</description><link>http://www.fatbobman.com/posts/swiftUI2-commands</link><pubDate>Sat, 27 Jun 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文介绍了SwiftUI 2.0中，如何为macOS平台添加菜单。 当前运行环境为 Xcode Version 12.0 beta (12A6159), macOS Big Sur 11.0 Beta版(20A4299v)。</p></blockquote><p>苹果在SwiftUI2.0中增加了Multiplatform项目模板，使得同一套代码，仅需少量的适配便可以同时满足iOS以及macOS的需要。对于macOS上运行的app,拥有自定义的菜单是一个十分重要的平台特征。对于没有macOS开发经验的我来说，学习如何设计开发菜单变得十分有趣且必要。</p><h2>基础</h2><p>在SwiftUI下为app添加菜单十分方便，下面的代码便可以为app添加一个最基础的菜单。</p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CommandExampleApp</span>: <span class="hljs-title">App</span> </span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
           <span class="hljs-type">ContentView</span>()
        }
        .commands{
           <span class="hljs-type">Menu</span>()
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Menu</span>:<span class="hljs-title">Commands</span></span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Commands</span>{
        <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"My Menu"</span>){
            <span class="hljs-type">Button</span>(<span class="hljs-string">"menu1"</span>){
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"menu1"</span>)
            }
        }
    }
}
</code></pre><p>通过创建一个符合Commands协议的结构来描述你要在app中添加的自定义菜单项</p><img src="http://cdn.fatbobman.com/swiftui2-commands-test1.png" alt="test1"/><h2>几个概念</h2><ul><li>@CommandBuilder</li></ul><p>SwiftUI2.0中，苹果为我来带来了很多新的function builder。Menu中的body，其实就是一个@CommandsBuilder。我们可以通过使用内置的语句通过DSL的方式，方便的定义自己所需的菜单。DSL的好处是简单明了，不过功能也有所限定，目前@CommandsBuilder支持的方法比较少，并不支持逻辑判断。</p><pre data-language="swift"><code>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyCommand</span>:<span class="hljs-title">Commands</span></span>{
      <span class="hljs-comment">//如果需要多个菜单列，需在body前显式注明@CommandsBuilder，或者使用Group，这一方法，同样使用与其他functionBuilder的描述。</span>
      @<span class="hljs-type">CommandsBuilder</span> <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Commands</span>{
          <span class="hljs-comment">//每个CommandMenu都是一个菜单列</span>
          <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"Menu1"</span>){
              <span class="hljs-type">Button</span>(<span class="hljs-string">"Test1"</span>){
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"test2"</span>)
              }
                <span class="hljs-type">Button</span>(<span class="hljs-string">"Test2"</span>){
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"test2"</span>)
              }
          }
          
          <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"Menu2"</span>){
              <span class="hljs-type">Button</span>(action: test1{
                  <span class="hljs-type">Text</span>(<span class="hljs-string">"😃Button"</span>)
              }
          }
      }
      
      <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>{
          <span class="hljs-built_in">print</span>(<span class="hljs-string">"test command"</span>)
      }
  
  }
  
</code></pre><ul><li>CommandMenu</li></ul><p>CommandMenu是一个菜单列，在同一个CommandMenu中，你可以定义多个Button。CommandMenu中的Content是符合View协议的，也就是说，View中不少手段、控件都可以被用来描述菜单的具体呈现。我们可以像编写View一样来编写菜单（比如设置字体、颜色、循环、判断等等）。</p><pre data-language="swift"><code>  <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"Menu"</span>){
    <span class="hljs-type">Button</span>(<span class="hljs-string">"test1"</span>){}
    <span class="hljs-type">Divider</span>()
    <span class="hljs-type">Button</span>(action:{}){<span class="hljs-type">Text</span>(<span class="hljs-string">"test2"</span>).foregroundColor(.red)}
  }
</code></pre><ul><li>Button</li></ul><p>菜单中单个选项的实现方法。</p><pre data-language="swift"><code>    <span class="hljs-type">Button</span>(action: {}){
      <span class="hljs-type">HStack</span>{
          <span class="hljs-type">Text</span>(<span class="hljs-string">"🎱"</span>).foregroundColor(.blue)
          <span class="hljs-type">Divider</span>().padding(.leading,<span class="hljs-number">10</span>)
          <span class="hljs-type">Text</span>(<span class="hljs-string">"Button"</span>)
      }
      }
</code></pre><ul><li>MenuButton</li></ul><p>子菜单的实现方法。</p><pre data-language="swift"><code>  <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"Test"</span>){
             <span class="hljs-type">Button</span>(action:{test1()}){
                  <span class="hljs-type">Text</span>(<span class="hljs-string">"test1"</span>).foregroundColor(.black)
             }
              
              #<span class="hljs-keyword">if</span> os(macOS)
              <span class="hljs-type">MenuButton</span>(<span class="hljs-string">"Switch Selection"</span>){
                  <span class="hljs-type">Button</span>(<span class="hljs-string">"one"</span>){
                      store.changeState(.one)
                  }
                  <span class="hljs-type">Button</span>(<span class="hljs-string">"two"</span>){
                      store.changeState(.two)
                  }
                  <span class="hljs-type">Button</span>(<span class="hljs-string">"three"</span>){
                      store.changeState(.three)
                  }
              }
              #endif
          }
</code></pre><ul><li>.commands</li></ul><p>Scene的方法，为场景添加菜单。commands中允许添加多个符合Commands协议的菜单定义。所有定义的菜单都会一并显示。</p><pre data-language="swift"><code>          <span class="hljs-type">WindowGroup</span> {
              <span class="hljs-type">RootView</span>()
                  .environmentObject(store)
          }
          .commands{
              <span class="hljs-type">OtherMenu</span>()
              <span class="hljs-type">Menu</span>()
          }
</code></pre><ul><li>keyboardShortcut</li></ul><p>为菜单上的选项添加快捷键。通过modifiers设置需要配合的按键，.help为选项添加悬停帮助</p><pre data-language="swift"><code>  <span class="hljs-type">Button</span>(action:{test1()})
         {
            <span class="hljs-type">Text</span>(<span class="hljs-string">"test1"</span>).foregroundColor(.black)
          }
           .keyboardShortcut(<span class="hljs-string">"1"</span>, modifiers: [.command,.shift])
           .help(<span class="hljs-string">"help test1"</span>)
                  
  <span class="hljs-type">Button</span>(<span class="hljs-string">"test2"</span>, action: test2)
           .keyboardShortcut(<span class="hljs-string">"2"</span>, modifiers: .command)
</code></pre><ul><li>CommandGroup</li></ul><p>在系统提供的默认菜单选项上添加自定义功能。通过replacing,before,after来决定是替换原选项还是设置在指定选项位置之后或之前。</p><pre data-language="swift"><code>  <span class="hljs-comment">//在系统预置的帮助菜单栏下，添加一个自己的选项</span>
  <span class="hljs-type">CommandGroup</span>(replacing: <span class="hljs-type">CommandGroupPlacement</span>.appInfo, addition: {<span class="hljs-type">Button</span>(<span class="hljs-string">"replace"</span>){}})
  <span class="hljs-type">CommandGroup</span>(before: <span class="hljs-type">CommandGroupPlacement</span>.help, addition: {<span class="hljs-type">Button</span>(<span class="hljs-string">"before"</span>){}})
  <span class="hljs-type">CommandGroup</span>(after: <span class="hljs-type">CommandGroupPlacement</span>.newItem, addition: {<span class="hljs-type">Button</span>(<span class="hljs-string">"after"</span>){}})
</code></pre><h2>例子</h2><p>这里简单的例程展示了如何在menu如何通过调用store来影响app的行为。并做了简单的多平台适配。在macOS平台下，通过选择子菜单中不同的选项来影响显示文本。在iOS下通过picker来实现。</p><p><a href="https://github.com/fatbobman/CommandExample">可在此处下载完成代码</a></p><pre data-language="swift"><code>@main
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CommandExampleApp</span>: <span class="hljs-title">App</span> </span>{
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> store = <span class="hljs-type">Store</span>()
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Scene</span> {
        <span class="hljs-type">WindowGroup</span> {
            <span class="hljs-type">RootView</span>()
                .environmentObject(store)
        }
        .commands{
          #<span class="hljs-keyword">if</span> os(macOS) 
            <span class="hljs-type">MyCommand</span>(store: store)
            <span class="hljs-type">OtherMenu</span>()
          #endif
        }
    }
}

#<span class="hljs-keyword">if</span> os(macOS)
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyCommand</span>:<span class="hljs-title">Commands</span></span>{
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> store:<span class="hljs-type">Store</span>
    @<span class="hljs-type">CommandsBuilder</span> <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Commands</span>{
        <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"Test"</span>){
            <span class="hljs-type">Section</span>{
                <span class="hljs-type">Button</span>(action:{test1()}){
                    <span class="hljs-type">Text</span>(<span class="hljs-string">"test1"</span>).foregroundColor(.black)
                }
                .keyboardShortcut(<span class="hljs-string">"1"</span>, modifiers: [.command,.shift])
                .help(<span class="hljs-string">"help test1"</span>)
                
                <span class="hljs-type">Button</span>(<span class="hljs-string">"test2"</span>, action: test2)
                    .keyboardShortcut(<span class="hljs-string">"2"</span>, modifiers: .command)
            }
            
            <span class="hljs-keyword">switch</span> store.selection{
            <span class="hljs-keyword">case</span> .one:
                <span class="hljs-type">Text</span>(<span class="hljs-string">"one"</span>)
            <span class="hljs-keyword">case</span> .two:
                <span class="hljs-type">Text</span>(<span class="hljs-string">"two"</span>)
            <span class="hljs-keyword">case</span> .three:
                <span class="hljs-type">Text</span>(<span class="hljs-string">"three"</span>)
            }
            
            <span class="hljs-type">Divider</span>().padding(.horizontal, <span class="hljs-number">10</span>)
            
            <span class="hljs-type">Button</span>(<span class="hljs-string">"other"</span>){
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"other command"</span>)
            }
            
            
            <span class="hljs-type">ForEach</span>(<span class="hljs-number">0</span>..&lt;<span class="hljs-number">3</span>){ i <span class="hljs-keyword">in</span>
                <span class="hljs-type">Button</span>(<span class="hljs-string">"button\(i)"</span>){
                    <span class="hljs-built_in">print</span>(<span class="hljs-string">"button\(i)"</span>)
                }
            }
            
            <span class="hljs-type">MenuButton</span>(<span class="hljs-string">"Switch Selection"</span>){
                <span class="hljs-type">Button</span>(<span class="hljs-string">"one"</span>){
                    store.changeState(.one)
                }
                <span class="hljs-type">Button</span>(<span class="hljs-string">"two"</span>){
                    store.changeState(.two)
                }
                <span class="hljs-type">Button</span>(<span class="hljs-string">"three"</span>){
                    store.changeState(.three)
                }
            }
        }
        
        <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"Menu2"</span>){
            <span class="hljs-type">Button</span>(action: {}){
                <span class="hljs-type">Text</span>(<span class="hljs-string">"😃Button"</span>)
            }
        }
        
        <span class="hljs-comment">//向现有的菜单项中增加功能</span>
        <span class="hljs-type">CommandGroup</span>(after: <span class="hljs-type">CommandGroupPlacement</span>.help, addition: {
            <span class="hljs-type">Button</span>(<span class="hljs-string">"new help button"</span>){
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"new help"</span>)
            }
        })
        

    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"test1 command"</span>)
    }
    
    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>{
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"test2 command"</span>)
    }
}
#endif

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OtherMenu</span>:<span class="hljs-title">Commands</span></span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">Commands</span>{
        <span class="hljs-type">CommandMenu</span>(<span class="hljs-string">"otherMenu"</span>){
            <span class="hljs-type">Button</span>(<span class="hljs-string">"abc"</span>){
                <span class="hljs-built_in">print</span>(<span class="hljs-string">"abc"</span>)
            }
        }
    }
}


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span>:<span class="hljs-title">ObservableObject</span></span>{
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Selection</span></span>{
        <span class="hljs-keyword">case</span> one,two,three
    }
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> selection:<span class="hljs-type">Selection</span> = .one
    
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">changeState</span><span class="hljs-params">(<span class="hljs-number">_</span> selection:Selection)</span></span>{
        <span class="hljs-keyword">self</span>.selection = selection
    }
}
</code></pre><h2>补充（打开新窗口）</h2><p>我尝试在菜单按钮中打开新的View，不过并没有找到原生的SwiftUI式的方法。我更希望@SceneBuilder能够支持逻辑判断，这样可以任意在WindowGroup组织我想显示的View了。</p><pre data-language="swift"><code><span class="hljs-comment">//打开新的View</span>
<span class="hljs-type">Button</span>(<span class="hljs-string">"other window"</span>){
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"other command"</span>)
    <span class="hljs-keyword">let</span> contentView =
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Text</span>(<span class="hljs-string">"New Window"</span>).padding(.all, <span class="hljs-number">10</span>)
        }.frame(minWidth: <span class="hljs-number">200</span>, minHeight: <span class="hljs-number">200</span>, alignment: .center)
    

    <span class="hljs-keyword">var</span> window: <span class="hljs-type">NSWindow!</span>
    <span class="hljs-comment">// Create the window and set the content view.</span>
    window = <span class="hljs-type">NSWindow</span>(
        contentRect: <span class="hljs-type">NSRect</span>(x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, width: <span class="hljs-number">480</span>, height: <span class="hljs-number">300</span>),
        styleMask: [.titled, .closable, .miniaturizable, .resizable, .fullSizeContentView],
        backing: .buffered, <span class="hljs-keyword">defer</span>: <span class="hljs-literal">false</span>)
    window.isReleasedWhenClosed = <span class="hljs-literal">false</span>
    window.center()
    window.setFrameAutosaveName(<span class="hljs-string">"Main Window"</span>)
    window.contentView = <span class="hljs-type">NSHostingView</span>(rootView: contentView)
    window.makeKeyAndOrderFront(<span class="hljs-literal">nil</span>)
}

<span class="hljs-comment">//打开系统文件选择面板</span>
<span class="hljs-type">Button</span>(<span class="hljs-string">"open panel"</span>){
    <span class="hljs-keyword">let</span> panel = <span class="hljs-type">NSOpenPanel</span>()
          panel.nameFieldLabel = <span class="hljs-string">"open test:"</span>
          panel.begin { response <span class="hljs-keyword">in</span>
              <span class="hljs-keyword">if</span> response == <span class="hljs-type">NSApplication</span>.<span class="hljs-type">ModalResponse</span>.<span class="hljs-type">OK</span>, <span class="hljs-keyword">let</span> fileUrl = panel.url {
                  <span class="hljs-built_in">print</span>(fileUrl)
              }
          }
}
</code></pre><h2>当前的问题</h2><p>由于目前还处在早期的测试阶段，菜单的实现和功能上还有些不足之处，以下是我现在比较在意的：</p><ul><li>Button文本的缺省颜色和系统的菜单选项颜色不同。需要手工设置</li><li>ShortCut的颜色和系统菜单的颜色不同</li><li>Divider的颜色和系统菜单不同</li><li>MenuButton在多平台开发时，必须添加编译注释。而其他比如创建Commands，.commands等都不需要</li><li>@CommandBuilder和@SceneBuilder目前都不支持判断。因此无法通过程序动态的添加或减少一个菜单列。不过从.command中可以添加多个Commands结构来看，后续应该是有这样的打算的。</li></ul>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/stateobject</guid><title>SwiftUI 2.0 —— @StateObject 研究</title><description>WWDC20刚刚结束，在过去的一周，苹果为开发者带来了巨大的惊喜。由于新特性实在太多，需要不少时间来消化，我首先选择自己最感兴趣的内容进行一些简单的研究和探讨。本文首先浅谈一下SwiftUI新提供的属性包装器@StateObject。</description><link>http://www.fatbobman.com/posts/stateobject</link><pubDate>Fri, 26 Jun 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>WWDC20刚刚结束，在过去的一周，苹果为开发者带来了巨大的惊喜。由于新特性实在太多，需要不少时间来消化，我首先选择自己最感兴趣的内容进行一些简单的研究和探讨。本文首先浅谈一下SwiftUI新提供的属性包装器@StateObject。</p></blockquote><h2>为什么要新增@StateObject</h2><p>在我之前的文章<a href="https://zhuanlan.zhihu.com/p/141229504">@State研究</a>中我们探讨过@State，通过它，我们可以方便的将值类型数据作为View的Source of truth。在SwiftUI 1.0时代，如果想将引用类型作为source of truth,通常的方法是使用@EnvironmentObject或者 @ObservedObject。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RootView</span>:<span class="hljs-title">View</span></span>{
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">ContentView</span>()
            .environmentObject(<span class="hljs-type">Store</span>())
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">EnvironmentObject</span>  <span class="hljs-keyword">var</span> store1:<span class="hljs-type">Store</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">Text</span>(<span class="hljs-string">"count:\(store.count)"</span>)
    }
}
</code></pre><p>对于使用@EnvironmentObject注入的数据，由于其通常是在SceneDelegate或着当前View的父辈、祖先View上创建的，所以其生命周期必然不短于当前View,因此在使用中并不会发生由于生命周期不可预测而导致的异常。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test5</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> store = <span class="hljs-type">Store</span>()
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">Text</span>(<span class="hljs-string">"count:\(store.count)"</span>)
    }
}
</code></pre><p>对于上面的代码，乍看起来没有任何不妥，不过由于@ObservedObject的机制问题，其创建的实例并不被当前View所拥有（当前View无法管理其生命周期），因此在一些特殊的情况下会出现不可预料的结果。</p><p>为了能够让开发者更好的掌控代码，同时也保持对于上一版本良好的兼容性，苹果在SwiftUI2.0中添加了@StateObject。顾名思义，它是@State的引用类型版本。</p><p>在WWDC的视频中，苹果明确的表明@StateObject是被创建他的View所持有的，也就是说，实例的生命周期是完全可控的，是同创建它的View的生命周期一样的。</p><p><strong>@StateObject 和 @ObservedObject 的区别就是实例是否被创建其的View所持有，其生命周期是否完全可控。</strong></p><h2>通过代码了解不同</h2><p>我通过下面的代码来详细阐述一下 @StateObject 和 @ObservedObject的不同表现。</p><p><strong>准备工作：</strong></p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateObjectClass</span>:<span class="hljs-title">ObservableObject</span></span>{
    <span class="hljs-keyword">let</span> type:<span class="hljs-type">String</span>
    <span class="hljs-keyword">let</span> id:<span class="hljs-type">Int</span>
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">init</span>(type:<span class="hljs-type">String</span>){
        <span class="hljs-keyword">self</span>.type = type
        <span class="hljs-keyword">self</span>.id = <span class="hljs-type">Int</span>.random(<span class="hljs-keyword">in</span>: <span class="hljs-number">0</span>...<span class="hljs-number">1000</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"type:\(type) id:\(id) init"</span>)
    }
    <span class="hljs-keyword">deinit</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"type:\(type) id:\(id) deinit"</span>)
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CountViewState</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> state = <span class="hljs-type">StateObjectClass</span>(type:<span class="hljs-string">"StateObject"</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Text</span>(<span class="hljs-string">"@StateObject count :\(state.count)"</span>)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"+1"</span>){
                state.<span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CountViewObserved</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> state = <span class="hljs-type">StateObjectClass</span>(type:<span class="hljs-string">"Observed"</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Text</span>(<span class="hljs-string">"@Observed count :\(state.count)"</span>)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"+1"</span>){
                state.<span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
            }
        }
    }
}
</code></pre><p>StateObjectClass将在其被创建和销毁时通过type 和 id 告知我们它是被那种方法创建的，以及具体哪个实例被销毁了。</p><p>CountViewState和CountViewObserved唯一的不同是创建实例使用的属性包装器不同。</p><p><strong>测试1：</strong></p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test1</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Text</span>(<span class="hljs-string">"刷新CounterView计数 :\(count)"</span>)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"刷新"</span>){
                <span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
            }
            
            <span class="hljs-type">CountViewState</span>()
                .padding()
            
            <span class="hljs-type">CountViewObserved</span>()
                .padding()
            
        }
    }
}
</code></pre><p>在测试1中，当进点击+1按钮时，无论是@StateObject或是@ObservedObject其都表现出一致的状态，两个View都可以正常的显示当前按钮的点击次数，不过当点击刷新按钮时，CountViewState中的数值仍然正常，不过CountViewObserved中的计数值被清零了。从调试信息可以看出，当点击刷新时，CountViewObserved中的实例被重新创建了，并销毁了之前的实例（CountViewObserved视图并没有被重新创建，仅是重新求了body的值）。</p><pre data-language="swift"><code>type:<span class="hljs-type">Observed</span> id:<span class="hljs-number">443</span> <span class="hljs-keyword">init</span>
type:<span class="hljs-type">Observed</span> id:<span class="hljs-number">103</span> <span class="hljs-keyword">deinit</span>
</code></pre><p>在这个测试中，@ObservedObject创建的实例的生命周期短于当前View。</p><p><strong>测试2:</strong></p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test2</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">count</span> = <span class="hljs-number">0</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">NavigationView</span>{
            <span class="hljs-type">List</span>{
                <span class="hljs-type">NavigationLink</span>(<span class="hljs-string">"@StateObject"</span>, destination: <span class="hljs-type">CountViewState</span>())
                <span class="hljs-type">NavigationLink</span>(<span class="hljs-string">"@ObservedObject"</span>, destination: <span class="hljs-type">CountViewObserved</span>())
            }
        }
    }
}
</code></pre><p>测试2中，点击link进入对应的View后通过点击+1进行计数，然后返回父视图。当再次进入link后，@StateObject对应的视图中计数清零（由于返回父视图，再次进入时会重新创建视图，所以会重新创建实例），不过@ObservedObject对应的视图中计数是不清零的。</p><p>在这个测试中，@ObservedObject创建的实例生命周期长于当前的View。</p><p><strong>测试3:</strong></p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test3</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> showStateObjectSheet = <span class="hljs-literal">false</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> showObservedObjectSheet = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>{
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Show StateObject Sheet"</span>){
                showStateObjectSheet.toggle()
            }
            .sheet(isPresented: $showStateObjectSheet) {
                <span class="hljs-type">CountViewState</span>()
            }
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Show ObservedObject Sheet"</span>){
                showObservedObjectSheet.toggle()
            }
            .sheet(isPresented: $showObservedObjectSheet) {
                <span class="hljs-type">CountViewObserved</span>()
            }   
        }
    }
}
</code></pre><p>测试3中点击按钮，在sheet中点击+1,当再次进入sheet后，无论是@StateObject还是@ObservedObject对应的View中的计数都被清零。</p><p>在这个测试中，@ObservedObject创建的实例生命周期和View是一致的。</p><p><strong>三段代码，三种结果，这也就是为什么苹果要新增@StateObject的原因——让开发者可以明确地了解并掌握实例的生命周期，消除不确定性！</strong></p><h2>ObservedObject是否还有存在的必要？</h2><p>对我个人而言，基本失去了使用其的理由（可用于绑定父视图传递的@StateObject）。</p><p>尽管或许上面例子的某种特性可能让你觉得ObservedObject可以完成某些特殊需求（比如测试2），但我们无法保证苹果在之后不改变ObservedObject的运行机理，从而改变当前的结果。</p><p>我个人还是更推荐将来都使用@StateObject来消除代码运行的不确定性。</p><p>通过下述代码，使用@StateObject同样可以得到测试2中ObservedObject的运行效果。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Test4</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> showStateObjectSheet = <span class="hljs-literal">false</span>
    @<span class="hljs-type">StateObject</span> <span class="hljs-keyword">var</span> state = <span class="hljs-type">StateObjectClass</span>(type: <span class="hljs-string">"stateObject"</span>)
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-type">List</span>{
            <span class="hljs-type">Button</span>(<span class="hljs-string">"Show StateObject1 Sheet"</span>){
                showStateObjectSheet.toggle()
            }
            .sheet(isPresented: $showStateObjectSheet) {
                <span class="hljs-type">CountViewState1</span>(state: state)
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CountViewState1</span>:<span class="hljs-title">View</span></span>{
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> state:<span class="hljs-type">StateObjectClass</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span>{
        <span class="hljs-type">VStack</span>{
            <span class="hljs-type">Text</span>(<span class="hljs-string">"@StateObject count :\(state.count)"</span>)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"+1"</span>){
                state.<span class="hljs-built_in">count</span> += <span class="hljs-number">1</span>
            }
        }
    }
}
</code></pre><h2>Next</h2><p>苹果使用@StateObject一方面修复了之前的隐患，同时通过SwiftUI2.0众多新特性的引入，进一步完善了Data Flow的实现手段。在下一篇文章《SwiftUI2.0 —— 100% SwiftUI app》中，我们来进一步探讨。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/observableObject-study</guid><title>ObservableObject研究——想说爱你不容易</title><description>本文主要研究在SwiftUI中，采用单一数据源(Single Source of Truth)的开发模式，ObservableObject是否为最佳选择。是否可以在几乎不改变现有设计思路下进行新的尝试，以提高响应效率。最后提供了一个仍采用单一数据源设计思路但完全弃用ObservableObject的方式。</description><link>http://www.fatbobman.com/posts/observableObject-study</link><pubDate>Sun, 17 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文主要研究在SwiftUI中，采用单一数据源(Single Source of Truth)的开发模式，ObservableObject是否为最佳选择。是否可以在几乎不改变现有设计思路下进行新的尝试，以提高响应效率。最后提供了一个仍采用单一数据源设计思路但完全弃用ObservableObject的方式。</p></blockquote><h2>单一数据源</h2><p>我是在去年阅读王巍写的<a href="https://objccn.io/products/swift-ui">《SwiftUI 与 Combine 编程》</a>才第一次接触到<strong>单一数据源</strong>这一概念的。</p><ul><li>将 app 当作一个状态机，状态决定用户界面。</li></ul><ul><li>这些状态都保存在一个 Store 对象中，被称为 State。</li></ul><ul><li>View 不能直接操作 State，而只能通过发送 Action 的方式，间接改变存储在 Store 中的 State。</li></ul><ul><li>Reducer 接受原有的 State 和发送过来的 Action，生成新的 State。</li></ul><ul><li>用新的 State 替换 Store 中原有的状态，并用新状态来驱动更新界面。</li></ul><img src="http://cdn.fatbobman.com/observableObject-study-reduximage.gif" alt="Redux架构"/><p>在该书中结合作者之前Redux、RxSwift等开发经验，提供了一个SwiftUI化的范例程序。之后我也继续学习了一些有关的资料，并通过阅读Github上不少的开源范例，基本对这一方式有所掌握，并在<a href="https://apps.apple.com/app/id1492861358"><strong>健康笔记</strong></a>中得以应用。总的来说，当前在SwiftUI框架下，大家的实现手段主要的不同都体现在细节上，大的方向、模式、代码构成基本都差不多：</p><ul><li>Store对象遵守ObservableObject协议</li></ul><ul><li>State保存在Store对象中，并使用@Published进行包装。从而在State发生变化时通知Store</li></ul><ul><li>Store对象通过@ObservedObject 或 @EnvironmentObject与View建立依赖</li></ul><ul><li>Store对象在State变化后通过objectWillChange的Pbulisher通知与其已建立依赖关系的View进行刷新</li></ul><ul><li>View发送Action -&gt; Recudcer(State,Action) -&gt; newState 周而复始</li></ul><ul><li>由于SwiftUI的双向绑定机制，数据流并非完全单向的</li></ul><ul><li>在部分视图中可以结合SwiftUI通过的其他包装属性如@FetchRequest等将状态局部化</li></ul><p>后两项是利用SwiftUI的特性，也可以不采用，完全采用单向数据流的方式</p><p>基于以上方法，在SwiftUI中进行单一数据源开发是非常便利的，在多数情况下执行效率、响应速度都是有基本保证的。不过就像我在上一篇文章 <a href="https://zhuanlan.zhihu.com/p/141229504">@State研究</a> 中提到过的，<strong>当随着动态数据量的增大、与Store保有依赖关系的View数量提高到一定程度后，整个app的响应效率便会急剧恶化。</strong></p><p>恶化的原因主要有以下几点：</p><ol><li>对于遵循ObservableObject对象的依赖注入时机</li><li>View的精细化</li><li>依赖通知接口唯一性。State（状态集合）中任何的单一元素发生变化都将通知所有与Store有依赖的View进行重绘。</li></ol><p>我就以上几点逐条进行分析。</p><h2>对于遵循ObservableObject对象的依赖注入时机</h2><p>在 <a href="https://zhuanlan.zhihu.com/p/141229504">@State研究</a> 中的 <strong>什么时候建立的依赖？</strong>章节中，我们通过了一段代码进行过@State和@ObservedObject对于依赖注入时机的推测。结果就是通过使用@ObservedObject或@EnvironmentObject进行的依赖注入，编译器没有办法根据当前View的具体内容来进行更精确的判断，只要你的View中进行了声明，依赖关系变建立了。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MainView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> store = <span class="hljs-type">AppStore</span>()

    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"mainView"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Form</span> {
            <span class="hljs-type">SubView</span>(date: $store.date)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"修改日期"</span>) {
                <span class="hljs-keyword">self</span>.store.date = <span class="hljs-type">Date</span>().description
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SubView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> date: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"subView"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Text</span>(date)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppStore</span>:<span class="hljs-title">ObservableObject</span></span>{
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> date:<span class="hljs-type">String</span> = <span class="hljs-type">Date</span>().description
}
</code></pre><p>执行后输出如下：</p><pre data-language="swift"><code>mainView
subView
mainView
subView
...
</code></pre><p>更详细的分析请参见 <a href="http://www.fatbobman.com/posts/swiftUI-state/">@State研究</a></p><p><strong>即使你只在View中发送action，并没有显示State中的数据或使用其做判断，该View也会被强制刷新。甚至，如果你像我一样，忘了移除在View中的声明，View也同样会被更新。</strong></p><p>如果类似的View比较多，你的app将会出现大量的无效更新。</p><h2>View的精细化</h2><p>这里所指的View是你自己构建的遵循View协议的结构体。</p><p>在SwiftUI下开发，无论是主观还是客观都需要你将View的表述精细化，用更多的子View来组成你的最终视图，而不是把所有的代码都尽量写在同一个View上。</p><h3>主观方面</h3><ul><li>更小的耦合性</li></ul><ul><li>更强的复用性</li></ul><h3>客观方面</h3><h4>ViewBuilder的设计限制</h4><p>FunctionBuilder作为Swift5.1的重要新增特性，成为了SwiftUI声明式编程的基础。它为在Swift代码中实现DSL带来了极大的便利。不过作为一个新生产物，它目前的能力还并不十分的强大。 目前它仅提供非常有限的逻辑语句 在编写代码中，为了能够实现更多逻辑和丰富的UI，我们必须把代码分散到各个View中，再最终合成。否则你会经常获得无法使用过多逻辑等等的错误提示。</p><h4>以Body为单位的优化机制</h4><p>SwiftUI为了减少View的重绘其实做了大量的工作，它以View的body为单位进行非常深度的优化（body是每个View的唯一入口；View中使用func -&gt; some View无法享受优化，只有独立的View才可以）。SwiftUI在程序编译时便已将所有的View编译成View树，它尽可能的只对必须要响应状态变化的View（@State完美的支持）进行重绘工作。用户还可以通过自行设置Equatable的比对条件进一步优化View重绘策略。<br>#### Xcode的代码实时解析能力限制 ####<br> 如果你在同一个View中写入了过多的代码，Xcode的代码提示功能几乎就会变得不可用了。我估计应该是解析DSL本身的工作量非常大，我们在View body中写的看起来不多的描述语句，其实后面对应的是非常多的具体代码。Xcode的代码提示总会超出了它合理的计算时间而导致故障。此时只需把View分解成几个View，即使仍然在同一个文件中，Xcode的工作也会立刻正常起来。</p><h4>预览的可靠性限制</h4><p>新的预览功能本来会极大的提升布局及调试效率，但由于其对复杂代码的支持并不完美，将View分割后，通过使用合适的Preview控制语句可以高效、无错的对每个子View进行独立预览。</p><p>从上面几点看，无论从任何角度，更精细化的View描述都是十分合适的。</p><p><strong>但由于在单一数据源的情况下，我们将会有更多的View和Store建立依赖。众多的依赖将使我们无法享受到SwiftUI提供的View更新优化机制。</strong></p><p>有关View优化的问题大家可以参考 <a href="https://objccn.io/products/thinking-in-swiftui">《SwiftUI编程思想》</a>一书中View更新机制的介绍，另外<a href="https://swiftui-lab.com/equatableview/">swiftui-lab</a>上也有探讨Equality的文章。</p><h2>依赖通知接口唯一性</h2><p>State（状态集合）中任何的单一元素的变化都将通知所有与Store有依赖的View进行重绘。</p><p>使用@Published对State进行了包装。在State的值发生变化后，其会通过Store（ObservableObject协议）提供的ObjectWillChangePublisher发送通知，所有与其有依赖的View进行刷新。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppStore</span>:<span class="hljs-title">ObservableObject</span></span>{
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> state = <span class="hljs-type">State</span>()
      ...
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span></span>{
    <span class="hljs-keyword">var</span> userName:<span class="hljs-type">String</span> = <span class="hljs-string">""</span>
    <span class="hljs-keyword">var</span> login:<span class="hljs-type">Bool</span> = <span class="hljs-literal">false</span>
    <span class="hljs-keyword">var</span> selection:<span class="hljs-type">Int</span> = <span class="hljs-number">0</span>
}
</code></pre><p>对于一个并不复杂的State来说，尽管仍有无效动作，但整体效率影响并不大，但是如果你的app的State里面内容较多，更新较频繁，View的更新压力会陡然增大。尤其State中本来很多数据的变化性是不高的，大量的View只需要使用变化性低的数据，但只要State发生任何改动，都将被迫重绘。</p><h2>如何改善</h2><p>在发现了上述的问题后，开始逐步尝试找寻解决的途径。</p><h3>第一步 减少注入依赖</h3><p>针对只要声明则就会形成依赖的的问题，我第一时间想到的就是减少注入依赖。首先不要在代码中添加不必要的依赖声明；对于那些只需要发送Action但并不使用State的View，将store定义成全部变量，无需注入直接使用。</p><pre data-language="swift"><code><span class="hljs-comment">//AppDelegate中</span>
<span class="hljs-built_in">lazy</span> <span class="hljs-keyword">var</span> store = <span class="hljs-type">Store</span>()

<span class="hljs-comment">//</span>
<span class="hljs-keyword">let</span> store = (<span class="hljs-type">UIApplication</span>.shared.delegate <span class="hljs-keyword">as</span>! <span class="hljs-type">AppDelegate</span>).store
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>:<span class="hljs-title">View</span></span>{
  <span class="hljs-keyword">var</span> body:some <span class="hljs-type">View</span>{
    <span class="hljs-type">Button</span>(<span class="hljs-string">"直接使用Action"</span>){
      store.dispatch(.test)
    }
  }
}

<span class="hljs-comment">//其他需要依赖注入的View则正常使用</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">OtherView</span>:<span class="hljs-title">View</span></span>{
  @<span class="hljs-type">EnvironmentObject</span> <span class="hljs-keyword">var</span> store:<span class="hljs-type">Store</span>
  <span class="hljs-keyword">var</span> boyd:some <span class="hljs-type">View</span>{
    <span class="hljs-type">Text</span>(store.state.name)
  }
}
</code></pre><h4>第二步 将无必要性的状态区域化</h4><p>听起来这条貌似背离了单一数据源的思想，不过其实在app中，有非常多的状态仅对当前View或小范围的View有效。如果能够合理的进行设计，这些状态信息在自己的小区域中完全可以很好地自我管理，自我维持。没有必要统统汇总到State中。</p><p>在区域范围内来创建被维持一个小的状态，主要可以使用以下几种手段：</p><ul><li>善用@State 在 <a href="https://zhuanlan.zhihu.com/p/141229504">@State研究</a> 这篇文章中,我们讨论了SwiftUI对于@State的优化问题。如果设计合理，我们可以将无关大局的信息，保存在局部View。同时通过对@State的二度包装，我们同样可以完成所需要的副作用。该View的子View如果使用了@Binding，也只对局部的View树产生影响。</li></ul><p>另外也可以将常用的View修饰通过ViewModifier进行包装。ViewModifier可以维持自己的@State，可以自行管理状态。</p><ul><li>创建自己的@EnviromentKey或PreferenceKey，仅注入需要的View树分支</li></ul><p>同EnviromentObject类似，注入EnviromentKey的依赖也是显性的</p><pre data-language="swift"><code>  @<span class="hljs-type">Environment</span>(\.myKey) <span class="hljs-keyword">var</span> currentPage
</code></pre><p>我们可以通过以下方式，更改该EnvironmentKey的值，但作用范围仅针对当前View下面的子View分支</p><pre data-language="swift"><code>  <span class="hljs-type">Button</span>(<span class="hljs-string">"修改值"</span>){
    <span class="hljs-keyword">self</span>.currentPage = <span class="hljs-number">3</span>
  }
  <span class="hljs-type">SubView</span>()
      .environment(\.myKey, currentPage)
</code></pre><p>EnvironmentObject也是可以在任意某个分支注入依赖的，不过由于其是引用类型，通常任何分支的改动，都仍然会对整个View树其他的使用者造成影响。</p><p>同理，我们也可以使用PreferenceKey，只将数据注入到当前View之上的层级。</p><p>值类型无论如何都要比引用类型都更可控些。</p><ul><li>在当前View使用SwiftUI提供的其他包装属性</li></ul><p>我现在最常使用的SwiftUI的其他包装属性就属@FetchRequest了。除了必要的数据放置于State中，我对于CoreDate的大多数据需求都通过该属性包装器来完成。@FetchRequest目前有不足之处，比如无法进行更精细的批量指定、明确惰性状态、获取限制等，不过相对于它带来的便利性，我还是完全可以接受的。FetchRequest完全可以实现同其他CoreData NSFetchRequest一样的程序化Request设定，结合上面的方式同样可以将Request生成器放在Store中而不影响当前View。</p><pre data-language="swift"><code>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SideView</span>: <span class="hljs-title">View</span> </span>{
      @<span class="hljs-type">Environment</span>(\.managedObjectContext)
      <span class="hljs-keyword">var</span> context
  
      @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> search: <span class="hljs-type">Search?</span>
  
      <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
          <span class="hljs-type">VStack</span>(alignment: .leading) {
              <span class="hljs-type">SearchView</span>(
                  onSearch: <span class="hljs-keyword">self</span>.onSearch
              )
              <span class="hljs-type">InsideListView</span>(fetchRequest: makeFetchRequest())  <span class="hljs-comment">//根据上面的search 来生成不同谓词对应的fetchrequest.</span>
          }
      }
  
      <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeFetchRequest</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">FetchRequest</span>&lt;<span class="hljs-type">Book</span>&gt; {
          <span class="hljs-keyword">let</span> predicate: <span class="hljs-type">NSPredicate?</span>
          <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> search = search {
              <span class="hljs-keyword">let</span> textPredicate = <span class="hljs-type">NSPredicate</span>(format: <span class="hljs-string">"string CONTAINS[cd] %@"</span>, search.text)
              <span class="hljs-keyword">let</span> appPredicate = <span class="hljs-type">NSPredicate</span>(format: <span class="hljs-string">"appName == %@"</span>, search.app)
              <span class="hljs-keyword">let</span> typePredicate = <span class="hljs-type">NSPredicate</span>(format: <span class="hljs-string">"type == %@"</span>, search.type)
  
              <span class="hljs-keyword">var</span> predicates: [<span class="hljs-type">NSPredicate</span>] = []
              <span class="hljs-keyword">if</span> search.text.<span class="hljs-built_in">count</span> &gt;= <span class="hljs-number">3</span> {
                  predicates.append(textPredicate)
              }
  
              <span class="hljs-keyword">if</span> search.app != <span class="hljs-type">Constants</span>.all {
                  predicates.append(appPredicate)
              }
  
              <span class="hljs-keyword">if</span> search.type != <span class="hljs-type">Constants</span>.all {
                  predicates.append(typePredicate)
              }
  
              predicate = <span class="hljs-type">NSCompoundPredicate</span>(andPredicateWithSubpredicates: predicates)
          } <span class="hljs-keyword">else</span> {
              predicate = <span class="hljs-literal">nil</span>
          }
  
          <span class="hljs-keyword">return</span> <span class="hljs-type">FetchRequest</span>&lt;<span class="hljs-type">Book</span>&gt;(
              entity: <span class="hljs-type">Book</span>.entity(),
              sortDescriptors: [
                  <span class="hljs-type">NSSortDescriptor</span>(keyPath: \<span class="hljs-type">Book</span>.date, ascending: <span class="hljs-literal">false</span>)
              ],
              predicate: predicate
          )
      }
  
      <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">onSearch</span><span class="hljs-params">(<span class="hljs-number">_</span> search: Search)</span></span> {
          <span class="hljs-keyword">if</span> search.text.<span class="hljs-built_in">count</span> &lt; <span class="hljs-number">3</span> &amp;&amp; search.type != <span class="hljs-type">Constants</span>.all &amp;&amp; search.app != <span class="hljs-type">Constants</span>.all {
              <span class="hljs-keyword">self</span>.search = <span class="hljs-literal">nil</span>
          } <span class="hljs-keyword">else</span> {
              <span class="hljs-keyword">self</span>.search = search
          }
      }
  }
  
  <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">InsideListView</span>: <span class="hljs-title">View</span> </span>{
      @<span class="hljs-type">Environment</span>(\.managedObjectContext)
      <span class="hljs-keyword">var</span> context
  
      <span class="hljs-keyword">var</span> fetchRequest: <span class="hljs-type">FetchRequest</span>&lt;<span class="hljs-type">Book</span>&gt;    <span class="hljs-comment">//只声明,内容需要由调用者来设定</span>
  
      <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
          <span class="hljs-type">List</span>(items) {
              <span class="hljs-type">ForEach</span>
         }
      }
  
      <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> items: <span class="hljs-type">FetchedResults</span>&lt;<span class="hljs-type">Book</span>&gt; {
          fetchRequest.wrappedValue
      }
  }
</code></pre><p>我相信，下一步SwiftUI应该还会提供更多的直接将状态控制在局部的包装器。</p><h4>第三部 和ObservedObject说再见</h4><p>只要我们的View还需要依赖单一数据源的State，前面我们做努力就都付之东流了。但坚持单一数据源的设计思路又是十分明确的。由于任何状态的变化ObservedObject只有通过ObjectWillChangePublisher这一个途径来通知与其依赖的View，因此我们如果要解决这个问题，只能放弃使用ObservedObject，通过自己创建视图和State中每个独立元素的依赖关系，完成我们的优化目的。</p><p>Combine当然是首选。我希望达到的效果如下：</p><ul><li>State仍然以目前的形式保存在Store中，整个程序的结构基本和使用ObservedObject一样</li><li>State中每个元素可以自己通知与其依赖的View而不通过@Published</li><li>每个View可以根据自己的需要同State中的元素建立依赖关系，State中其他无关的变化不会导致其被强制刷新</li><li>State中的数据仍然支持Binding等操作，而且能够支持各种形式的结构设定</li></ul><p>基于以上几点，我最终采用了如下的解决方案：</p><p>1、Store不变，只是去掉了ObservedObject</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Store</span></span>{
  <span class="hljs-keyword">var</span> state = <span class="hljs-type">AppState</span>()
  ...
}
</code></pre><p>2、State结构如下</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AppState</span></span>{
  <span class="hljs-keyword">var</span> name = <span class="hljs-type">CurrentValueSubject</span>&lt;<span class="hljs-type">String</span>,<span class="hljs-type">Never</span>&gt;(<span class="hljs-string">"肘子"</span>)
  <span class="hljs-keyword">var</span> age = <span class="hljs-type">CurrentValueSubject</span>&lt;<span class="hljs-type">Int</span>,<span class="hljs-type">Never</span>&gt;(<span class="hljs-number">100</span>)
}
</code></pre><p>通过使用CurrentValueSubject来创建指定类型的Publisher。</p><p>3、通过如下方式注入</p><pre data-language="swift"><code><span class="hljs-comment">//当前View只需要显示name</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>:<span class="hljs-title">View</span></span>{
  @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name:<span class="hljs-type">String</span> = <span class="hljs-string">""</span>
  <span class="hljs-keyword">var</span> body:some <span class="hljs-type">View</span>{
    <span class="hljs-type">Form</span>{
      <span class="hljs-type">Text</span>(name)
    }
    .onReceive(store.state.name, perform: { name <span class="hljs-keyword">in</span>
                <span class="hljs-keyword">self</span>.name = name
            })
  }
}
</code></pre><p>我们需要显式的在每个View中把需要依赖的元素单独通过.onReceive获取并保存到本地。</p><p>4、修改State中的值</p><pre data-language="swift"><code><span class="hljs-comment">//基于View-&gt; Action 来修改State的机制</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Store</span></span>{
  <span class="hljs-comment">//例程并非遵循action，不过也是调用Store，意会即可</span>
  fune test{
     state.name.value = <span class="hljs-string">"大肘子"</span>
  }
}

<span class="hljs-comment">//在上面的ContentView中添加</span>
<span class="hljs-type">Button</span>(<span class="hljs-string">"修改名字"</span>){
  store.test()
}
</code></pre><p>5、支持Binding</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CurrentValueSubject</span></span>{
    <span class="hljs-keyword">var</span> binding:<span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Output</span>&gt;{
        <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Output</span>&gt;(<span class="hljs-keyword">get</span>: {<span class="hljs-keyword">self</span>.value}, <span class="hljs-keyword">set</span>: {<span class="hljs-keyword">self</span>.value = $<span class="hljs-number">0</span>})
    }
}
<span class="hljs-comment">//使用binding</span>

<span class="hljs-type">TextField</span>(<span class="hljs-string">"姓名"</span>,text:store.state.name.binding)
</code></pre><p>6、对结构体支持Binding</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span></span>{
    <span class="hljs-keyword">var</span> name = <span class="hljs-string">"fat"</span>
    <span class="hljs-keyword">var</span> age = <span class="hljs-number">18</span>
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AppState</span></span>{
      <span class="hljs-keyword">var</span> student = <span class="hljs-type">CurrentValueSubject</span>&lt;<span class="hljs-type">Student</span>,<span class="hljs-type">Never</span>&gt;(<span class="hljs-type">Student</span>())
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">CurrentValueSubject</span></span>{
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binding</span>&lt;Value&gt;<span class="hljs-params">(<span class="hljs-keyword">for</span> keyPath:WritableKeyPath&lt;Output,Value&gt;)</span></span>-&gt;<span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Value</span>&gt;{
               <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Value</span>&gt;(<span class="hljs-keyword">get</span>: {<span class="hljs-keyword">self</span>.value[keyPath:keyPath]}, 
                              <span class="hljs-keyword">set</span>: { <span class="hljs-keyword">self</span>.value[keyPath:keyPath] = $<span class="hljs-number">0</span>})
    }
}

<span class="hljs-comment">//使用Binding</span>
<span class="hljs-type">TextField</span>(<span class="hljs-string">"studentName:"</span>,text: store.state.student.binding(<span class="hljs-keyword">for</span>: \.name))
</code></pre><p>7、对于更复杂的State元素设计的Binding支持。如果你却有必要在State中创建以上Binding方式无法支持的格式可以通过使用我另一篇文章中 <a href="https://zhuanlan.zhihu.com/p/141229504">@State研究</a>最后创建的增强型@MyState来完成特殊的需要，你对本地的 studentAge做的任何改动都将自动的反馈到State中</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ContentView</span>:<span class="hljs-title">View</span></span>{
  @<span class="hljs-type">MyState</span>&lt;<span class="hljs-type">String</span>&gt;(wrappedValue: <span class="hljs-type">String</span>(store.state.student.value.age), toAction: {
        store.state.student.value.age = <span class="hljs-type">Int</span>($<span class="hljs-number">0</span>) ?? <span class="hljs-number">0</span>
    }) <span class="hljs-keyword">var</span> studentAge
  <span class="hljs-keyword">var</span> body:some <span class="hljs-type">View</span>{
     <span class="hljs-type">TextField</span>(<span class="hljs-string">"student age:"</span>,text: $studentAge)   
  }
}
</code></pre><p>至此我们便达成了之前设定的全部目标。</p><ul><li>只对原有的程序结构做微小的调整</li></ul><ul><li>State中每个元素都会在自改动时独立的发出通知</li></ul><ul><li>每个View可以只与自己有关的State中的元素创建依赖</li></ul><ul><li>对Binding的完美支持</li></ul><h4>追加：减少代码量</h4><p>在实际的使用中，上述解决方案会导致每个View的代码量有了一定的增长。尤其是当你忘了写.onReceive时，程序并不会报错，但同时数据不会实时响应，反倒增加排查错误的难度。通过使用属性包装器，我们可以将Publisher订阅和变量声明合二为一，进一步的优化上述的解决方案。</p><pre data-language="swift"><code><span class="hljs-meta">@propertyWrapper</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ObservedPublisher</span>&lt;<span class="hljs-title">P</span>:<span class="hljs-title">Publisher</span>&gt;:<span class="hljs-title">DynamicProperty</span> <span class="hljs-title">where</span> <span class="hljs-title">P</span>.<span class="hljs-title">Failure</span> == <span class="hljs-title">Never</span></span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">let</span> publisher:<span class="hljs-type">P</span>
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> cancellable:<span class="hljs-type">AnyCancellable?</span> = <span class="hljs-literal">nil</span>
    
    @<span class="hljs-type">State</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">private</span>(<span class="hljs-keyword">set</span>) <span class="hljs-keyword">var</span> wrappedValue:<span class="hljs-type">P</span>.<span class="hljs-type">Output</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> updateWrappedValue = <span class="hljs-type">MutableHeapWrapper</span>&lt;(<span class="hljs-type">P</span>.<span class="hljs-type">Output</span>)-&gt;<span class="hljs-type">Void</span>&gt;({ <span class="hljs-number">_</span> <span class="hljs-keyword">in</span> })
    
    <span class="hljs-keyword">init</span>(publisher:<span class="hljs-type">P</span>,initial:<span class="hljs-type">P</span>.<span class="hljs-type">Output</span>) {
        <span class="hljs-keyword">self</span>.publisher = publisher
        <span class="hljs-keyword">self</span>._wrappedValue = .<span class="hljs-keyword">init</span>(wrappedValue: initial)
        
        <span class="hljs-keyword">let</span> updateWrappedValue = <span class="hljs-keyword">self</span>.updateWrappedValue
        <span class="hljs-keyword">self</span>._cancellable = .<span class="hljs-keyword">init</span>(initialValue:  publisher
            .delay(<span class="hljs-keyword">for</span>: .nanoseconds(<span class="hljs-number">1</span>), scheduler: <span class="hljs-type">RunLoop</span>.main)
            .sink(receiveValue: {
                updateWrappedValue.value($<span class="hljs-number">0</span>)
            }))
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> _wrappedValue = <span class="hljs-keyword">self</span>._wrappedValue
        updateWrappedValue.value = {
            _wrappedValue.wrappedValue = $<span class="hljs-number">0</span>}
    }
    
}

<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutableHeapWrapper</span>&lt;<span class="hljs-title">T</span>&gt; </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> value: <span class="hljs-type">T</span>
    
    @inlinable
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(<span class="hljs-number">_</span> value: <span class="hljs-type">T</span>) {
        <span class="hljs-keyword">self</span>.value = value
    }
}
</code></pre><p>上面的代码来自于开源项目SwiftUIX，我对其进行了很小修改使其能够适配CurrentValueSubject</p><p>使用方法</p><pre data-language="swift"><code>@<span class="hljs-type">ObservedPublisher</span>(publisher: store.state.title, initial: <span class="hljs-string">""</span>) <span class="hljs-keyword">var</span> title
</code></pre><p>至此，我们进一步的减少了代码量，并且基本消除了由于漏写.onReceive而可能出现的问题。</p><p>上述代码我已经放到了<a href="https://github.com/fatbobman/MySingleSoureOfTruthDemo">Github</a></p><h2>总结</h2><p>之所以进行这方面的探讨是由于我的app出现了响应的粘滞（和我心目中iOS平台上该有的丝滑感有落差）。在研究学习的过程中也让我对SwiftUI的有了进一步的认识。无论我提出的思路是否正确，至少整个过程让我获益匪浅。</p><p>在我做这方面学习的过程中，恰好也发现了另外一位朋友提出了类似的观点，并提出了他的解决方案。由于他之前有RxSwift上开发大型项目的经验，他的解决方案使用了快照（SnapShot）的概念。注入方式采用EnvironmetKey，对于State元素的无效修改（比如说和原值相同）做了比较好的过滤。可以到<a href="https://nalexn.github.io/swiftui-observableobject/">他的博客</a>查看该文。</p><p>最后希望Apple能够在将来提供更原生的方式解决以上问题。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/swiftUI-state</guid><title>@state研究</title><description>本文试图探讨并分析SwiftUI 中 @State的实现方式和运行特征；最后提供了一个有关扩展@State功能的思路及例程。读者需要对SwiftUI的响应式编程有基本概念。</description><link>http://www.fatbobman.com/posts/swiftUI-state</link><pubDate>Sun, 17 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文试图探讨并分析SwiftUI 中 @State的实现方式和运行特征；最后提供了一个有关扩展@State功能的思路及例程。读者需要对SwiftUI的响应式编程有基本概念。</p></blockquote><h2>研究的意义何在</h2><p>我在去年底使用了SwiftUI写了第一个 iOS app <strong>健康笔记</strong>，这是我第一次接触响应式编程概念。在有了些基本的认识和尝试后，深深的被这种编程的思路所打动。不过，我在使用中也发现了一些奇怪的问题。就像之前在 <a href="https://zhuanlan.zhihu.com/p/103822455">老人新兵</a> 中说的那样，我发现在视图（View）数量达到一定程度，随着数据量的增加，整个app的响应有些开始迟钝，变得有粘滞感、不跟手。app响应出现了问题一方面肯定和我的代码效率、数据结构设计欠佳有关；不过随着继续分析，发现其中也有很大部分原因来自于SwiftUI中所使用的响应式的实现方式。不恰当的使用，可能导致响应速度会随着数据量及View量的增加而大幅下降。通过一段时间的研究和分析，我打算用两篇文章来阐述这方面的问题，并尝试提供一个现阶段的使用思路。</p><h2>数据（状态）驱动</h2><p>在SwiftUI中，视图是由数据（状态）驱动的。按照苹果的说法，视图是状态的函数，而不是事件的序列（The views are a function of state, not a sequence of events）。每当视图在创建或解析时，都会为该视图和与该视图中使用的状态数据之间创建一个依赖关系，每当状态的信息发生变化是，有依赖关系的视图则会马上反应出这些变化并重绘。SwiftUI中提供了诸如 @State ObservedObject EnvironmentObject等来创建应对不同类型、不同作用域的状态形式。</p><img src="http://cdn.fatbobman.com/state-study-image.jpg" alt="类型及作用域"/><center>图片来自于SwiftUI for Absoloute Beginners</center><p>其中@State只能用于当前视图，并且其对应的数据类型为值类型（如果非要对应引用类型的话则必须在每次赋值时重新创建新的实例才可以）。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DemoView</span>:<span class="hljs-title">View</span></span>{
  @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">"肘子"</span>
  <span class="hljs-keyword">var</span> body:some <span class="hljs-type">View</span>{
    <span class="hljs-type">VStack</span>{
      <span class="hljs-type">Text</span>(name)
      <span class="hljs-type">Button</span>(<span class="hljs-string">"改名"</span>){
        <span class="hljs-keyword">self</span>.name = <span class="hljs-string">"大肘子"</span>
      }
    }
  }
}
</code></pre><p>通过执行上面代码，我们可以发现两个情况：</p><ol><li>通过使用@State，我们可以在未使用mutating的情况下修改结构中的值</li></ol><ol start="2"><li>当状态值发生变化后，视图会自动重绘以反应状态的变化。</li></ol><h2>@State如何工作的</h2><p>在分析@State如何工作之前，我们需要先了解几个知识点</p><h3>属性包装器</h3><p>作为swift 5.1的新增功能之一，<a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/10_properties#property-wrappers">属性包装器在管理属性如何存储和定义属性的代码之间添加了一个分割层</a>。通过该特性，可以在对值校验、持久化、编解码等多个方面获得收益。</p><p>它的实现也很简单,下面的例子定义了一个包装器用来确保它包装的值始终小于等于12。如果要求它存储一个更大的数字，它则会存储 12 这个数字。呈现值(投射值)则返回当前包装值是否为偶数</p><pre data-language="swift"><code><span class="hljs-meta">@propertyWrapper</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TwelveOrLess</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> number: <span class="hljs-type">Int</span>
    <span class="hljs-keyword">init</span>() { <span class="hljs-keyword">self</span>.number = <span class="hljs-number">0</span> }
    <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">get</span> { <span class="hljs-keyword">return</span> number }
        <span class="hljs-keyword">set</span> { number = <span class="hljs-built_in">min</span>(newValue, <span class="hljs-number">12</span>) }
    }
    <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-type">Bool</span> {
        <span class="hljs-keyword">self</span>.number % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>
    }
}
</code></pre><p>更多的具体资料请查阅<a href="https://swiftgg.gitbook.io/swift/swift-jiao-cheng/10_properties#property-wrappers">官方文档</a></p><h3>Binding</h3><p>Binding是数据的一级引用，在SwiftUI中作为数据（状态）双向绑定的桥梁，允许在不拥有数据的情况下对数据进行读写操作。我们可以绑定到多种类型，包括 State ObservedObject 等，甚至还可以绑定到另一个Binding上面。Binding本身就是一个Getter和Setter的封装。</p><h3>State 的定义</h3><pre data-language="swift"><code>@frozen <span class="hljs-meta">@propertyWrapper</span> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">Value</span>&gt; : <span class="hljs-title">DynamicProperty</span> </span>{

    <span class="hljs-comment">/// Initialize with the provided initial value.</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(wrappedValue value: <span class="hljs-type">Value</span>)

    <span class="hljs-comment">/// Initialize with the provided initial value.</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>(initialValue value: <span class="hljs-type">Value</span>)

    <span class="hljs-comment">/// The current state value.</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">Value</span> { <span class="hljs-keyword">get</span> <span class="hljs-keyword">nonmutating</span> <span class="hljs-keyword">set</span> }

    <span class="hljs-comment">/// Produces the binding referencing this state value</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Value</span>&gt; { <span class="hljs-keyword">get</span> }
}
</code></pre><h3>DynamicProperty 的定义</h3><pre data-language="swift"><code><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">protocol</span> <span class="hljs-title">DynamicProperty</span> </span>{

    <span class="hljs-comment">/// Called immediately before the view's body() function is</span>
    <span class="hljs-comment">/// executed, after updating the values of any dynamic properties</span>
    <span class="hljs-comment">/// stored in `self`.</span>
    <span class="hljs-keyword">mutating</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span>
}
</code></pre><h3>工作原理</h3><p>前面我们说过 @State 有两个作用</p><ol><li>通过使用@State，我们可以在未使用mutating的情况下修改结构中的值</li><li>当状态值发生变化后，视图会自动重绘以反应状态的变化。</li></ol><p>让我们根据上面的知识点来分析如何才能实现以上功能。</p><ul><li>@State本身包含 @propertyWrapper,意味着他是一个属性包装器。</li></ul><ul><li>public var wrappedValue: Value { get nonmutating set } 意味着他的包装值并没有保存在本地。</li></ul><ul><li>它的呈现值（投射值）为Binding类型。也就是只是一个管道，对包装数据的引用</li></ul><ul><li>遵循 DynamicProperty 协议，该协议完成了创建数据（状态）和视图的依赖操作所需接口。现在只暴露了很少的接口，我们暂时无法完全使用它。</li></ul><p>在了解了以上几点后，我们来尝试使用自己的代码来构建一个@State的<strong><em>半成品</em></strong></p><pre data-language="swift"><code><span class="hljs-meta">@propertyWrapper</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStates</span>:<span class="hljs-title">DynamicProperty</span></span>{
    <span class="hljs-keyword">init</span>(wrappedValue:<span class="hljs-type">String</span>){
        <span class="hljs-type">UserDefaults</span>.standard.<span class="hljs-keyword">set</span>(wrappedValue, forKey: <span class="hljs-string">"myString"</span>)
    }
    
    <span class="hljs-keyword">var</span> wrappedValue:<span class="hljs-type">String</span>{
        <span class="hljs-keyword">nonmutating</span> <span class="hljs-keyword">set</span>{<span class="hljs-type">UserDefaults</span>.standard.<span class="hljs-keyword">set</span>(newValue, forKey: <span class="hljs-string">"myString"</span>)}
        <span class="hljs-keyword">get</span>{<span class="hljs-type">UserDefaults</span>.standard.string(forKey: <span class="hljs-string">"myString"</span>) ?? <span class="hljs-string">""</span>}
    }
    
    <span class="hljs-keyword">var</span> projectedValue:<span class="hljs-type">Binding</span>&lt;<span class="hljs-type">String</span>&gt;{
        <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">String</span>&gt;(
            <span class="hljs-keyword">get</span>:{<span class="hljs-type">String</span>(<span class="hljs-keyword">self</span>.wrappedValue)},
            <span class="hljs-keyword">set</span>:{
                <span class="hljs-keyword">self</span>.wrappedValue = $<span class="hljs-number">0</span>
        }
        )
    }
    
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"重绘视图"</span>)
    }
}
</code></pre><p>这是一个可以用来包装String类型的State。</p><p>我们使用UserDefault将数据包装后保存到本地。读取包装数据也是从本地的UserDefault里读取的。</p><p>为了能够包装其他的类型的数据，同时也为了能够提高存储效率，进一步的可以修改成如下代码：</p><pre data-language="swift"><code><span class="hljs-meta">@propertyWrapper</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyState</span>&lt;<span class="hljs-title">Value</span>&gt;:<span class="hljs-title">DynamicProperty</span></span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _value:<span class="hljs-type">Value</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _location:<span class="hljs-type">AnyLocation</span>&lt;<span class="hljs-type">Value</span>&gt;?
    
    <span class="hljs-keyword">init</span>(wrappedValue:<span class="hljs-type">Value</span>){
        <span class="hljs-keyword">self</span>._value = wrappedValue
        <span class="hljs-keyword">self</span>._location = <span class="hljs-type">AnyLocation</span>(value: wrappedValue)
    }
    
    <span class="hljs-keyword">var</span> wrappedValue:<span class="hljs-type">Value</span>{
        <span class="hljs-keyword">get</span>{ _location?._value.pointee ?? _value}
        <span class="hljs-keyword">nonmutating</span> <span class="hljs-keyword">set</span>{ _location?._value.pointee = newValue}
    }
    
    <span class="hljs-keyword">var</span> projectedValue:<span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Value</span>&gt;{
        <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Value</span>&gt;(
            <span class="hljs-keyword">get</span>:{<span class="hljs-keyword">self</span>.wrappedValue},
            <span class="hljs-keyword">set</span>:{<span class="hljs-keyword">self</span>._location?._value.pointee = $<span class="hljs-number">0</span>}
        )
    }
    
    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"重绘视图"</span>)
    }
}


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnyLocation</span>&lt;<span class="hljs-title">Value</span>&gt;</span>{
    <span class="hljs-keyword">let</span> _value = <span class="hljs-type">UnsafeMutablePointer</span>&lt;<span class="hljs-type">Value</span>&gt;.allocate(capacity: <span class="hljs-number">1</span>)
    <span class="hljs-keyword">init</span>(value:<span class="hljs-type">Value</span>){
        <span class="hljs-keyword">self</span>._value.pointee = value
    }
}
</code></pre><p>至此，我们完成了这个@MyState的半成品。</p><p>之所以说是半成品，因为尽管我们也遵循了DynamicProperty协议，但我们自己编写的这段代码并不能和视图建立依赖。我们可以和使用@State一样来使用@MyState，同样支持绑定、修改，除了视图不会自动刷新😂。</p><p>但至少我们可以大概了解@State是如何让我们在视图中修改、绑定数据的。</p><h3>什么时候建立的依赖？</h3><p>我目前无法找到任何关于SwiftUI建立依赖的更具体的资料或实现线索。不过我们可以通过下面两段代码来猜测编译器是如何处理数据和视图之间的依赖关联时机的。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MainView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> date: <span class="hljs-type">String</span> = <span class="hljs-type">Date</span>().description
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"mainView"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Form</span> {
            <span class="hljs-type">SubView</span>(date: $date)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"修改日期"</span>) {
                <span class="hljs-keyword">self</span>.date = <span class="hljs-type">Date</span>().description
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SubView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> date: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"subView"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Text</span>(date)
    }
}
</code></pre><p>执行这段代码，我们点击<strong>修改日期</strong> ，我们会得到如下输出</p><pre data-language="bash"><code>mainView
subView
subView
...
</code></pre><p>虽然我们在MainView中使用@State声明了date，并且在MainView中修改了date的值，但由于我们并没有在MainView中使用date的值来进行显示或者判断，所以无论我们如何修改date值，MainView都不会重绘。我推测@State同视图的依赖是在ViewBuilder解析时进行的。编译器在解析我们的body时，会判断date的数据变化是否会对当前视图造成改变。如果没有则不建立依赖关联。</p><p>我们可以用另一段代码来分析编译器对 ObservedObject 的反应。</p><pre data-language="swift"><code><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MainView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">ObservedObject</span> <span class="hljs-keyword">var</span> store = <span class="hljs-type">AppStore</span>()
    
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"mainView"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Form</span> {
            <span class="hljs-type">SubView</span>(date: $store.date)
            <span class="hljs-type">Button</span>(<span class="hljs-string">"修改日期"</span>) {
                <span class="hljs-keyword">self</span>.store.date = <span class="hljs-type">Date</span>().description
            }
        }
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SubView</span>: <span class="hljs-title">View</span> </span>{
    @<span class="hljs-type">Binding</span> <span class="hljs-keyword">var</span> date: <span class="hljs-type">String</span>
    <span class="hljs-keyword">var</span> body: some <span class="hljs-type">View</span> {
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"subView"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-type">Text</span>(date)
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppStore</span>:<span class="hljs-title">ObservableObject</span></span>{
    @<span class="hljs-type">Published</span> <span class="hljs-keyword">var</span> date:<span class="hljs-type">String</span> = <span class="hljs-type">Date</span>().description
}
</code></pre><p>执行后输出如下：</p><pre data-language="bash"><code>mainView
subView
mainView
subView
...
</code></pre><p>我们把@State换成了@ObservedObject ，同样在MainView中并没有显示store.date的值或者用其来做判断，但是只要我们改变了store里的date值，MainView便会刷新重绘。由此可以推测，SwiftUI对于ObservedObject采用了不同的依赖创建时机，只要声明，无论body里是否有需要，在ObservableObject的objectWillChange产生send后，都会进行重绘。因此ObservedObject很可能是在初始化MainView的时候建立的依赖关系。</p><p>之所以花气力来判断这个问题，<strong>因为这两种创建依赖的时机的不同会导致View更新效率的巨大差异。这个差异也正是我下一篇文章要重点探讨的地方</strong>。</p><h2>打造适合自己的增强型 @State</h2><p>@State使用属性包装器这个特性来实现了它既定的功能，不过属性包装器还被广泛用于数据验证、副作用等众多领域，我们能否将众多功能属性集于一身？</p><p>本文我们自己通过代码打造的@State半成品并不能创建和视图的依赖，我们如何才能完成这种依赖关联的创建？</p><p>@State不仅可以被用于对属性的包装，同时State本身也是一个标准的结构体。它通过内部没有暴露的功能接口完成了同视图的依赖创建。</p><p>以下两种使用方式是等效的：</p><pre data-language="swift"><code>@<span class="hljs-type">State</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">""</span>
<span class="hljs-keyword">self</span>.name = <span class="hljs-string">"肘子"</span>
</code></pre><pre data-language="swift"><code><span class="hljs-keyword">var</span> name = <span class="hljs-type">State</span>&lt;<span class="hljs-type">String</span>&gt;(wrappedValue:<span class="hljs-string">""</span>)
<span class="hljs-keyword">self</span>.name.wrappedValue = <span class="hljs-string">"肘子"</span>
</code></pre><p>因此我们可以通过将State作为包装值类型，创建新的属性包装器，来实现我们的最终目标 —— 完整功能、可任意扩展的增强型@State。</p><pre data-language="swift"><code><span class="hljs-meta">@propertyWrapper</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyState</span>&lt;<span class="hljs-title">Value</span>&gt;:<span class="hljs-title">DynamicProperty</span></span>{
    <span class="hljs-keyword">typealias</span> <span class="hljs-type">Action</span> = (<span class="hljs-type">Value</span>) -&gt; <span class="hljs-type">Void</span>
    
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _value:<span class="hljs-type">State</span>&lt;<span class="hljs-type">Value</span>&gt;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> _toAction:<span class="hljs-type">Action?</span>
    
    <span class="hljs-keyword">init</span>(wrappedValue value:<span class="hljs-type">Value</span>){
        <span class="hljs-keyword">self</span>._value = <span class="hljs-type">State</span>&lt;<span class="hljs-type">Value</span>&gt;(wrappedValue: value)
    }
    
    <span class="hljs-keyword">init</span>(wrappedValue value:<span class="hljs-type">Value</span>,toAction:@escaping <span class="hljs-type">Action</span>){
        <span class="hljs-keyword">self</span>._value = <span class="hljs-type">State</span>&lt;<span class="hljs-type">Value</span>&gt;(wrappedValue: value)
        <span class="hljs-keyword">self</span>._toAction = toAction
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> wrappedValue: <span class="hljs-type">Value</span> {
        <span class="hljs-keyword">get</span> {<span class="hljs-keyword">self</span>._value.wrappedValue}
        <span class="hljs-keyword">nonmutating</span> <span class="hljs-keyword">set</span> {<span class="hljs-keyword">self</span>._value.wrappedValue = newValue}
    }÷
    
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> projectedValue: <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Value</span>&gt;{
        <span class="hljs-type">Binding</span>&lt;<span class="hljs-type">Value</span>&gt;(
            <span class="hljs-keyword">get</span>: {<span class="hljs-keyword">self</span>._value.wrappedValue},
            <span class="hljs-keyword">set</span>: {
                <span class="hljs-keyword">self</span>._value.wrappedValue = $<span class="hljs-number">0</span>
                <span class="hljs-keyword">self</span>._toAction?($<span class="hljs-number">0</span>)
        }
        )
    }
    
    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">update</span><span class="hljs-params">()</span></span> {
       <span class="hljs-built_in">print</span>(<span class="hljs-string">"视图重绘"</span>)
    }
    
    
}
</code></pre><p>这段代码仅作为一个例子，可以根据自己的需求任意创建自己所需的功能。</p><pre data-language="swift"><code>@<span class="hljs-type">MyState</span> <span class="hljs-keyword">var</span> name = <span class="hljs-string">"hello"</span>  <span class="hljs-comment">//实现和标准@State一样的功能</span>
</code></pre><pre data-language="swift"><code>@<span class="hljs-type">MyState</span>&lt;<span class="hljs-type">String</span>&gt;(
  wrappedValue: <span class="hljs-string">"hello"</span>, 
  toAction: {<span class="hljs-built_in">print</span>($<span class="hljs-number">0</span>)}
) <span class="hljs-keyword">var</span> name
<span class="hljs-comment">//在每次赋值后（包括通过Binding修改）执行 toAction 定义的函数</span>
</code></pre><h2>接下来？</h2><p>在响应式编程开始流行的今天，越来越多的人都在使用单一数据源（Single Souce of Truth）的构架方式进行设计和开发。如何使用@State这种作用域范围仅限于当前视图的特性？仅从命名来看，苹果给了他最本质的名称——State。State属于SwiftUI架构，ObservableObject属于Combine架构，SwiftUI明显对于State的优化要好于ObservableObject。如何在满足单一数据源的情况下最大限度享受SwiftUI的优化便利？我将在下一篇文章中进行进一步探讨。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/vapor4</guid><title>Vapor4 的安装与配置</title><description>本文介绍了如何在mac 10.5.4和ubuntu 18.04下安装Vapor命令行工具，创建Vapor项目，简单的调试项目以及如何部署到生产环境的过程。文中的运行环境为: Vapor4,Swift5.2,Catalina 10.5.4,Ubuntu18.04</description><link>http://www.fatbobman.com/posts/vapor4</link><pubDate>Thu, 7 May 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<blockquote><p>本文介绍了如何在mac 10.5.4和ubuntu 18.04下安装Vapor命令行工具，创建Vapor项目，简单的调试项目以及如何部署到生产环境的过程。文中的运行环境为: Vapor4,Swift5.2,Catalina 10.5.4,Ubuntu18.04</p></blockquote><p>最近新开通了一个云服务器（Linux系统），使用<a href="https://hexo.io/zh-cn/index.html/">Hexo</a>创建了新的博客网页。考虑增加点简单的交互功能，所以需要在服务器端添加逻辑处理能力。由于近半年来基本上都是在使用Swift，所以打算尝试一下Server Side Swift。没有太仔细选择各种框架，看过几个介绍Vapor使用的视频后，感觉不错，便开始尝试安装配置。</p><p>Vapor的官方文档实在是有很大的问题，网上的不少心得、教程又有点陈旧（目前版本调整较大）。通过两天的折腾，终于基本上理出了脉络，初步搭建了开发和生产环境。</p><h2>什么是Vapor</h2><p><a href="https://github.com/vapor/vapor">Vapor</a>是一个使用swift语言编写的Web网络框架，它是跨平台的（mac、Linux），用户可以使用swift语言以及其丰富的第三方库来高效的完成多种网络服务。</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> Vapor

<span class="hljs-keyword">let</span> app = <span class="hljs-keyword">try</span> <span class="hljs-type">Application</span>()
<span class="hljs-keyword">let</span> router = <span class="hljs-keyword">try</span> app.make(<span class="hljs-type">Router</span>.<span class="hljs-keyword">self</span>)

router.<span class="hljs-keyword">get</span>(<span class="hljs-string">"hello"</span>) { req <span class="hljs-keyword">in</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, world."</span>
}

<span class="hljs-keyword">try</span> app.run()
</code></pre><p>上面的代码变可以完成一个最基本的网络服务。访问 <code>http://localhost:8080/hello</code> 网页返回 <em>hello, world.</em></p><p>你可以在mac或Linux平台上开发，同时也可以将通过Vapor框架开发的项目部署到mac或Linux平台上。</p><h2>什么是Vaper 命令行工具</h2><p>Vaper命令行工具的作用有：</p><ul><li>基于模板创建Vaper项目</li><li>配置、编译、运行项目</li><li>其他配合操作系统的一些功能</li></ul><p>但它不是必须的，如果用户已经很熟悉Vapor的开发和配置，无论是在开发环境还是运行环境都可以不使用这个命令行工具。不过对于像我这样的新手来说，无疑它是一个好的帮手。</p><h3>开发Vaper项目需要的资源</h3><ul><li>mac 或 Linux ，我目前在Catalina 10.5.4 和 Ubuntu 18.04下都成功完成了配置</li><li>swift语言环境，目前Vapor4可以在swift5.2下运行</li><li>web服务器，我目前使用Nginx （如果只是用于开发测试，也可以不配置）</li></ul><h2>安装swift</h2><h3>Mac</h3><p>在mac平台下，安装Xcode及Xcode ommand Line Tools，Vapor4对xcode提供了非常友好的支持，可以像其他的swift项目一样使用全部的Xcode的各种能力（比如断点调试）。</p><h4>Ubuntu 18.04</h4><pre data-language="bash"><code>sudo apt-get install clang
sudo apt-get install libcurl3 libpython2.7 libpython2.7-dev 

<span class="hljs-comment">#从swift.org找到需要的文件</span>

wget https://swift.org/builds/swift-5.2.3-release/ubuntu1804/swift-5.2.3-RELEASE/swift-5.2.3-RELEASE-ubuntu18.04.tar.gz

tar xzvf swift-5.2.3-RELEASE-ubuntu18.04.tar.gz
sudo mv swift-5.2.3-RELEASE-ubuntu18.04 /usr/share/swift

<span class="hljs-built_in">echo</span> <span class="hljs-string">"export PATH=/usr/share/swift/usr/bin:<span class="hljs-variable">$PATH</span>"</span> &gt;&gt; ~/.bashrc
<span class="hljs-built_in">source</span>  ~/.bashrc
</code></pre><p>我也使用过Docker安装Swift5.2，不过Image有点太大，需要1.2Gb左右的空间。</p><pre data-language="bash"><code><span class="hljs-comment">#Docker安装Swift的方法。</span>
docker pull swift
</code></pre><h2>安装Vapor命令行工具</h2><h3>MacOS</h3><pre data-language="shell"><code>brew tap vapor/tap
brew install vapor
<span class="hljs-meta">#</span><span class="bash">我目前安装的是 vapor-beta</span>
<span class="hljs-meta">#</span><span class="bash">brew install vapor-beta</span>
<span class="hljs-meta">#</span><span class="bash">执行vapor测试一下</span>
vapor
</code></pre><h3>Ubuntu 1804</h3><p>Ubuntu下安装Vapor toolbox略微麻烦，主要是目前的Vapor Toolbox源文件有点问题需要做一些修改才能正常编译。</p><p>首先保证已成功安装 <strong>swift</strong></p><pre data-language="bash"><code><span class="hljs-built_in">cd</span> ~
git <span class="hljs-built_in">clone</span> https://github.com/vapor/toolbox.git
<span class="hljs-built_in">cd</span> toolbox
</code></pre><p>在 Test 目录下 创建一个 <strong>LinuxMain.swift</strong> 文件</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> XCTest
<span class="hljs-meta">@testable</span> <span class="hljs-keyword">import</span> AppTests
<span class="hljs-type">XCTMain</span>([testCase(<span class="hljs-type">AppTests</span>.allTests)])
</code></pre><p><strong><em>这个是Swift SPM需要的文件，上面我只写了个最简单的能够完成编译即可，不清楚为什么官方的git源不包含这个文件。</em></strong></p><p>修改 Source/VaporToolbox/exec.swift 文件</p><p>在36行左右（当前版本）找到</p><pre data-language="undefined"><code>
let spawned = posix_spawnp(&pid, argv[0], &fileActions, nil, argv + [nil], envp + [nil])
</code></pre><p>修改成</p><pre data-language="swift"><code><span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> _argv0 = argv[<span class="hljs-number">0</span>] <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">fatalError</span>(<span class="hljs-string">"unwrap error"</span>)
        }
<span class="hljs-keyword">let</span> spawned = posix_spawnp(&amp;pid, _argv, &amp;fileActions, <span class="hljs-literal">nil</span>, argv + [<span class="hljs-literal">nil</span>], envp + [<span class="hljs-literal">nil</span>])
</code></pre><p><strong><em>同样不清楚为什么代码会有这么一个错误。</em></strong></p><p>完成上述修改后</p><pre data-language="bash"><code><span class="hljs-built_in">cd</span> ~/toolbox
swift build -c release --<span class="hljs-built_in">disable</span>-sandbox
sudo mv .build/release/vapor /usr/<span class="hljs-built_in">local</span>/bin
</code></pre><p><em>以上步骤在我本地的Ubuntu上已可正常编译，不过在我的腾讯云主机上，编译时会缺少一个相关库，添加上后即可正常编译。</em></p><pre data-language="bash"><code>sudo apt-get install libcurl4 -y
</code></pre><p>至此Vapor Toolbox 安装完毕。</p><p><em>Toolbox的目录中包含了Dockerfile，使用它可以直接将toolbox生成一个Docker Image，并且系统会自动下载swift的Docker Image。不过我在Ubuntu上使用这种方法安装后（已配置entrypoint），vapor的Image没有名字，只有container id，但是可以通过id来运行。个人目前不推荐这种方式。</em></p><h2>使用 Vapor命令行工具</h2><h3>创建项目</h3><pre data-language="bash"><code><span class="hljs-comment">#vapor new &lt;projectname&gt; [--template]</span>
vapor new hello
</code></pre><p>使用缺省模板创建一个名为 hello 的Vapor项目。</p><p>创建的过程其实就是从github上clone一个模板，并可帮你进行简单配置。如果已经比较熟悉的话也可以不适用工具，直接从github上<a href="https://github.com/vapor?q=template&type=&language=">克隆模板</a>开始项目。</p><p>在Mac系统下，模板可以直接编译运行，不过Linux下，git源仍然缺少 <strong>LinuxMain.swift</strong> 文件，按照上面的方法，在项目中加入该文件后方可编译。</p><p>clone完成后，系统会有如下提示：</p><pre data-language="bash"><code>Would you like to use Fluent? y
数据库类型选择 <span class="hljs-comment">#我选择了 sqllite</span>
</code></pre><p>系统会根据你的选择直接在模板中创建好相应的代码。（<a href="https://github.com/vapor/fluent">Fluent</a> 是一个swift写的ORM）</p><h3>编译项目</h3><pre data-language="bash"><code><span class="hljs-built_in">cd</span> ~/hello
vapor build
</code></pre><p>我在ubuntu下执行<strong>vapor new</strong>可以正常执行，不过<strong>vapor build</strong>执行报错。因此就直接使用 <strong>swift build</strong> 来编译项目。其实<strong>build</strong> 和 <strong>run</strong> 都是直接调用的 <strong>swift</strong> 命令。</p><h3>运行项目</h3><pre data-language="bash"><code>vapor run 
<span class="hljs-comment">#系统显示，说明项目已正常启动。可以通过 http://127.0.0.1:8080 访问</span>
Environment(name: <span class="hljs-string">"development"</span>, arguments: [<span class="hljs-string">".build/x86_64-apple-macosx/debug/Run"</span>])
[ NOTICE ] Server starting on http://127.0.0.1:8080
</code></pre><p>可以在运行命令后面添加运行状态，对于部署尤为重要。</p><pre data-language="bash"><code>vapor run --env prod 
<span class="hljs-comment"># test prod dev 对应不同的状态，主要关系到是否显示操作日志等</span>
</code></pre><p>如果是Mac系统，使用</p><pre data-language="bash"><code>vapor xcode 
</code></pre><p>直接打开Xcode，然后就可以直接在Xcode下编辑、编译、调试、运行。</p><p>即使没有安装Vapor Toolbox也可以使用如下命令创建Xcode项目</p><pre data-language="bash"><code>swift package generate-xcodeproj
</code></pre><p>按照上述的步骤安装后，无论在Mac上还是Ubuntu上我们都可以开始编写并运行自己的Vapor项目了。</p><h2>模板项目简单分析</h2><p>本节我们通过对模板代码的简单分析来快速感受一下Vapor的便捷。</p><p>我使用的是项目缺省模板，启用Fluent，数据库选择的是sqlite。</p><p>项目源文件存在Sources目录下。</p><img src="http://cdn.fatbobman.com/vapor4-struct.png" alt="目录结构"/><p><strong>main.swift</strong>作为程序的入口，创建了Vapor服务</p><p><strong>configure.swift</strong>中由于我们选择了使用sqlite，因此系统为我们自动生成了使用数据库所需的代码。下列代码完成数据库的创建工作。</p><pre data-language="swift"><code>app.migrations.add(<span class="hljs-type">CreateTodo</span>())
</code></pre><p>为了能够完整的运行这个模板项目，我们需要在命令行执行</p><pre data-language="bash"><code>vapor run migrate
</code></pre><p>系统将在项目根目录下完成db.sqlite里的表创建工作。如果没有执行这个步骤，访问 localhost:8080/todos 将在得到如下的错误提示。</p><pre data-language="bash"><code>[ ERROR ] error: no such table: todos
</code></pre><p><strong>Xcode的用户也可以直接在Scheme中的Arguments添加 --auto-migrate 完成上述功能。</strong></p><p><strong>另外，最好在Xcode中将Scheme -- Run -- Working Directory设置成当前项目的根目录，这样无论使用命令行，还是直接使用Xcode都可以使用同一个Sqlite文件。</strong></p><pre data-language="swift"><code><span class="hljs-comment">//app.middleware.use(FileMiddleware(publicDirectory: app.directory.publicDirectory))</span>
</code></pre><p>如果取消这一句的注释，Vapor将提供对静态文件的支持。我们可以把静态文件放入项目根目录的 Public目录中，即可访问。 127.0.0.1:8080/index.html 。如果和其他WebServer配合使用的话，我感觉还是用如Nginx来提供静态文件的支持比较好。</p><p>routes.swift**作为项目的核心，在其中完成网络的路由逻辑设定。</p><pre data-language="swift"><code><span class="hljs-keyword">import</span> Fluent
<span class="hljs-keyword">import</span> Vapor

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">routes</span><span class="hljs-params">(<span class="hljs-number">_</span> app: Application)</span></span> <span class="hljs-keyword">throws</span> {
    <span class="hljs-comment">/*
    访问  127.0.0.1:8080/  返回：It works!
    */</span>
    app.<span class="hljs-keyword">get</span> { req <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"It works!"</span>
    }
    
    <span class="hljs-comment">//   localhost:8080/hello    返回: "Hello world"</span>
    app.<span class="hljs-keyword">get</span>(<span class="hljs-string">"hello"</span>) { req -&gt; <span class="hljs-type">String</span> <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, world!"</span>
    }

    <span class="hljs-keyword">let</span> todoController = <span class="hljs-type">TodoController</span>()
    <span class="hljs-comment">/*
    以下操作我使用postman进行测试
    post 127.0.0.1:8080/todos body内容: {"title":"东坡肘子"}  添加一条记录
    get 127.0.0.1:8080/todos 显示已添加的记录
    del 127.0.0.1:8080/todos/B508471F-FF5F-422C-B384-C300FD7B49D9 删除一条记录。id使用显示记录获取
    */</span>
    app.<span class="hljs-keyword">get</span>(<span class="hljs-string">"todos"</span>, use: todoController.index)
    app.post(<span class="hljs-string">"todos"</span>, use: todoController.create)
    app.delete(<span class="hljs-string">"todos"</span>, <span class="hljs-string">":todoID"</span>, use: todoController.delete)
}
</code></pre><p>更具体的应用就不展开了。不过仅从模板例程上我们便可以感觉到Vapor的便利和高效。</p><h2>和Nginx 配合使用</h2><p>通过编辑nginx的配置文件，我们的Vapor项目便可以对外发布了。</p><pre data-language="nginx"><code><span class="hljs-section">server</span> {
        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;
        <span class="hljs-attribute">server_name</span>  localhost;
  
        <span class="hljs-attribute">location</span> / {
          <span class="hljs-attribute">root</span>   html;
          <span class="hljs-attribute">index</span>   index.html index.htm;
          <span class="hljs-attribute">try_files</span>  <span class="hljs-variable">$uri</span> <span class="hljs-variable">@proxy</span>;
        }

        <span class="hljs-attribute">location</span> <span class="hljs-variable">@proxy</span> {
               <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080;
               <span class="hljs-attribute">proxy_pass_header</span> Server;
               <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;
               <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;
               <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;
               <span class="hljs-attribute">proxy_pass_header</span> Server;
               <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">3s</span>;
               <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">10s</span>;
}
</code></pre><p>现在你就可以通过 <code>http://你的域名或地址/todos</code> 来访问你的项目。</p><p>我使用Vapor的目的是为了配合自己的博客，所以仍需配合我自己原有的页面使用，所以采用了如下的配置。</p><p>即使打开了Vapor的静态页面支持，如果我把Vapor项目配置在/的话（已取消Vapor对根的响应），仍然需要明确的输入 <code>http://我的域名/index.html</code>才能访问到索引页面。没有办法才把他转到 /api/下。</p><pre data-language="nginx"><code><span class="hljs-section">server</span> {
        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;
        <span class="hljs-attribute">server_name</span>  localhost;
  
        <span class="hljs-attribute">location</span> / {
            <span class="hljs-attribute">root</span>   html;
            <span class="hljs-attribute">index</span>  index.html index.htm;
        }

        <span class="hljs-attribute">location</span> /api {
          <span class="hljs-attribute">root</span>   html;
          <span class="hljs-attribute">index</span>   index.html index.htm;
          <span class="hljs-attribute">try_files</span>  <span class="hljs-variable">$uri</span> <span class="hljs-variable">@proxy</span>;
        }

        <span class="hljs-attribute">location</span> <span class="hljs-variable">@proxy</span> {
               <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:8080;
               <span class="hljs-attribute">proxy_pass_header</span> Server;
               <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;
               <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;
               <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;
               <span class="hljs-attribute">proxy_pass_header</span> Server;
               <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">3s</span>;
               <span class="hljs-attribute">proxy_read_timeout</span> <span class="hljs-number">10s</span>;
}
</code></pre><p>如此配置后，需要对代码 routes.swift 进行改动后即可正常访问。</p><pre data-language="swift"><code>app.<span class="hljs-keyword">get</span>(<span class="hljs-string">"api"</span>,<span class="hljs-string">"hello"</span>) { req -&gt; <span class="hljs-type">String</span> <span class="hljs-keyword">in</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello, world!"</span>
    }
</code></pre><p>如果谁知道如何设置能够直接将/转发到Vapor而又可以 直接使用 http://我的域名 来访问原有的页面烦请告知一下。</p><h2>部署</h2><h3>修改运行端口</h3><p>Vapor4对于指定运行端口和之前有了较大的区别。</p><p>在main.swift中做如下修改</p><pre data-language="swift"><code>app.http.server.configuration.hostname = <span class="hljs-string">"127.0.0.1"</span> <span class="hljs-comment">//响应的地址 0.0.0.0 </span>
app.http.server.configuration.port = <span class="hljs-number">8000</span> <span class="hljs-comment">//希望设定的端口</span>
<span class="hljs-keyword">try</span> configure(app)
</code></pre><p>目前我没有找到如何在命令行下设置运行端口（Vapor3之前的方法好像已经不支持了）。如果有人了解烦请告知一下。</p><h3>手动部署</h3><p>由于我目前也还刚刚开始接触Vapor，为了调试方便，我在本机的Xcode下进行开发。通过github作为中转，将本地的修改commit到repository上。手动在服务器端fetch并执行。在终端中执行的话当前终端将被任务锁定。</p><h3>Docker部署</h3><p>另外，Vapor的模板本身已经生成了Dockerfile。也可以直接将完成后的项目生成Docker Image。这种方式可以将项目发布到任何支持Docker的平台（mac、Linux、windows等）。不过通常只适用于已经开发完善后的部署。更多细节可查阅<a href="https://docs.vapor.codes/4.0/deploy/docker/">官方文档</a></p><h3>Supervisior</h3><p>Vapor Toolbox 已提供了对 <a href="http://supervisord.org">Supervisior</a> 的支持,可以很方便的通过supervisor来管理服务。</p><p>ubuntu下安装Supervisor</p><pre data-language="bash"><code>sudo apt-get update
sudo apt-get install supervisor
</code></pre><p>我们需要为每一个项目创建一个supervisor配置文件。创建/etc/supervisor/conf.d/hello.conf</p><pre data-language="bash"><code>[program:hello]
<span class="hljs-built_in">command</span>=/home/parallels/hello/.build/release/Run serve --env production
directory=/home/parallels/hello
user=parallels
stdout_logfile=/var/<span class="hljs-built_in">log</span>/supervisor/%(program_name)-stdout.log
stderr_logfile=/var/<span class="hljs-built_in">log</span>/supervisor/%(program_name)-stderr.log
</code></pre><p>文件名是你的项目名.conf，目录指向你项目的根目录并设置好用户名</p><pre data-language="bash"><code><span class="hljs-built_in">command</span>=/home/parallels/hello/.build/release/Run serve --env production
</code></pre><p>需确定已将项目编译成release版本，如果vapor build不好用，可以使用如下命令</p><pre data-language="bash"><code><span class="hljs-built_in">cd</span> ~/hello
swift build -c release
</code></pre><p>通过supervisor管理项目</p><pre data-language="bash"><code>supervisorctl reread
supervisorctl add hello
supervisorctl start hello
</code></pre><p>也可以通过supervisor的配置来指定运行端口</p><p>在/etc/supervisor/conf.d/hello.conf中加入</p><pre data-language="bash"><code>environment=PORT=8123
</code></pre><p>修改 main.swift</p><pre data-language="swift"><code><span class="hljs-keyword">let</span> port = <span class="hljs-type">Environment</span>.<span class="hljs-keyword">get</span>(<span class="hljs-string">"PORT"</span>) ?? <span class="hljs-string">""</span>
app.http.server.configuration.port = <span class="hljs-type">Int</span>(port) ?? <span class="hljs-number">8080</span>
</code></pre><h2>结语</h2><p>希望本文能够对你开始使用Vapor4带来一点帮助。同时也希望swift能在更多的平台上有所表现。</p><p>swift已有更多的官方对window支持的迹象。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/posts/first-post</guid><title>时隔多年，重新创建了博客</title><description>用Hexo创建了一个博客，主要记录自己在开发健康笔记过程中的一点心得和技术总结。</description><link>http://www.fatbobman.com/posts/first-post</link><pubDate>Thu, 30 Apr 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<p>用Hexo创建了一个博客，主要记录自己在开发健康笔记过程中的一点心得和技术总结。</p>]]></content:encoded></item><item><guid isPermaLink="true">http://www.fatbobman.com/project/healthnotes</guid><title>健康笔记</title><description>健康笔记是一个可以记录和管理全家人身体健康数据的iOS app。拥有多人管理、图表分析、多种数据类型、隐私保护、云存储等特性。</description><link>http://www.fatbobman.com/project/healthnotes</link><pubDate>Thu, 16 Jan 2020 12:00:00 +0800</pubDate><content:encoded><![CDATA[<h2>起因</h2><p>之前由于身体原因，我有5年左右的时间基本上都待在家里极少外出。因为治疗的需要，每天都要记录大量的治疗数据以及用药情况。很幸运的是，我的妻子承担了其中大部分的工作，转眼之间便记录了好多个笔记本。</p><p>经过几次手术和治疗，我的身体已经恢复大半，但由于仍要终身服药及定期检查，所以每天还是要记录很多的身体指标以及各种检查、检验数据。</p><p>我也曾尝试使用电子表格或其他的电脑工具来辅助记录，但并不方便。试图寻找相关的手机应用，并没有找到贴切的。</p><p>在这期间，苹果手机的健康应用对我的帮助不小。由于使用了支持自动导入数据的一些测量设备，类似体重、体温、体脂、血压等都会自动的导入到手机中，帮助我整理和分析。</p><p>但系统的健康应用可以录入的数据种类是固定的，我大量日常的数据均无法通过其录入。</p><p>在身体好转了的情况下，我开始考虑自己开发一款能够满足需求的应用。但毕竟已经10多年没接触代码了，真正开始启动这个项目还是很下了不小的决心和功夫。</p><p>通过近半年的学习和开发，健康笔记（Health Notes）就这样逐渐有了些模样。由于受到系统的健康应用很大的影响，健康笔记里的很多布局都和其都有相似之处。</p><p>2020年,健康笔记2.0发布了. 2.0版做出了重大的升级.</p><h2>健康笔记主要的特点</h2><ul><li>多笔记管理 可针对不同用途、不同人群的数据分开记录。允许用户创建多个笔记本，方便您根据自己的需要进行归纳。</li><li>可随意自定义条目使用者可在健康笔记中记录多种类型的数据。能够满足你生活中绝大多数情况下的需要。 每个人所面对的数据内容都有极大的不同，无论怎么专业的机构都无法完全涵盖用户所需要面对的数据种类。健康笔记允许用户自定义条目内容，您可以任意创建自己所需的健康数据条目。</li><li>完善的图表机制 2.0新增了更多的图表显示方式已应对更多的数据种类</li><li>不仅记录数据 健康笔记同时提供完善的文字记录能力，无论是对个别数据的单独备注还是记录生活中的大事小情，都可轻松应对。</li><li>对自己的数据有绝对的控制权 健康笔记可将用户录入的数据按需导出。通过导出成xls,csv格式的文件供其他软件使用。</li><li>云存储，数据永久保存 数据保存在云服务器上，同时支持多机同步，数据安全有保障。</li><li>iPad的全面优化方便使用者更好的利用iPad的屏幕优势，数据管理更加轻松 希望你们将更多的意见和建议更多的反馈给我，帮助健康笔记更好的成长。</li></ul><p>在这里可以下载 <a href="https://apps.apple.com/us/app/health-notes-2/id1534513553"><img src="http://cdn.fatbobman.com/appStoreIcon.svg" alt="pic"/></a></p>]]></content:encoded></item></channel></rss>